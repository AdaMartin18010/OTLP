% Section 3: Formal Verification Framework

\section{Formal Verification Framework}
\label{sec:framework}

This section presents our comprehensive formal verification framework for \otlp. We describe the mathematical foundations, verification techniques, and how they work together to ensure correctness and consistency of OTLP-based distributed tracing systems.

\subsection{Framework Overview}
\label{sec:framework-overview}

Our verification framework consists of five interconnected components, each addressing specific aspects of \otlp correctness:

\textbf{Architecture}: Figure~\ref{fig:framework} illustrates the overall architecture. \otlp data streams flow through our verification framework, which applies five complementary verification techniques at different abstraction levels.

% TODO: Add Figure 2 - Framework Architecture (from PAPER_FIGURES_TIKZ.md)

Each component operates at a different abstraction level:

\begin{enumerate}
\item \textbf{Type System} (Section~\ref{sec:type-system}): Ensures that \otlp data structures are well-formed and type-correct. Detects violations like invalid trace IDs, missing required fields, or type mismatches.

\item \textbf{Algebraic Structures} (Section~\ref{sec:algebra}): Models data composition and aggregation using monoids, lattices, and category theory. Ensures that combining spans or traces preserves essential properties.

\item \textbf{Triple Flow Analysis} (Section~\ref{sec:flow}): Tracks control flow (call hierarchy), data flow (context propagation), and execution flow (temporal ordering). Detects causality violations and context loss.

\item \textbf{Temporal Logic} (Section~\ref{sec:temporal}): Specifies and verifies system-wide properties using LTL and CTL. Examples include ``all spans eventually complete'' or ``errors are always logged.''

\item \textbf{Semantic Validation}: Checks compliance with \otlp semantic conventions (e.g., attribute naming, value constraints).
\end{enumerate}

These components are not independent---they interact and reinforce each other. For example, the type system provides input to flow analysis, which in turn informs temporal logic verification.

\textbf{Design Principles}:

\begin{itemize}
\item \textbf{Composability}: Each component can be used independently or combined for comprehensive verification.
\item \textbf{Incrementality}: Verification can be performed on partial traces or streaming data, not just complete traces.
\item \textbf{Practicality}: The framework is designed for real-world deployment, balancing rigor with performance.
\item \textbf{Extensibility}: New verification rules or properties can be added without redesigning the framework.
\end{itemize}

\subsection{Type System}
\label{sec:type-system}

Our type system ensures structural correctness of \otlp data. We use a combination of dependent types, refinement types, and type soundness proofs.

\subsubsection{Core Type Definitions}

\textbf{Trace Context Types}:

We define basic \otlp types using refinement types:

\begin{align*}
\text{TraceID} &= \text{Bytes}[16] \\
\text{SpanID} &= \text{Bytes}[8] \\
\text{TraceFlags} &= \text{Bits}[8] \\
\text{SpanContext} &= \{ \text{trace\_id}: \text{TraceID}, \text{span\_id}: \text{SpanID}, \\
                   &\quad \text{trace\_flags}: \text{TraceFlags}, \text{trace\_state}: \text{String} \}
\end{align*}

\textbf{Span Types with Refinements}:

We use dependent types to express invariants:

\begin{align*}
\text{Timestamp} &= \{t: \text{Int64} \mid t \geq 0\} \\
\text{Span} &= \{ \text{context}: \text{SpanContext}, \\
            &\quad \text{parent\_id}: \text{Option}[\text{SpanID}], \\
            &\quad \text{name}: \{s: \text{String} \mid 1 \leq \text{len}(s) \leq 256\}, \\
            &\quad \text{start\_time}: \text{Timestamp}, \\
            &\quad \text{end\_time}: \{t: \text{Timestamp} \mid t \geq \text{start\_time}\} \}
\end{align*}

\textbf{Key Properties}:

\begin{enumerate}
\item \textbf{Non-negative Timestamps}: $\text{Timestamp} = \{t: \text{Int64} \mid t \geq 0\}$ prevents invalid negative timestamps.

\item \textbf{Causality Constraint}: $\text{end\_time}: \{t \mid t \geq \text{start\_time}\}$ ensures spans don't end before they start.

\item \textbf{Bounded Strings}: Span names are 1--256 characters, preventing empty or excessively long names.

\item \textbf{Type-safe IDs}: TraceID and SpanID are distinct types, preventing accidental misuse.
\end{enumerate}

\subsubsection{Dependent Types for Parent-Child Relationships}

A critical correctness property is that every span (except root spans) must have a valid parent. We encode this using dependent types:

\begin{align*}
\text{TraceStore} &= \text{Map}[\text{TraceID}, \text{Set}[\text{Span}]] \\
\text{ValidSpan}[\text{store}] &= \{s: \text{Span} \mid \\
&\quad (s.\text{parent\_id} = \text{None}) \lor \\
&\quad (\exists \text{ parent} \in \text{store}[s.\text{context}.\text{trace\_id}]. \\
&\quad\quad \text{parent}.\text{context}.\text{span\_id} = s.\text{parent\_id} \land \\
&\quad\quad \text{parent}.\text{start\_time} \leq s.\text{start\_time} \land \\
&\quad\quad \text{parent}.\text{end\_time} \geq s.\text{start\_time}) \}
\end{align*}

This dependent type ensures that:

\begin{itemize}
\item Root spans have no parent ($\text{parent\_id} = \text{None}$)
\item Non-root spans have a parent in the same trace
\item The parent starts before or when the child starts
\item The parent is still active when the child starts (allowing for asynchronous spawning)
\end{itemize}

\textbf{Theorem 1 (Type Soundness)}:
If a span $s$ is well-typed under our type system ($\vdash s : \text{ValidSpan}[\text{store}]$), then:

\begin{enumerate}
\item All structural invariants hold (IDs have correct length, timestamps are valid)
\item If $s$ is not a root span, its parent exists and satisfies causality constraints
\item All attributes conform to their expected types
\end{enumerate}

\emph{Proof}: By induction on the structure of the type checking algorithm. See supplementary material for the full proof.

\subsection{Triple Flow Analysis}
\label{sec:flow}

Triple flow analysis tracks three types of flows through distributed tracing systems: control flow, data flow, and execution flow. Together, they ensure causality preservation and context propagation correctness.

\subsubsection{Control Flow Analysis (CFA)}

Control flow analysis constructs the call graph of spans, representing which operations invoke which others.

\textbf{Call Graph Definition}:

\begin{align*}
\text{CallGraph} &= (V, E) \text{ where} \\
V &= \text{Set}[\text{Span}] \\
E &= \{(p, c) \mid c.\text{parent\_id} = \text{Some}(p.\text{context}.\text{span\_id})\}
\end{align*}

\textbf{Properties to Verify}:

\begin{enumerate}
\item \textbf{Acyclicity}: The call graph must be a Directed Acyclic Graph (DAG). A cycle would indicate a logical impossibility.

\item \textbf{Connectedness}: Within a trace, all spans should be reachable from the root span.

\item \textbf{Span Kind Consistency}: Parent-child relationships should respect span kinds (e.g., CLIENT spans typically have corresponding SERVER child spans).
\end{enumerate}

\subsubsection{Data Flow Analysis (DFA)}

Data flow analysis tracks how trace context propagates across service boundaries.

\textbf{Context Flow}:

\begin{align*}
\text{ContextFlow} &= (S, F) \text{ where} \\
S &= \text{Set}[\text{Service}] \\
F &= \{(s_1, s_2, \text{ctx}) \mid \text{service } s_1 \text{ sends context ctx to service } s_2\}
\end{align*}

\textbf{Properties to Verify}:

\begin{enumerate}
\item \textbf{Context Preservation}: When a service calls another, the trace context must be propagated.

\item \textbf{Context Consistency}: The trace ID must remain constant within a trace; span IDs must be unique.

\item \textbf{No Context Corruption}: Context values must not be modified or truncated during propagation.
\end{enumerate}

\subsubsection{Execution Flow Analysis}

Execution flow analysis tracks the temporal ordering of events, ensuring that causality is preserved even in the presence of clock drift and out-of-order arrival.

\textbf{Happens-Before Relation}:

We define a happens-before relation $\rightarrow$ based on span relationships:

\begin{align*}
s_1 \rightarrow s_2 \iff &(s_1 \text{ is an ancestor of } s_2 \text{ in the call graph}) \land \\
                         &(s_1.\text{start\_time} \leq s_2.\text{start\_time})
\end{align*}

\textbf{Causality Invariant}:

For any two spans $s_1$ and $s_2$ in the same trace:

\[
\text{If } s_1 \rightarrow s_2 \text{ then } s_1.\text{start\_time} \leq s_2.\text{start\_time}
\]

\textbf{Clock Drift Tolerance}:

In practice, we allow a tolerance $\delta$ (e.g., 50ms) to account for clock drift:

\[
\text{If } s_1 \rightarrow s_2 \text{ then } s_1.\text{start\_time} \leq s_2.\text{start\_time} + \delta
\]

\textbf{Theorem 2 (Causality Preservation)}:
If a trace passes execution flow analysis with tolerance $\delta$, then for any two spans $s_1$ and $s_2$ where $s_1$ is an ancestor of $s_2$, we have:

\[
s_1.\text{start\_time} \leq s_2.\text{start\_time} + \delta
\]

\subsection{Algebraic Structures}
\label{sec:algebra}

Algebraic structures provide a mathematical framework for reasoning about composition and aggregation of telemetry data. We use monoids for span composition, lattices for trace aggregation, and category theory for interoperability.

\subsubsection{Monoid Structure for Span Composition}

\textbf{Definition}: A monoid is a set $M$ with a binary operation $\oplus: M \times M \rightarrow M$ and an identity element $\varepsilon \in M$ such that:

\begin{enumerate}
\item \textbf{Associativity}: $(a \oplus b) \oplus c = a \oplus (b \oplus c)$ for all $a, b, c \in M$
\item \textbf{Identity}: $\varepsilon \oplus a = a \oplus \varepsilon = a$ for all $a \in M$
\end{enumerate}

\textbf{Span Composition Monoid}:

We define a monoid $(\text{Span}^*, \oplus, \varepsilon)$ where:

\begin{itemize}
\item $\text{Span}^*$ = partial spans (spans with possibly incomplete information)
\item $\oplus$ = attribute merging operation
\item $\varepsilon$ = empty span (identity)
\end{itemize}

\textbf{Why Monoid Properties Matter}:

\begin{enumerate}
\item \textbf{Associativity} means we can compose spans in any order: $(s_1 \oplus s_2) \oplus s_3 = s_1 \oplus (s_2 \oplus s_3)$. This is crucial for distributed systems where spans may arrive out of order.

\item \textbf{Identity} means an empty span doesn't change composition: $s \oplus \varepsilon = \varepsilon \oplus s = s$. This simplifies handling of optional or missing spans.
\end{enumerate}

\textbf{Theorem 3 (Span Composition Associativity)}:
The span composition operation $\oplus$ is associative: for any spans $s_1, s_2, s_3$,

\[
(s_1 \oplus s_2) \oplus s_3 = s_1 \oplus (s_2 \oplus s_3)
\]

\emph{Proof}: By structural induction on span fields. See supplementary material.

\subsubsection{Lattice Structure for Trace Aggregation}

\textbf{Definition}: A lattice is a partially ordered set $(L, \leq)$ where every two elements $a, b \in L$ have a join (least upper bound) $a \sqcup b$ and a meet (greatest lower bound) $a \sqcap b$.

\textbf{Trace Aggregation Lattice}:

We define a lattice $(\text{TraceViews}, \sqsubseteq)$ where:

\begin{itemize}
\item $\text{TraceViews}$ = different views or projections of a trace
\item $v_1 \sqsubseteq v_2$ means $v_1$ is a subset of $v_2$ (less information)
\item $v_1 \sqcup v_2$ = union of views (merge information)
\item $v_1 \sqcap v_2$ = intersection of views (common information)
\end{itemize}

\textbf{Properties}:

\begin{enumerate}
\item \textbf{Idempotence}: $v \sqcup v = v$ (merging a view with itself gives the same view)
\item \textbf{Commutativity}: $v_1 \sqcup v_2 = v_2 \sqcup v_1$ (order doesn't matter)
\item \textbf{Associativity}: $(v_1 \sqcup v_2) \sqcup v_3 = v_1 \sqcup (v_2 \sqcup v_3)$
\end{enumerate}

\textbf{Theorem 4 (Trace Aggregation Lattice)}:
The structure $(\text{TraceViews}, \sqsubseteq, \sqcup, \sqcap)$ forms a lattice.

\emph{Proof}: Standard result from set theory; subset relation with union and intersection forms a lattice.

\subsubsection{Category Theory for Interoperability}

\textbf{Definition}: A category $\mathcal{C}$ consists of objects $\text{Ob}(\mathcal{C})$ and morphisms $\text{Hom}(A, B)$ for each pair of objects, with composition and identity morphisms.

\textbf{OTLP Interoperability Category}:

We model different \otlp implementations as a category:

\begin{itemize}
\item \textbf{Objects}: Data models (e.g., Java SDK span, Go SDK span, OTLP Protobuf span)
\item \textbf{Morphisms}: Transformations (e.g., serialization, format conversion)
\item \textbf{Composition}: Chaining transformations
\end{itemize}

\textbf{Theorem 5 (Interoperability via Functors)}:
If transformations between \otlp implementations are functorial (preserve composition and identities), then essential span properties are preserved across the entire pipeline.

\emph{Proof}: Functors preserve structure by definition. See supplementary material.

\subsection{Temporal Logic Verification}
\label{sec:temporal}

Temporal logic allows us to specify and verify system-wide properties that hold over time. We use Linear Temporal Logic (LTL) for sequential properties and Computation Tree Logic (CTL) for branching-time properties.

\subsubsection{Linear Temporal Logic (LTL)}

\textbf{LTL Syntax}:

\[
\varphi ::= p \mid \neg\varphi \mid \varphi_1 \land \varphi_2 \mid \bigcirc\varphi \mid \varphi_1 \mathcal{U} \varphi_2 \mid \Box\varphi \mid \Diamond\varphi
\]

where:
\begin{itemize}
\item $p$ = atomic proposition (e.g., ``span $s$ started'')
\item $\neg\varphi$ = negation
\item $\varphi_1 \land \varphi_2$ = conjunction
\item $\bigcirc\varphi$ = next ($\varphi$ holds in the next state)
\item $\varphi_1 \mathcal{U} \varphi_2$ = until ($\varphi_1$ holds until $\varphi_2$ becomes true)
\item $\Box\varphi$ = always ($\varphi$ holds in all future states)
\item $\Diamond\varphi$ = eventually ($\varphi$ holds in some future state)
\end{itemize}

\textbf{LTL Properties for OTLP}:

\begin{enumerate}
\item \textbf{Span Completion}: If a span starts, it must eventually end.
\[
\Box(\text{started}(s) \rightarrow \Diamond\text{ended}(s))
\]

\item \textbf{Error Logging}: If an error occurs, it must eventually be logged.
\[
\Box(\text{error}(s) \rightarrow \Diamond\text{logged}(s))
\]

\item \textbf{Causality}: A child span never starts before its parent.
\[
\Box(\text{started}(\text{child}) \rightarrow \text{started}(\text{parent}))
\]
\end{enumerate}

\subsubsection{Computation Tree Logic (CTL)}

\textbf{CTL Syntax}:

\[
\varphi ::= p \mid \neg\varphi \mid \varphi_1 \land \varphi_2 \mid \text{EX}\varphi \mid \text{EF}\varphi \mid \text{EG}\varphi \mid \text{AX}\varphi \mid \text{AF}\varphi \mid \text{AG}\varphi
\]

where E = ``exists a path'' and A = ``for all paths'', X = ``next'', F = ``eventually'', G = ``globally''.

\textbf{CTL Properties for OTLP}:

\begin{enumerate}
\item \textbf{Reachability}: From any span, there exists a path to the root span.
\[
\text{AG}(\exists s. \text{EF}(\text{root}(s)))
\]

\item \textbf{Invariants}: All spans always have valid trace IDs.
\[
\text{AG}(\text{valid\_trace\_id}(s))
\]
\end{enumerate}

\textbf{Theorem 6 (Temporal Property Verification)}:
If a trace satisfies all specified LTL and CTL properties, then the system exhibits correct temporal behavior, including span completion, causality preservation, and error handling.

\subsection{Integration and Workflow}
\label{sec:integration}

The five components of our framework work together in a verification pipeline. OTLP data streams are processed through:

\begin{enumerate}
\item \textbf{Type Checking}: Structural validation, ID format checks, timestamp validation
\item \textbf{Semantic Validation}: Attribute checks, convention compliance
\item \textbf{Triple Flow Analysis}: Control/data/execution flow verification
\item \textbf{Algebraic Verification}: Composition correctness, aggregation consistency
\item \textbf{Temporal Logic Verification}: LTL/CTL property checking
\end{enumerate}

\textbf{Incremental Verification}:

Our framework supports incremental verification on streaming data:

\begin{algorithmic}[1]
\Function{IncrementalVerify}{span, state}
    \State $\text{state}' \gets \text{state}.\text{add\_span}(\text{span})$
    \If{$\neg \text{typecheck}(\text{span}, \text{state}'.\text{store})$}
        \State $\text{state}'.\text{report\_violation}(\text{``Type error''}, \text{span})$
    \EndIf
    \State $\text{state}' \gets \text{update\_flow\_analysis}(\text{state}', \text{span})$
    \If{$\neg \text{check\_local\_ltl}(\text{span}, \text{state}')$}
        \State $\text{state}'.\text{report\_violation}(\text{``LTL violation''}, \text{span})$
    \EndIf
    \State \Return $\text{state}'$
\EndFunction
\end{algorithmic}

This allows verification to happen in real-time, as spans are collected, rather than waiting for complete traces.

\textbf{Theorem 7 (Framework Soundness)}:
If a trace passes all five verification components, then: (1) the trace is structurally well-formed, (2) context is correctly propagated, (3) causality is preserved, (4) composition and aggregation are consistent, and (5) all specified temporal properties hold.

\textbf{Theorem 8 (Framework Completeness)}:
If a violation exists in any of the five aspects (structure, context, causality, composition, temporal properties), at least one verification component will detect it.

\emph{Proof}: By combining the soundness results of each component (Theorems 1--6).
