% Section 2: Background
% Based on ICSE2026_Paper_Draft.md (2025-10-20)

\section{Background}
\label{sec:background}

This section provides essential background on OpenTelemetry, OTLP, Semantic Conventions, and formal verification techniques that form the foundation of our work.

\subsection{OpenTelemetry and Distributed Tracing}
\label{sec:opentelemetry}

\textbf{OpenTelemetry Architecture}:

OpenTelemetry~\cite{opentelemetry2023} is a comprehensive observability framework consisting of:

\begin{itemize}
\item \textbf{Instrumentation SDKs}: Libraries for 20+ languages (Java, Python, Go, JavaScript, C++, Rust, etc.) that instrument applications to generate telemetry data
\item \textbf{OpenTelemetry Collector}: A vendor-agnostic data pipeline for receiving, processing, and exporting telemetry
\item \textbf{Semantic Conventions}: Standardized naming for attributes, metrics, and spans across different domains
\item \textbf{Protocol (OTLP)}: The wire protocol for transmitting telemetry data
\end{itemize}

\textbf{Distributed Tracing Concepts}:

A \textbf{trace} represents a single request's journey through a distributed system. Each trace consists of:

\begin{itemize}
\item \textbf{Spans}: Individual units of work, representing operations within services
\item \textbf{Trace Context}: Global trace ID and parent span ID propagated across service boundaries
\item \textbf{Resource}: Information about the entity producing telemetry (service name, version, host)
\item \textbf{Attributes}: Key-value pairs providing contextual information
\end{itemize}

\textbf{Example}: When a user places an order in an e-commerce system:

\begin{enumerate}
\item Frontend service creates a root span (traceID: \texttt{abc123})
\item Payment service creates a child span (traceID: \texttt{abc123}, parentSpanID: root)
\item Inventory service creates another child span
\item Each span records timing, status, and contextual attributes
\item All spans are exported to a backend for storage and visualization
\end{enumerate}

\textbf{Challenges in Distributed Tracing}:

\begin{itemize}
\item \textbf{Context Propagation}: Maintaining trace context across asynchronous operations, message queues, and HTTP requests
\item \textbf{Clock Skew}: Services running on different machines with unsynchronized clocks
\item \textbf{Sampling}: Deciding which traces to keep (typically $<$1\% due to volume)
\item \textbf{Data Volume}: Large-scale systems generate millions of spans per second
\end{itemize}

\subsection{OpenTelemetry Protocol (OTLP)}
\label{sec:otlp}

\textbf{Protocol Overview}:

OTLP v1.3.0 (latest as of 2025) is defined using Protocol Buffers~\cite{protobuf} and supports three signal types:

\begin{itemize}
\item \textbf{Traces}: Request flows through services
\item \textbf{Metrics}: Numerical measurements (counters, gauges, histograms)
\item \textbf{Logs}: Timestamped text records with structured data
\end{itemize}

\textbf{OTLP Data Model for Traces} (simplified):

\begin{lstlisting}[style=otlpcode,language=protobuf,caption={OTLP Trace Data Model (Protocol Buffers)}]
message TracesData {
  repeated ResourceSpans resource_spans = 1;
}

message ResourceSpans {
  Resource resource = 1;  // Service/host information
  repeated ScopeSpans scope_spans = 2;
}

message ScopeSpans {
  InstrumentationScope scope = 1;  // Library info
  repeated Span spans = 2;
}

message Span {
  bytes trace_id = 1;           // 16 bytes (128-bit)
  bytes span_id = 2;            // 8 bytes (64-bit)
  bytes parent_span_id = 3;     // 8 bytes, empty for root
  string name = 4;              // Operation name
  SpanKind kind = 5;            // INTERNAL, CLIENT, SERVER
  uint64 start_time = 6;        // Unix nanoseconds
  uint64 end_time = 7;          // Unix nanoseconds
  repeated KeyValue attributes = 8;  // Metadata
  Status status = 9;            // OK, ERROR, UNSET
  repeated Event events = 10;   // Timestamped events
  repeated Link links = 11;     // Links to other spans
}
\end{lstlisting}

\textbf{Key Protocol Properties}:

\begin{enumerate}
\item \textbf{Hierarchical Structure}: Resource $\rightarrow$ Scope $\rightarrow$ Span (3 levels)
\item \textbf{Immutable IDs}: Trace ID and Span ID are globally unique and immutable
\item \textbf{Parent-Child Relationships}: \texttt{parent\_span\_id} creates a directed acyclic graph (DAG)
\item \textbf{Temporal Constraints}: \texttt{start\_time} $\leq$ \texttt{end\_time}, parent span contains child spans temporally
\item \textbf{Extensibility}: Attributes allow arbitrary key-value pairs
\end{enumerate}

\textbf{Informal Protocol Constraints} (from specification):

\begin{itemize}
\item \textbf{C1}: Trace ID must be 16 bytes, non-zero
\item \textbf{C2}: Span ID must be 8 bytes, non-zero
\item \textbf{C3}: If \texttt{parent\_span\_id} is non-empty, it must refer to a valid span in the same trace
\item \textbf{C4}: Start time must be $\leq$ end time
\item \textbf{C5}: Attribute keys must be non-empty strings
\item \textbf{C6}: Resource and InstrumentationScope are shared across multiple spans for efficiency
\end{itemize}

\textbf{Problem}: These constraints are expressed informally in prose. Our work provides \textbf{formal semantics} that make these constraints mathematically precise and verifiable.

\subsection{Semantic Conventions}
\label{sec:semantic-conventions}

\textbf{Purpose}:

Semantic Conventions~\cite{otel-semconv} define standardized naming for span names, attributes, metrics, and resource attributes to ensure consistency across different implementations and domains.

\textbf{Example Conventions} (from v1.29.0):

\textbf{HTTP Spans}:

\begin{itemize}
\item Span name: \texttt{\{http.request.method\} \{http.route\}}
\item Required attributes:
  \begin{itemize}
  \item \texttt{http.request.method}: HTTP method (GET, POST, etc.)
  \item \texttt{http.response.status\_code}: HTTP status code (200, 404, 500, etc.)
  \item \texttt{url.full}: Full request URL
  \end{itemize}
\item Optional attributes:
  \begin{itemize}
  \item \texttt{user\_agent.original}: User agent string
  \item \texttt{http.request.body.size}: Request body size in bytes
  \end{itemize}
\end{itemize}

\textbf{Database Spans}:

\begin{itemize}
\item Span name: \texttt{\{db.operation.name\} \{db.collection.name\}}
\item Required attributes:
  \begin{itemize}
  \item \texttt{db.system}: Database system (postgresql, mysql, mongodb)
  \item \texttt{db.operation.name}: Operation (SELECT, INSERT, findOne)
  \end{itemize}
\item Optional attributes:
  \begin{itemize}
  \item \texttt{db.query.text}: Database query statement
  \item \texttt{db.collection.name}: Collection/table name
  \end{itemize}
\end{itemize}

\textbf{GenAI Spans} (NEW in v1.29.0):

\begin{itemize}
\item Span name: \texttt{gen\_ai.chat}
\item Required attributes:
  \begin{itemize}
  \item \texttt{gen\_ai.system}: AI system (openai, anthropic, gemini)
  \item \texttt{gen\_ai.request.model}: Model name (gpt-4, claude-3)
  \end{itemize}
\item Optional attributes:
  \begin{itemize}
  \item \texttt{gen\_ai.request.temperature}: Temperature parameter
  \item \texttt{gen\_ai.response.finish\_reasons}: Completion reasons
  \item \texttt{gen\_ai.usage.input\_tokens}: Token count
  \end{itemize}
\end{itemize}

\textbf{Importance}: Semantic Conventions enable cross-platform observability and standardized analysis. Our verification framework ensures implementations comply with these conventions.

\subsection{Formal Verification Techniques}
\label{sec:formal-techniques}

We employ five complementary formal verification techniques:

\subsubsection{Type Systems}
\label{sec:type-systems}

Type systems~\cite{pierce2002types} assign types to program expressions and enforce constraints statically. Key concepts:

\begin{itemize}
\item \textbf{Typing Judgments}: $\Gamma \vdash e : \tau$ means expression $e$ has type $\tau$ under context $\Gamma$
\item \textbf{Typing Rules}: Inference rules that derive type judgments
\item \textbf{Type Soundness}: Well-typed programs don't "go wrong" (Progress + Preservation)
\end{itemize}

\textbf{Application to OTLP}: We design a type system where OTLP constraints (e.g., valid IDs, temporal ordering) are encoded as type rules, ensuring protocol correctness at compile time.

\subsubsection{Operational Semantics}
\label{sec:operational-semantics}

Operational semantics~\cite{plotkin1981structural} define program execution as a transition system:

\begin{itemize}
\item \textbf{States}: Configurations representing program state
\item \textbf{Reduction Rules}: $\sigma \rightarrow \sigma'$ means state $\sigma$ transitions to $\sigma'$
\item \textbf{Evaluation}: Programs execute by applying reduction rules
\end{itemize}

\textbf{Application to OTLP}: We model span operations (create, propagate, export) as reduction rules, enabling formal reasoning about trace assembly.

\subsubsection{Algebraic Structures}
\label{sec:algebraic-structures}

Algebraic structures~\cite{maclane1998categories,birkhoff1940lattice} capture compositional properties:

\begin{itemize}
\item \textbf{Monoids}: Sets with associative binary operation and identity
\item \textbf{Lattices}: Partially ordered sets with meet and join operations
\item \textbf{Categories}: Objects and morphisms with composition
\end{itemize}

\textbf{Application to OTLP}: We prove traces form monoids (composition), span relationships form lattices (hierarchy), and transformations form categories (pipelines).

\subsubsection{Temporal Logic}
\label{sec:temporal-logic}

Temporal logic~\cite{pnueli1977temporal,clarke1999model} specifies properties over time:

\begin{itemize}
\item \textbf{Linear Temporal Logic (LTL)}: Properties over single execution paths
  \begin{itemize}
  \item $\square \phi$: $\phi$ always holds
  \item $\Diamond \phi$: $\phi$ eventually holds
  \item $\phi \mathcal{U} \psi$: $\phi$ holds until $\psi$
  \end{itemize}
\item \textbf{Computation Tree Logic (CTL)}: Properties over all possible executions
  \begin{itemize}
  \item $\text{AG } \phi$: $\phi$ holds on all paths, all states
  \item $\text{EF } \phi$: $\phi$ holds on some path, some state
  \end{itemize}
\end{itemize}

\textbf{Application to OTLP}: We specify OTLP temporal properties (e.g., causality) in LTL/CTL and verify them using model checking.

\subsubsection{Theorem Proving}
\label{sec:theorem-proving}

Interactive theorem provers~\cite{bertot2013coq,nipkow2002isabelle} mechanize mathematical proofs:

\begin{itemize}
\item \textbf{Coq}: Based on the Calculus of Inductive Constructions
\item \textbf{Isabelle/HOL}: Based on higher-order logic
\end{itemize}

\textbf{Application to OTLP}: We formalize OTLP semantics and verify theorems in Coq (1,500 lines) and Isabelle/HOL (640 lines), ensuring proof correctness.

\subsection{Related Formal Frameworks}
\label{sec:related-frameworks}

Several formal frameworks have been applied to distributed systems:

\textbf{TLA+ for Distributed Protocols}~\cite{lamport2002specifying}: Used to verify consensus algorithms (Raft, Paxos) and distributed databases. However, TLA+ focuses on protocol state machines, not observability data correctness.

\textbf{Session Types for Communication}~\cite{honda1993types,honda2008multiparty}: Ensure communication protocol correctness through types. Not designed for telemetry data with hierarchical structure and temporal constraints.

\textbf{Dependent Types for Verification}~\cite{xi1999dependent}: Encode rich invariants in types (e.g., array bounds). Could express OTLP constraints but lack OTLP-specific reasoning principles.

\textbf{Our Distinction}: We develop the first formal framework specifically for observability protocols, combining type systems, algebraic structures, and multi-flow analysis to address OTLP's unique challenges.
