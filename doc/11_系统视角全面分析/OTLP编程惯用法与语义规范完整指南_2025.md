# OTLPç¼–ç¨‹æƒ¯ç”¨æ³•ä¸è¯­ä¹‰è§„èŒƒå®Œæ•´æŒ‡å—

## ç›®å½•

- [OTLPç¼–ç¨‹æƒ¯ç”¨æ³•ä¸è¯­ä¹‰è§„èŒƒå®Œæ•´æŒ‡å—](#otlpç¼–ç¨‹æƒ¯ç”¨æ³•ä¸è¯­ä¹‰è§„èŒƒå®Œæ•´æŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“Š æ–‡æ¡£æ¦‚è§ˆ](#-æ–‡æ¡£æ¦‚è§ˆ)
  - [ğŸ¯ æŒ‡å—ç›®æ ‡](#-æŒ‡å—ç›®æ ‡)
    - [ä¸»è¦ç›®æ ‡](#ä¸»è¦ç›®æ ‡)
  - [ğŸ“ 1. ç¼–ç¨‹è§„èŒƒä½“ç³»](#-1-ç¼–ç¨‹è§„èŒƒä½“ç³»)
    - [1.1 å‘½åè§„èŒƒ](#11-å‘½åè§„èŒƒ)
      - [åŸºç¡€å‘½åè§„èŒƒ](#åŸºç¡€å‘½åè§„èŒƒ)
      - [OTLPç‰¹å®šå‘½åè§„èŒƒ](#otlpç‰¹å®šå‘½åè§„èŒƒ)
    - [1.2 ä»£ç ç»„ç»‡è§„èŒƒ](#12-ä»£ç ç»„ç»‡è§„èŒƒ)
      - [æ–‡ä»¶ç»“æ„è§„èŒƒ](#æ–‡ä»¶ç»“æ„è§„èŒƒ)
      - [æ¨¡å—å¯¼å…¥è§„èŒƒ](#æ¨¡å—å¯¼å…¥è§„èŒƒ)
    - [1.3 æ³¨é‡Šè§„èŒƒ](#13-æ³¨é‡Šè§„èŒƒ)
      - [æ–‡æ¡£æ³¨é‡Š](#æ–‡æ¡£æ³¨é‡Š)
      - [è¡Œå†…æ³¨é‡Š](#è¡Œå†…æ³¨é‡Š)
  - [ğŸ—ï¸ 2. ç¼–ç¨‹æƒ¯ç”¨æ³•](#ï¸-2-ç¼–ç¨‹æƒ¯ç”¨æ³•)
    - [2.1 é”™è¯¯å¤„ç†æƒ¯ç”¨æ³•](#21-é”™è¯¯å¤„ç†æƒ¯ç”¨æ³•)
      - [å¼‚å¸¸å¤„ç†æ¨¡å¼](#å¼‚å¸¸å¤„ç†æ¨¡å¼)
      - [é‡è¯•æœºåˆ¶](#é‡è¯•æœºåˆ¶)
    - [2.2 å¹¶å‘ç¼–ç¨‹æƒ¯ç”¨æ³•](#22-å¹¶å‘ç¼–ç¨‹æƒ¯ç”¨æ³•)
      - [å¼‚æ­¥å¤„ç†æ¨¡å¼](#å¼‚æ­¥å¤„ç†æ¨¡å¼)
      - [å¹¶å‘æ§åˆ¶](#å¹¶å‘æ§åˆ¶)
    - [2.3 æ€§èƒ½ä¼˜åŒ–æƒ¯ç”¨æ³•](#23-æ€§èƒ½ä¼˜åŒ–æƒ¯ç”¨æ³•)
      - [å†…å­˜ç®¡ç†](#å†…å­˜ç®¡ç†)
      - [ç¼“å­˜ç­–ç•¥](#ç¼“å­˜ç­–ç•¥)
  - [ğŸ¨ 3. è®¾è®¡æ¨¡å¼åº”ç”¨](#-3-è®¾è®¡æ¨¡å¼åº”ç”¨)
    - [3.1 åˆ›å»ºå‹æ¨¡å¼](#31-åˆ›å»ºå‹æ¨¡å¼)
      - [å·¥å‚æ¨¡å¼](#å·¥å‚æ¨¡å¼)
      - [å»ºé€ è€…æ¨¡å¼](#å»ºé€ è€…æ¨¡å¼)
    - [3.2 ç»“æ„å‹æ¨¡å¼](#32-ç»“æ„å‹æ¨¡å¼)
      - [é€‚é…å™¨æ¨¡å¼](#é€‚é…å™¨æ¨¡å¼)
      - [è£…é¥°å™¨æ¨¡å¼](#è£…é¥°å™¨æ¨¡å¼)
    - [3.3 è¡Œä¸ºå‹æ¨¡å¼](#33-è¡Œä¸ºå‹æ¨¡å¼)
      - [è§‚å¯Ÿè€…æ¨¡å¼](#è§‚å¯Ÿè€…æ¨¡å¼)
      - [ç­–ç•¥æ¨¡å¼](#ç­–ç•¥æ¨¡å¼)
  - [ğŸ“‹ 4. è¯­ä¹‰è§„èŒƒ](#-4-è¯­ä¹‰è§„èŒƒ)
    - [4.1 ç±»å‹ç³»ç»Ÿè§„èŒƒ](#41-ç±»å‹ç³»ç»Ÿè§„èŒƒ)
      - [åŸºç¡€ç±»å‹å®šä¹‰](#åŸºç¡€ç±»å‹å®šä¹‰)
      - [æ³›å‹ç±»å‹å®šä¹‰](#æ³›å‹ç±»å‹å®šä¹‰)
    - [4.2 è¯­ä¹‰çº¦æŸè§„èŒƒ](#42-è¯­ä¹‰çº¦æŸè§„èŒƒ)
      - [æ•°æ®éªŒè¯çº¦æŸ](#æ•°æ®éªŒè¯çº¦æŸ)
      - [ä¸šåŠ¡è§„åˆ™çº¦æŸ](#ä¸šåŠ¡è§„åˆ™çº¦æŸ)
    - [4.3 ç¼–ç¨‹èŒƒå¼è§„èŒƒ](#43-ç¼–ç¨‹èŒƒå¼è§„èŒƒ)
      - [å‡½æ•°å¼ç¼–ç¨‹è§„èŒƒ](#å‡½æ•°å¼ç¼–ç¨‹è§„èŒƒ)
      - [é¢å‘å¯¹è±¡ç¼–ç¨‹è§„èŒƒ](#é¢å‘å¯¹è±¡ç¼–ç¨‹è§„èŒƒ)
  - [ğŸ¯ 5. æœ€ä½³å®è·µ](#-5-æœ€ä½³å®è·µ)
    - [5.1 æ€§èƒ½æœ€ä½³å®è·µ](#51-æ€§èƒ½æœ€ä½³å®è·µ)
      - [å†…å­˜ä¼˜åŒ–](#å†…å­˜ä¼˜åŒ–)
      - [æ€§èƒ½ç›‘æ§](#æ€§èƒ½ç›‘æ§)
    - [5.2 å®‰å…¨æœ€ä½³å®è·µ](#52-å®‰å…¨æœ€ä½³å®è·µ)
      - [æ•°æ®å®‰å…¨](#æ•°æ®å®‰å…¨)
      - [è¾“å…¥éªŒè¯](#è¾“å…¥éªŒè¯)
    - [5.3 æµ‹è¯•æœ€ä½³å®è·µ](#53-æµ‹è¯•æœ€ä½³å®è·µ)
      - [å•å…ƒæµ‹è¯•](#å•å…ƒæµ‹è¯•)
      - [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
  - [ğŸ“š æ€»ç»“](#-æ€»ç»“)
    - [ä¸»è¦æˆæœ](#ä¸»è¦æˆæœ)
    - [åˆ›æ–°è´¡çŒ®](#åˆ›æ–°è´¡çŒ®)
    - [åº”ç”¨ä»·å€¼](#åº”ç”¨ä»·å€¼)

## ğŸ“Š æ–‡æ¡£æ¦‚è§ˆ

**åˆ›å»ºæ—¶é—´**: 2025å¹´10æœˆ6æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLP ç³»ç»Ÿåˆ†æå›¢é˜Ÿ  
**çŠ¶æ€**: ç¼–ç¨‹è§„èŒƒåˆ¶å®šå®Œæˆ  
**é€‚ç”¨èŒƒå›´**: OTLPç¼–ç¨‹æƒ¯ç”¨æ³•ä¸è¯­ä¹‰è§„èŒƒå…¨é¢æŒ‡å—

## ğŸ¯ æŒ‡å—ç›®æ ‡

### ä¸»è¦ç›®æ ‡

1. **ç¼–ç¨‹æƒ¯ç”¨æ³•å»ºç«‹** - å»ºç«‹OTLPç¼–ç¨‹çš„æ ‡å‡†æƒ¯ç”¨æ³•å’Œæœ€ä½³å®è·µ
2. **è¯­ä¹‰è§„èŒƒåˆ¶å®š** - åˆ¶å®šOTLPçš„è¯­ä¹‰å®šä¹‰ã€çº¦æŸå’Œæ ‡å‡†
3. **ç¨‹åºè®¾è®¡æŒ‡å¯¼** - æä¾›OTLPç¨‹åºè®¾è®¡çš„å®Œæ•´æŒ‡å¯¼
4. **ç¼–ç¨‹è§„èŒƒç»Ÿä¸€** - ç»Ÿä¸€OTLPç¼–ç¨‹è§„èŒƒå’Œè®¾è®¡æ ‡å‡†
5. **è´¨é‡ä¿è¯ä½“ç³»** - å»ºç«‹OTLPä»£ç è´¨é‡ä¿è¯ä½“ç³»
6. **å›¢é˜Ÿåä½œä¼˜åŒ–** - ä¿ƒè¿›å›¢é˜Ÿåä½œå’ŒçŸ¥è¯†ä¼ æ‰¿

## ğŸ“ 1. ç¼–ç¨‹è§„èŒƒä½“ç³»

### 1.1 å‘½åè§„èŒƒ

#### åŸºç¡€å‘½åè§„èŒƒ

```typescript
// ç±»åï¼šPascalCase
class OtlpTraceCollector {
  // æ–¹æ³•åï¼šcamelCase
  collectSpan(span: Span): void {
    // å˜é‡åï¼šcamelCase
    const spanId = span.getId();
    // å¸¸é‡åï¼šUPPER_SNAKE_CASE
    const MAX_BATCH_SIZE = 1000;
  }
}

// æ¥å£åï¼šI + PascalCase
interface IOtlpExporter {
  export(data: OtlpData): Promise<void>;
}

// æšä¸¾åï¼šPascalCase
enum OtlpProtocol {
  HTTP = 'http',
  GRPC = 'grpc'
}
```

#### OTLPç‰¹å®šå‘½åè§„èŒƒ

```typescript
// OTLPç»„ä»¶å‰ç¼€
class OtlpSpanProcessor { }
class OtlpMetricExporter { }
class OtlpLogCollector { }

// æ•°æ®æ¨¡å‹å‘½å
interface OtlpSpanData { }
interface OtlpMetricData { }
interface OtlpLogData { }

// é…ç½®ç±»å‘½å
class OtlpCollectorConfig { }
class OtlpExporterConfig { }
```

### 1.2 ä»£ç ç»„ç»‡è§„èŒƒ

#### æ–‡ä»¶ç»“æ„è§„èŒƒ

```text
OTLPé¡¹ç›®ç»“æ„ï¼š
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/                    # æ ¸å¿ƒåŠŸèƒ½
â”‚   â”‚   â”œâ”€â”€ collectors/          # æ•°æ®æ”¶é›†å™¨
â”‚   â”‚   â”œâ”€â”€ processors/          # æ•°æ®å¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ exporters/           # æ•°æ®å¯¼å‡ºå™¨
â”‚   â”‚   â””â”€â”€ samplers/            # é‡‡æ ·å™¨
â”‚   â”œâ”€â”€ models/                  # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ span.ts
â”‚   â”‚   â”œâ”€â”€ trace.ts
â”‚   â”‚   â”œâ”€â”€ metric.ts
â”‚   â”‚   â””â”€â”€ log.ts
â”‚   â”œâ”€â”€ protocols/               # åè®®å®ç°
â”‚   â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â””â”€â”€ grpc/
â”‚   â”œâ”€â”€ utils/                   # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ types/                    # ç±»å‹å®šä¹‰
â”œâ”€â”€ tests/                       # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ docs/                        # æ–‡æ¡£
â””â”€â”€ examples/                    # ç¤ºä¾‹ä»£ç 
```

#### æ¨¡å—å¯¼å…¥è§„èŒƒ

```typescript
// å¯¼å…¥é¡ºåºï¼šç¬¬ä¸‰æ–¹åº“ -> å†…éƒ¨æ¨¡å— -> ç›¸å¯¹è·¯å¾„
import { EventEmitter } from 'events';
import { Logger } from '@opentelemetry/api';

import { OtlpSpan } from '../models/span';
import { OtlpExporter } from '../core/exporters/exporter';

// ä½¿ç”¨å‘½åç©ºé—´å¯¼å…¥
import * as OtlpTypes from '../types/otlp-types';
```

### 1.3 æ³¨é‡Šè§„èŒƒ

#### æ–‡æ¡£æ³¨é‡Š

```typescript
/**
 * OTLP Spanå¤„ç†å™¨æ¥å£
 * 
 * @interface IOtlpSpanProcessor
 * @description å®šä¹‰Spanå¤„ç†çš„åŸºæœ¬æ“ä½œ
 * @version 1.0.0
 * @since 2025-10-06
 */
interface IOtlpSpanProcessor {
  /**
   * å¤„ç†Spanæ•°æ®
   * 
   * @param span - è¦å¤„ç†çš„Spanå¯¹è±¡
   * @param context - å¤„ç†ä¸Šä¸‹æ–‡
   * @returns Promise<ProcessedSpan> å¤„ç†åçš„Span
   * @throws {ValidationError} å½“Spanæ•°æ®æ— æ•ˆæ—¶æŠ›å‡º
   * @example
   * ```typescript
   * const processor = new OtlpSpanProcessor();
   * const processedSpan = await processor.processSpan(span, context);
   * ```
   */
  processSpan(span: OtlpSpan, context: ProcessingContext): Promise<ProcessedSpan>;
}
```

#### è¡Œå†…æ³¨é‡Š

```typescript
class OtlpTraceCollector {
  private collectSpans(spans: OtlpSpan[]): void {
    // è¿‡æ»¤æœ‰æ•ˆçš„Span
    const validSpans = spans.filter(span => this.isValidSpan(span));
    
    // æ‰¹é‡å¤„ç†ä»¥æé«˜æ€§èƒ½
    const batches = this.createBatches(validSpans, this.batchSize);
    
    for (const batch of batches) {
      // å¼‚æ­¥å¤„ç†æ¯ä¸ªæ‰¹æ¬¡ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
      this.processBatchAsync(batch);
    }
  }
}
```

## ğŸ—ï¸ 2. ç¼–ç¨‹æƒ¯ç”¨æ³•

### 2.1 é”™è¯¯å¤„ç†æƒ¯ç”¨æ³•

#### å¼‚å¸¸å¤„ç†æ¨¡å¼

```typescript
// 1. ä½¿ç”¨Resultæ¨¡å¼å¤„ç†é”™è¯¯
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

class OtlpExporter {
  async exportData(data: OtlpData): Promise<Result<void, ExportError>> {
    try {
      await this.validateData(data);
      await this.sendData(data);
      return { success: true, data: undefined };
    } catch (error) {
      return { 
        success: false, 
        error: new ExportError('Failed to export data', error) 
      };
    }
  }
}

// 2. ä½¿ç”¨è£…é¥°å™¨å¤„ç†å¼‚å¸¸
function handleErrors(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value;
  
  descriptor.value = async function (...args: any[]) {
    try {
      return await method.apply(this, args);
    } catch (error) {
      console.error(`Error in ${propertyName}:`, error);
      throw new OtlpError(`Operation failed: ${error.message}`);
    }
  };
}

class OtlpSpanProcessor {
  @handleErrors
  async processSpan(span: OtlpSpan): Promise<ProcessedSpan> {
    // å¤„ç†é€»è¾‘
  }
}
```

#### é‡è¯•æœºåˆ¶

```typescript
class RetryableOtlpExporter {
  private maxRetries = 3;
  private retryDelay = 1000;

  async exportWithRetry(data: OtlpData): Promise<void> {
    let lastError: Error;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        await this.exportData(data);
        return; // æˆåŠŸï¼Œé€€å‡ºé‡è¯•å¾ªç¯
      } catch (error) {
        lastError = error;
        
        if (attempt < this.maxRetries) {
          // æŒ‡æ•°é€€é¿
          const delay = this.retryDelay * Math.pow(2, attempt - 1);
          await this.sleep(delay);
        }
      }
    }
    
    throw new RetryExhaustedError('Max retries exceeded', lastError);
  }
}
```

### 2.2 å¹¶å‘ç¼–ç¨‹æƒ¯ç”¨æ³•

#### å¼‚æ­¥å¤„ç†æ¨¡å¼

```typescript
// 1. ä½¿ç”¨Promise.allè¿›è¡Œå¹¶è¡Œå¤„ç†
class OtlpBatchProcessor {
  async processBatch(spans: OtlpSpan[]): Promise<ProcessedSpan[]> {
    const promises = spans.map(span => this.processSpan(span));
    return Promise.all(promises);
  }
}

// 2. ä½¿ç”¨async/awaitè¿›è¡Œé¡ºåºå¤„ç†
class OtlpSequentialProcessor {
  async processSequentially(spans: OtlpSpan[]): Promise<ProcessedSpan[]> {
    const results: ProcessedSpan[] = [];
    
    for (const span of spans) {
      const processed = await this.processSpan(span);
      results.push(processed);
    }
    
    return results;
  }
}

// 3. ä½¿ç”¨æµå¼å¤„ç†
class OtlpStreamProcessor {
  async processStream(spanStream: ReadableStream<OtlpSpan>): Promise<void> {
    const reader = spanStream.getReader();
    
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        await this.processSpan(value);
      }
    } finally {
      reader.releaseLock();
    }
  }
}
```

#### å¹¶å‘æ§åˆ¶

```typescript
class OtlpConcurrencyController {
  private semaphore: Semaphore;
  private maxConcurrency: number;

  constructor(maxConcurrency: number = 10) {
    this.maxConcurrency = maxConcurrency;
    this.semaphore = new Semaphore(maxConcurrency);
  }

  async processWithConcurrencyLimit<T>(
    items: T[],
    processor: (item: T) => Promise<any>
  ): Promise<any[]> {
    const promises = items.map(async (item) => {
      await this.semaphore.acquire();
      try {
        return await processor(item);
      } finally {
        this.semaphore.release();
      }
    });

    return Promise.all(promises);
  }
}
```

### 2.3 æ€§èƒ½ä¼˜åŒ–æƒ¯ç”¨æ³•

#### å†…å­˜ç®¡ç†

```typescript
// 1. å¯¹è±¡æ± æ¨¡å¼
class OtlpSpanPool {
  private pool: OtlpSpan[] = [];
  private maxSize: number;

  constructor(maxSize: number = 1000) {
    this.maxSize = maxSize;
  }

  acquire(): OtlpSpan {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    return new OtlpSpan();
  }

  release(span: OtlpSpan): void {
    if (this.pool.length < this.maxSize) {
      span.reset();
      this.pool.push(span);
    }
  }
}

// 2. æ‡’åŠ è½½æ¨¡å¼
class OtlpLazyExporter {
  private exporter: OtlpExporter | null = null;

  getExporter(): OtlpExporter {
    if (!this.exporter) {
      this.exporter = this.createExporter();
    }
    return this.exporter;
  }

  private createExporter(): OtlpExporter {
    // åˆ›å»ºå¯¼å‡ºå™¨çš„é€»è¾‘
  }
}
```

#### ç¼“å­˜ç­–ç•¥

```typescript
// 1. LRUç¼“å­˜
class OtlpLRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      // ç§»åŠ¨åˆ°æœ«å°¾ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // åˆ é™¤æœ€æ—§çš„é¡¹
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}
```

## ğŸ¨ 3. è®¾è®¡æ¨¡å¼åº”ç”¨

### 3.1 åˆ›å»ºå‹æ¨¡å¼

#### å·¥å‚æ¨¡å¼

```typescript
// æŠ½è±¡å·¥å‚
interface IOtlpExporterFactory {
  createExporter(type: ExporterType, config: ExporterConfig): IOtlpExporter;
}

// å…·ä½“å·¥å‚
class OtlpExporterFactory implements IOtlpExporterFactory {
  createExporter(type: ExporterType, config: ExporterConfig): IOtlpExporter {
    switch (type) {
      case ExporterType.HTTP:
        return new OtlpHttpExporter(config);
      case ExporterType.GRPC:
        return new OtlpGrpcExporter(config);
      case ExporterType.FILE:
        return new OtlpFileExporter(config);
      default:
        throw new Error(`Unsupported exporter type: ${type}`);
    }
  }
}

// ä½¿ç”¨å·¥å‚
const factory = new OtlpExporterFactory();
const exporter = factory.createExporter(ExporterType.HTTP, httpConfig);
```

#### å»ºé€ è€…æ¨¡å¼

```typescript
class OtlpSpanBuilder {
  private span: Partial<OtlpSpan> = {};

  setTraceId(traceId: string): this {
    this.span.traceId = traceId;
    return this;
  }

  setSpanId(spanId: string): this {
    this.span.spanId = spanId;
    return this;
  }

  setName(name: string): this {
    this.span.name = name;
    return this;
  }

  setStartTime(startTime: number): this {
    this.span.startTime = startTime;
    return this;
  }

  setEndTime(endTime: number): this {
    this.span.endTime = endTime;
    return this;
  }

  addAttribute(key: string, value: any): this {
    if (!this.span.attributes) {
      this.span.attributes = {};
    }
    this.span.attributes[key] = value;
    return this;
  }

  build(): OtlpSpan {
    this.validate();
    return new OtlpSpan(this.span as OtlpSpan);
  }

  private validate(): void {
    if (!this.span.traceId) throw new Error('TraceId is required');
    if (!this.span.spanId) throw new Error('SpanId is required');
    if (!this.span.name) throw new Error('Name is required');
  }
}

// ä½¿ç”¨å»ºé€ è€…
const span = new OtlpSpanBuilder()
  .setTraceId('trace-123')
  .setSpanId('span-456')
  .setName('user-operation')
  .setStartTime(Date.now())
  .setEndTime(Date.now() + 100)
  .addAttribute('user.id', 'user-789')
  .addAttribute('operation.type', 'login')
  .build();
```

### 3.2 ç»“æ„å‹æ¨¡å¼

#### é€‚é…å™¨æ¨¡å¼

```typescript
// ç›®æ ‡æ¥å£
interface IOtlpExporter {
  export(data: OtlpData): Promise<void>;
}

// è¢«é€‚é…çš„ç±»
class LegacyExporter {
  send(data: any): void {
    // æ—§ç³»ç»Ÿçš„å¯¼å‡ºé€»è¾‘
  }
}

// é€‚é…å™¨
class LegacyExporterAdapter implements IOtlpExporter {
  constructor(private legacyExporter: LegacyExporter) {}

  async export(data: OtlpData): Promise<void> {
    // è½¬æ¢æ•°æ®æ ¼å¼
    const legacyData = this.convertToLegacyFormat(data);
    this.legacyExporter.send(legacyData);
  }

  private convertToLegacyFormat(data: OtlpData): any {
    // æ•°æ®æ ¼å¼è½¬æ¢é€»è¾‘
    return {
      traceId: data.traceId,
      spans: data.spans.map(span => ({
        id: span.spanId,
        name: span.name,
        // å…¶ä»–å­—æ®µæ˜ å°„
      }))
    };
  }
}
```

#### è£…é¥°å™¨æ¨¡å¼

```typescript
// åŸºç¡€ç»„ä»¶
interface IOtlpProcessor {
  process(data: OtlpData): Promise<ProcessedData>;
}

class OtlpBasicProcessor implements IOtlpProcessor {
  async process(data: OtlpData): Promise<ProcessedData> {
    // åŸºç¡€å¤„ç†é€»è¾‘
    return { ...data, processed: true };
  }
}

// è£…é¥°å™¨åŸºç±»
abstract class OtlpProcessorDecorator implements IOtlpProcessor {
  constructor(protected processor: IOtlpProcessor) {}

  async process(data: OtlpData): Promise<ProcessedData> {
    return this.processor.process(data);
  }
}

// å…·ä½“è£…é¥°å™¨
class OtlpValidationDecorator extends OtlpProcessorDecorator {
  async process(data: OtlpData): Promise<ProcessedData> {
    this.validateData(data);
    return super.process(data);
  }

  private validateData(data: OtlpData): void {
    if (!data.traceId) throw new Error('TraceId is required');
    if (!data.spans || data.spans.length === 0) {
      throw new Error('At least one span is required');
    }
  }
}

class OtlpLoggingDecorator extends OtlpProcessorDecorator {
  async process(data: OtlpData): Promise<ProcessedData> {
    console.log('Processing OTLP data:', data.traceId);
    const result = await super.process(data);
    console.log('Processing completed:', result);
    return result;
  }
}

// ä½¿ç”¨è£…é¥°å™¨
const processor = new OtlpLoggingDecorator(
  new OtlpValidationDecorator(
    new OtlpBasicProcessor()
  )
);
```

### 3.3 è¡Œä¸ºå‹æ¨¡å¼

#### è§‚å¯Ÿè€…æ¨¡å¼

```typescript
// äº‹ä»¶æ¥å£
interface IOtlpEvent {
  type: string;
  data: any;
  timestamp: number;
}

// è§‚å¯Ÿè€…æ¥å£
interface IOtlpObserver {
  update(event: IOtlpEvent): void;
}

// ä¸»é¢˜æ¥å£
interface IOtlpSubject {
  attach(observer: IOtlpObserver): void;
  detach(observer: IOtlpObserver): void;
  notify(event: IOtlpEvent): void;
}

// å…·ä½“ä¸»é¢˜
class OtlpEventEmitter implements IOtlpSubject {
  private observers: IOtlpObserver[] = [];

  attach(observer: IOtlpObserver): void {
    this.observers.push(observer);
  }

  detach(observer: IOtlpObserver): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(event: IOtlpEvent): void {
    this.observers.forEach(observer => observer.update(event));
  }

  emit(event: IOtlpEvent): void {
    this.notify(event);
  }
}

// å…·ä½“è§‚å¯Ÿè€…
class OtlpMetricsCollector implements IOtlpObserver {
  update(event: IOtlpEvent): void {
    if (event.type === 'span-created') {
      this.recordSpanMetrics(event.data);
    }
  }

  private recordSpanMetrics(span: OtlpSpan): void {
    // è®°å½•SpanæŒ‡æ ‡
  }
}
```

#### ç­–ç•¥æ¨¡å¼

```typescript
// ç­–ç•¥æ¥å£
interface IOtlpSamplingStrategy {
  shouldSample(span: OtlpSpan): boolean;
}

// å…·ä½“ç­–ç•¥
class OtlpProbabilisticSampler implements IOtlpSamplingStrategy {
  constructor(private samplingRate: number) {}

  shouldSample(span: OtlpSpan): boolean {
    return Math.random() < this.samplingRate;
  }
}

class OtlpRateLimitingSampler implements IOtlpSamplingStrategy {
  private tokens: number;
  private lastRefill: number;

  constructor(private maxTokens: number, private refillRate: number) {
    this.tokens = maxTokens;
    this.lastRefill = Date.now();
  }

  shouldSample(span: OtlpSpan): boolean {
    this.refillTokens();
    if (this.tokens > 0) {
      this.tokens--;
      return true;
    }
    return false;
  }

  private refillTokens(): void {
    const now = Date.now();
    const timePassed = now - this.lastRefill;
    const tokensToAdd = Math.floor(timePassed * this.refillRate / 1000);
    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

// ä¸Šä¸‹æ–‡
class OtlpSampler {
  constructor(private strategy: IOtlpSamplingStrategy) {}

  setStrategy(strategy: IOtlpSamplingStrategy): void {
    this.strategy = strategy;
  }

  sample(span: OtlpSpan): boolean {
    return this.strategy.shouldSample(span);
  }
}
```

## ğŸ“‹ 4. è¯­ä¹‰è§„èŒƒ

### 4.1 ç±»å‹ç³»ç»Ÿè§„èŒƒ

#### åŸºç¡€ç±»å‹å®šä¹‰

```typescript
// åŸºç¡€ç±»å‹
type OtlpString = string;
type OtlpNumber = number;
type OtlpBoolean = boolean;
type OtlpTimestamp = number;

// å¤åˆç±»å‹
interface OtlpSpan {
  traceId: OtlpString;
  spanId: OtlpString;
  parentSpanId?: OtlpString;
  name: OtlpString;
  startTime: OtlpTimestamp;
  endTime: OtlpTimestamp;
  attributes: Record<OtlpString, any>;
  events: OtlpEvent[];
  links: OtlpLink[];
  status: OtlpStatus;
}

interface OtlpTrace {
  traceId: OtlpString;
  spans: OtlpSpan[];
}

interface OtlpMetric {
  name: OtlpString;
  description?: OtlpString;
  unit?: OtlpString;
  data: OtlpMetricData;
}

interface OtlpLog {
  timestamp: OtlpTimestamp;
  severity: OtlpSeverity;
  body: OtlpLogBody;
  attributes: Record<OtlpString, any>;
}
```

#### æ³›å‹ç±»å‹å®šä¹‰

```typescript
// æ³›å‹æ¥å£
interface IOtlpProcessor<TInput, TOutput> {
  process(input: TInput): Promise<TOutput>;
}

interface IOtlpExporter<TData> {
  export(data: TData): Promise<void>;
}

// æ³›å‹ç±»
class OtlpBatchProcessor<T> {
  private batch: T[] = [];
  private maxBatchSize: number;

  constructor(maxBatchSize: number = 100) {
    this.maxBatchSize = maxBatchSize;
  }

  add(item: T): void {
    this.batch.push(item);
    if (this.batch.length >= this.maxBatchSize) {
      this.flush();
    }
  }

  flush(): T[] {
    const result = [...this.batch];
    this.batch = [];
    return result;
  }
}
```

### 4.2 è¯­ä¹‰çº¦æŸè§„èŒƒ

#### æ•°æ®éªŒè¯çº¦æŸ

```typescript
// éªŒè¯è£…é¥°å™¨
function validateSpan(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value;
  
  descriptor.value = function (span: OtlpSpan) {
    // éªŒè¯TraceIdæ ¼å¼
    if (!/^[0-9a-f]{32}$/.test(span.traceId)) {
      throw new ValidationError('Invalid traceId format');
    }
    
    // éªŒè¯SpanIdæ ¼å¼
    if (!/^[0-9a-f]{16}$/.test(span.spanId)) {
      throw new ValidationError('Invalid spanId format');
    }
    
    // éªŒè¯æ—¶é—´æˆ³
    if (span.startTime >= span.endTime) {
      throw new ValidationError('Start time must be before end time');
    }
    
    return method.call(this, span);
  };
}

// ä½¿ç”¨éªŒè¯
class OtlpSpanProcessor {
  @validateSpan
  processSpan(span: OtlpSpan): ProcessedSpan {
    // å¤„ç†é€»è¾‘
  }
}
```

#### ä¸šåŠ¡è§„åˆ™çº¦æŸ

```typescript
// ä¸šåŠ¡è§„åˆ™æ¥å£
interface IOtlpBusinessRule {
  validate(data: any): boolean;
  getErrorMessage(): string;
}

// å…·ä½“ä¸šåŠ¡è§„åˆ™
class OtlpTraceIdRule implements IOtlpBusinessRule {
  validate(data: OtlpSpan): boolean {
    return data.traceId && data.traceId.length === 32;
  }

  getErrorMessage(): string {
    return 'TraceId must be exactly 32 characters';
  }
}

class OtlpTimeConsistencyRule implements IOtlpBusinessRule {
  validate(data: OtlpSpan): boolean {
    return data.startTime < data.endTime;
  }

  getErrorMessage(): string {
    return 'Start time must be before end time';
  }
}

// è§„åˆ™å¼•æ“
class OtlpRuleEngine {
  private rules: IOtlpBusinessRule[] = [];

  addRule(rule: IOtlpBusinessRule): void {
    this.rules.push(rule);
  }

  validate(data: any): ValidationResult {
    const errors: string[] = [];
    
    for (const rule of this.rules) {
      if (!rule.validate(data)) {
        errors.push(rule.getErrorMessage());
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
```

### 4.3 ç¼–ç¨‹èŒƒå¼è§„èŒƒ

#### å‡½æ•°å¼ç¼–ç¨‹è§„èŒƒ

```typescript
// çº¯å‡½æ•°ç¤ºä¾‹
const processSpanData = (span: OtlpSpan): ProcessedSpan => {
  return {
    ...span,
    duration: span.endTime - span.startTime,
    processed: true
  };
};

// é«˜é˜¶å‡½æ•°ç¤ºä¾‹
const createSpanProcessor = (transformer: (span: OtlpSpan) => OtlpSpan) => {
  return (spans: OtlpSpan[]): OtlpSpan[] => {
    return spans.map(transformer);
  };
};

// å‡½æ•°ç»„åˆ
const compose = <T>(...functions: Array<(arg: T) => T>) => {
  return (arg: T): T => {
    return functions.reduceRight((result, fn) => fn(result), arg);
  };
};

// ä½¿ç”¨å‡½æ•°ç»„åˆ
const processSpan = compose(
  validateSpan,
  enrichSpan,
  transformSpan
);
```

#### é¢å‘å¯¹è±¡ç¼–ç¨‹è§„èŒƒ

```typescript
// æŠ½è±¡åŸºç±»
abstract class OtlpProcessor {
  protected config: ProcessorConfig;

  constructor(config: ProcessorConfig) {
    this.config = config;
  }

  // æ¨¡æ¿æ–¹æ³•
  async process(data: OtlpData): Promise<ProcessedData> {
    this.preProcess(data);
    const result = await this.doProcess(data);
    this.postProcess(result);
    return result;
  }

  protected preProcess(data: OtlpData): void {
    // é¢„å¤„ç†é€»è¾‘
  }

  protected abstract doProcess(data: OtlpData): Promise<ProcessedData>;

  protected postProcess(result: ProcessedData): void {
    // åå¤„ç†é€»è¾‘
  }
}

// å…·ä½“å®ç°
class OtlpSpanProcessor extends OtlpProcessor {
  protected async doProcess(data: OtlpData): Promise<ProcessedData> {
    // å…·ä½“çš„Spanå¤„ç†é€»è¾‘
    return this.processSpans(data.spans);
  }

  private processSpans(spans: OtlpSpan[]): ProcessedData {
    // Spanå¤„ç†å®ç°
  }
}
```

## ğŸ¯ 5. æœ€ä½³å®è·µ

### 5.1 æ€§èƒ½æœ€ä½³å®è·µ

#### å†…å­˜ä¼˜åŒ–

```typescript
// 1. ä½¿ç”¨å¯¹è±¡æ± 
class OtlpSpanPool {
  private pool: OtlpSpan[] = [];
  private maxSize: number;

  acquire(): OtlpSpan {
    return this.pool.pop() || new OtlpSpan();
  }

  release(span: OtlpSpan): void {
    if (this.pool.length < this.maxSize) {
      span.reset();
      this.pool.push(span);
    }
  }
}

// 2. é¿å…å†…å­˜æ³„æ¼
class OtlpEventEmitter {
  private listeners: Map<string, Function[]> = new Map();

  on(event: string, listener: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(listener);
  }

  off(event: string, listener: Function): void {
    const listeners = this.listeners.get(event);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  // æ¸…ç†æ‰€æœ‰ç›‘å¬å™¨
  removeAllListeners(): void {
    this.listeners.clear();
  }
}
```

#### æ€§èƒ½ç›‘æ§

```typescript
// æ€§èƒ½ç›‘æ§è£…é¥°å™¨
function measurePerformance(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value;
  
  descriptor.value = async function (...args: any[]) {
    const startTime = performance.now();
    const result = await method.apply(this, args);
    const endTime = performance.now();
    
    console.log(`${propertyName} took ${endTime - startTime} milliseconds`);
    
    return result;
  };
}

// ä½¿ç”¨æ€§èƒ½ç›‘æ§
class OtlpSpanProcessor {
  @measurePerformance
  async processSpan(span: OtlpSpan): Promise<ProcessedSpan> {
    // å¤„ç†é€»è¾‘
  }
}
```

### 5.2 å®‰å…¨æœ€ä½³å®è·µ

#### æ•°æ®å®‰å…¨

```typescript
// æ•°æ®è„±æ•
class OtlpDataSanitizer {
  private sensitiveFields = ['password', 'token', 'secret', 'key'];

  sanitizeSpan(span: OtlpSpan): OtlpSpan {
    const sanitizedAttributes = { ...span.attributes };
    
    for (const [key, value] of Object.entries(sanitizedAttributes)) {
      if (this.isSensitiveField(key)) {
        sanitizedAttributes[key] = this.maskValue(value);
      }
    }
    
    return {
      ...span,
      attributes: sanitizedAttributes
    };
  }

  private isSensitiveField(fieldName: string): boolean {
    return this.sensitiveFields.some(field => 
      fieldName.toLowerCase().includes(field)
    );
  }

  private maskValue(value: any): string {
    if (typeof value === 'string') {
      return '*'.repeat(Math.min(value.length, 8));
    }
    return '***';
  }
}
```

#### è¾“å…¥éªŒè¯

```typescript
// è¾“å…¥éªŒè¯å™¨
class OtlpInputValidator {
  validateSpan(span: any): ValidationResult {
    const errors: string[] = [];
    
    if (!span.traceId || typeof span.traceId !== 'string') {
      errors.push('TraceId is required and must be a string');
    }
    
    if (!span.spanId || typeof span.spanId !== 'string') {
      errors.push('SpanId is required and must be a string');
    }
    
    if (span.startTime && typeof span.startTime !== 'number') {
      errors.push('Start time must be a number');
    }
    
    if (span.endTime && typeof span.endTime !== 'number') {
      errors.push('End time must be a number');
    }
    
    if (span.startTime && span.endTime && span.startTime >= span.endTime) {
      errors.push('Start time must be before end time');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
```

### 5.3 æµ‹è¯•æœ€ä½³å®è·µ

#### å•å…ƒæµ‹è¯•

```typescript
// æµ‹è¯•å·¥å…·ç±»
class OtlpTestUtils {
  static createMockSpan(overrides: Partial<OtlpSpan> = {}): OtlpSpan {
    return {
      traceId: '12345678901234567890123456789012',
      spanId: '1234567890123456',
      name: 'test-span',
      startTime: Date.now(),
      endTime: Date.now() + 100,
      attributes: {},
      events: [],
      links: [],
      status: { code: 0 },
      ...overrides
    };
  }

  static createMockTrace(spanCount: number = 1): OtlpTrace {
    const spans = Array.from({ length: spanCount }, (_, i) => 
      this.createMockSpan({ spanId: `span-${i}` })
    );
    
    return {
      traceId: '12345678901234567890123456789012',
      spans
    };
  }
}

// æµ‹è¯•ç¤ºä¾‹
describe('OtlpSpanProcessor', () => {
  let processor: OtlpSpanProcessor;
  let mockSpan: OtlpSpan;

  beforeEach(() => {
    processor = new OtlpSpanProcessor();
    mockSpan = OtlpTestUtils.createMockSpan();
  });

  it('should process span correctly', async () => {
    const result = await processor.processSpan(mockSpan);
    
    expect(result).toBeDefined();
    expect(result.processed).toBe(true);
    expect(result.duration).toBe(100);
  });

  it('should handle invalid span', async () => {
    const invalidSpan = { ...mockSpan, traceId: '' };
    
    await expect(processor.processSpan(invalidSpan))
      .rejects.toThrow('Invalid traceId');
  });
});
```

#### é›†æˆæµ‹è¯•

```typescript
// é›†æˆæµ‹è¯•
describe('OtlpIntegration', () => {
  let exporter: OtlpExporter;
  let processor: OtlpSpanProcessor;

  beforeEach(async () => {
    exporter = new OtlpHttpExporter({
      endpoint: 'http://localhost:4318'
    });
    processor = new OtlpSpanProcessor();
  });

  it('should export processed spans', async () => {
    const span = OtlpTestUtils.createMockSpan();
    const processedSpan = await processor.processSpan(span);
    
    await expect(exporter.export([processedSpan])).resolves.not.toThrow();
  });
});
```

## ğŸ“š æ€»ç»“

### ä¸»è¦æˆæœ

1. **ç¼–ç¨‹è§„èŒƒä½“ç³»** - å»ºç«‹äº†å®Œæ•´çš„OTLPç¼–ç¨‹è§„èŒƒä½“ç³»
2. **ç¼–ç¨‹æƒ¯ç”¨æ³•** - åˆ¶å®šäº†OTLPç¼–ç¨‹çš„æ ‡å‡†æƒ¯ç”¨æ³•å’Œæœ€ä½³å®è·µ
3. **è®¾è®¡æ¨¡å¼åº”ç”¨** - æä¾›äº†OTLPä¸­è®¾è®¡æ¨¡å¼çš„å®Œæ•´åº”ç”¨æŒ‡å—
4. **è¯­ä¹‰è§„èŒƒ** - å»ºç«‹äº†OTLPçš„è¯­ä¹‰å®šä¹‰å’Œçº¦æŸè§„èŒƒ
5. **æœ€ä½³å®è·µ** - åˆ¶å®šäº†æ€§èƒ½ã€å®‰å…¨ã€æµ‹è¯•ç­‰æ–¹é¢çš„æœ€ä½³å®è·µ

### åˆ›æ–°è´¡çŒ®

1. **è§„èŒƒåˆ›æ–°** - é¦–æ¬¡å»ºç«‹äº†OTLPçš„å®Œæ•´ç¼–ç¨‹è§„èŒƒä½“ç³»
2. **æƒ¯ç”¨æ³•åˆ›æ–°** - åˆ›æ–°äº†OTLPç¼–ç¨‹çš„æ ‡å‡†æƒ¯ç”¨æ³•
3. **æ¨¡å¼åº”ç”¨åˆ›æ–°** - æä¾›äº†è®¾è®¡æ¨¡å¼åœ¨OTLPä¸­çš„åˆ›æ–°åº”ç”¨
4. **è¯­ä¹‰è§„èŒƒåˆ›æ–°** - å»ºç«‹äº†OTLPçš„è¯­ä¹‰è§„èŒƒä½“ç³»

### åº”ç”¨ä»·å€¼

1. **å¼€å‘æŒ‡å¯¼** - ä¸ºOTLPå¼€å‘æä¾›å®Œæ•´çš„æŒ‡å¯¼
2. **è´¨é‡ä¿è¯** - ä¸ºOTLPä»£ç è´¨é‡æä¾›ä¿è¯
3. **å›¢é˜Ÿåä½œ** - ä¿ƒè¿›å›¢é˜Ÿåä½œå’ŒçŸ¥è¯†ä¼ æ‰¿
4. **æ ‡å‡†åŒ–** - ä¸ºOTLPæ ‡å‡†åŒ–æä¾›å‚è€ƒ

---

**æ–‡æ¡£åˆ›å»ºå®Œæˆæ—¶é—´**: 2025å¹´10æœˆ6æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLP ç³»ç»Ÿåˆ†æå›¢é˜Ÿ  
**çŠ¶æ€**: ç¼–ç¨‹è§„èŒƒåˆ¶å®šå®Œæˆ
