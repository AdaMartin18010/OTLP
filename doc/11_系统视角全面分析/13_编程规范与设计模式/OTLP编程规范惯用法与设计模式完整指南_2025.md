# OTLPç¼–ç¨‹è§„èŒƒã€æƒ¯ç”¨æ³•ä¸è®¾è®¡æ¨¡å¼å®Œæ•´æŒ‡å—

## ğŸ“‹ ç›®å½•

- [OTLPç¼–ç¨‹è§„èŒƒã€æƒ¯ç”¨æ³•ä¸è®¾è®¡æ¨¡å¼å®Œæ•´æŒ‡å—](#otlpç¼–ç¨‹è§„èŒƒæƒ¯ç”¨æ³•ä¸è®¾è®¡æ¨¡å¼å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ¦‚è¿°](#-æ¦‚è¿°)
    - [æ ¸å¿ƒåŸåˆ™](#æ ¸å¿ƒåŸåˆ™)
  - [ğŸ“ ç¼–ç¨‹è§„èŒƒä½“ç³»](#-ç¼–ç¨‹è§„èŒƒä½“ç³»)
    - [1. å‘½åè§„èŒƒ](#1-å‘½åè§„èŒƒ)
      - [1.1 åŸºç¡€å‘½åè§„èŒƒ](#11-åŸºç¡€å‘½åè§„èŒƒ)
      - [1.2 OTLPç‰¹å®šå‘½åè§„èŒƒ](#12-otlpç‰¹å®šå‘½åè§„èŒƒ)
    - [2. ä»£ç ç»“æ„è§„èŒƒ](#2-ä»£ç ç»“æ„è§„èŒƒ)
      - [2.1 æ–‡ä»¶ç»„ç»‡ç»“æ„](#21-æ–‡ä»¶ç»„ç»‡ç»“æ„)
      - [2.2 ç±»ç»“æ„è§„èŒƒ](#22-ç±»ç»“æ„è§„èŒƒ)
    - [3. æ³¨é‡Šè§„èŒƒ](#3-æ³¨é‡Šè§„èŒƒ)
      - [3.1 JSDocæ³¨é‡Šè§„èŒƒ](#31-jsdocæ³¨é‡Šè§„èŒƒ)
      - [3.2 å†…è”æ³¨é‡Šè§„èŒƒ](#32-å†…è”æ³¨é‡Šè§„èŒƒ)
    - [4. é”™è¯¯å¤„ç†è§„èŒƒ](#4-é”™è¯¯å¤„ç†è§„èŒƒ)
      - [4.1 é”™è¯¯ç±»å‹å®šä¹‰](#41-é”™è¯¯ç±»å‹å®šä¹‰)
      - [4.2 é”™è¯¯å¤„ç†æ¨¡å¼](#42-é”™è¯¯å¤„ç†æ¨¡å¼)
  - [ğŸ”§ ç¼–ç¨‹æƒ¯ç”¨æ³•](#-ç¼–ç¨‹æƒ¯ç”¨æ³•)
    - [1. æ•°æ®æ”¶é›†æƒ¯ç”¨æ³•](#1-æ•°æ®æ”¶é›†æƒ¯ç”¨æ³•)
      - [1.1 å¼‚æ­¥æ•°æ®æ”¶é›†](#11-å¼‚æ­¥æ•°æ®æ”¶é›†)
      - [1.2 æ‰¹å¤„ç†æ”¶é›†](#12-æ‰¹å¤„ç†æ”¶é›†)
    - [2. æ•°æ®å¤„ç†æƒ¯ç”¨æ³•](#2-æ•°æ®å¤„ç†æƒ¯ç”¨æ³•)
      - [2.1 ç®¡é“å¤„ç†æ¨¡å¼](#21-ç®¡é“å¤„ç†æ¨¡å¼)
      - [2.2 æµå¼å¤„ç†](#22-æµå¼å¤„ç†)
    - [3. æ•°æ®ä¼ è¾“æƒ¯ç”¨æ³•](#3-æ•°æ®ä¼ è¾“æƒ¯ç”¨æ³•)
      - [3.1 é‡è¯•æœºåˆ¶](#31-é‡è¯•æœºåˆ¶)
      - [3.2 èƒŒå‹æ§åˆ¶](#32-èƒŒå‹æ§åˆ¶)
    - [4. é”™è¯¯å¤„ç†æƒ¯ç”¨æ³•](#4-é”™è¯¯å¤„ç†æƒ¯ç”¨æ³•)
      - [4.1 æ–­è·¯å™¨æ¨¡å¼](#41-æ–­è·¯å™¨æ¨¡å¼)
  - [ğŸ—ï¸ è®¾è®¡æ¨¡å¼](#ï¸-è®¾è®¡æ¨¡å¼)
    - [1. åˆ›å»ºå‹æ¨¡å¼](#1-åˆ›å»ºå‹æ¨¡å¼)
      - [1.1 å·¥å‚æ¨¡å¼](#11-å·¥å‚æ¨¡å¼)
      - [1.2 å»ºé€ è€…æ¨¡å¼](#12-å»ºé€ è€…æ¨¡å¼)
    - [2. ç»“æ„å‹æ¨¡å¼](#2-ç»“æ„å‹æ¨¡å¼)
      - [2.1 é€‚é…å™¨æ¨¡å¼](#21-é€‚é…å™¨æ¨¡å¼)
      - [2.2 è£…é¥°å™¨æ¨¡å¼](#22-è£…é¥°å™¨æ¨¡å¼)
    - [3. è¡Œä¸ºå‹æ¨¡å¼](#3-è¡Œä¸ºå‹æ¨¡å¼)
      - [3.1 è§‚å¯Ÿè€…æ¨¡å¼](#31-è§‚å¯Ÿè€…æ¨¡å¼)
      - [3.2 ç­–ç•¥æ¨¡å¼](#32-ç­–ç•¥æ¨¡å¼)
  - [ğŸ“Š è¯­ä¹‰æ¨¡å‹é›†æˆ](#-è¯­ä¹‰æ¨¡å‹é›†æˆ)
    - [1. ç±»å‹ç³»ç»Ÿé›†æˆ](#1-ç±»å‹ç³»ç»Ÿé›†æˆ)
    - [2. è¯­ä¹‰çº¦æŸ](#2-è¯­ä¹‰çº¦æŸ)
  - [âœ… æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. æ€§èƒ½ä¼˜åŒ–](#1-æ€§èƒ½ä¼˜åŒ–)
    - [2. å†…å­˜ç®¡ç†](#2-å†…å­˜ç®¡ç†)
  - [ğŸ” è´¨é‡ä¿è¯](#-è´¨é‡ä¿è¯)
    - [1. å•å…ƒæµ‹è¯•](#1-å•å…ƒæµ‹è¯•)
    - [2. é›†æˆæµ‹è¯•](#2-é›†æˆæµ‹è¯•)
    - [3. æ€§èƒ½æµ‹è¯•](#3-æ€§èƒ½æµ‹è¯•)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)

## ğŸ¯ æ¦‚è¿°

æœ¬æŒ‡å—æä¾›OTLPç¼–ç¨‹çš„å®Œæ•´è§„èŒƒä½“ç³»ï¼ŒåŒ…æ‹¬ç¼–ç¨‹è§„èŒƒã€æƒ¯ç”¨æ³•å’Œè®¾è®¡æ¨¡å¼ï¼Œç¡®ä¿OTLPåº”ç”¨çš„æ ‡å‡†åŒ–ã€å¯ç»´æŠ¤æ€§å’Œé«˜æ€§èƒ½ã€‚

### æ ¸å¿ƒåŸåˆ™

1. **ä¸€è‡´æ€§åŸåˆ™** - ç»Ÿä¸€çš„ç¼–ç¨‹é£æ ¼å’Œå‘½åè§„èŒƒ
2. **å¯è¯»æ€§åŸåˆ™** - æ¸…æ™°çš„ä»£ç ç»“æ„å’Œæ³¨é‡Š
3. **å¯ç»´æŠ¤æ€§åŸåˆ™** - æ¨¡å—åŒ–è®¾è®¡å’Œæ¾è€¦åˆ
4. **æ€§èƒ½åŸåˆ™** - é«˜æ•ˆçš„èµ„æºåˆ©ç”¨å’Œä¼˜åŒ–
5. **å¯é æ€§åŸåˆ™** - å¥å£®çš„é”™è¯¯å¤„ç†å’Œå®¹é”™æœºåˆ¶

## ğŸ“ ç¼–ç¨‹è§„èŒƒä½“ç³»

### 1. å‘½åè§„èŒƒ

#### 1.1 åŸºç¡€å‘½åè§„èŒƒ

```typescript
// ç±»åï¼šPascalCase
class OtlpTraceCollector {
  // æ–¹æ³•åï¼šcamelCase
  collectSpan(span: Span): void {
    // å˜é‡åï¼šcamelCase
    const spanId = span.getId();
    // å¸¸é‡åï¼šUPPER_SNAKE_CASE
    const MAX_BATCH_SIZE = 1000;
  }
}

// æ¥å£åï¼šI + PascalCase
interface IOtlpExporter {
  export(data: OtlpData): Promise<void>;
}

// æšä¸¾åï¼šPascalCase
enum OtlpProtocol {
  HTTP = 'http',
  GRPC = 'grpc'
}
```

#### 1.2 OTLPç‰¹å®šå‘½åè§„èŒƒ

```typescript
// OTLPç»„ä»¶å‰ç¼€
class OtlpSpanProcessor { }
class OtlpMetricExporter { }
class OtlpLogCollector { }

// æ•°æ®æ¨¡å‹å‘½å
interface OtlpSpanData { }
interface OtlpMetricData { }
interface OtlpLogData { }

// é…ç½®ç±»å‘½å
class OtlpCollectorConfig { }
class OtlpExporterConfig { }
```

### 2. ä»£ç ç»“æ„è§„èŒƒ

#### 2.1 æ–‡ä»¶ç»„ç»‡ç»“æ„

```text
src/
â”œâ”€â”€ collectors/          # æ•°æ®æ”¶é›†å™¨
â”‚   â”œâ”€â”€ trace/
â”‚   â”œâ”€â”€ metric/
â”‚   â””â”€â”€ log/
â”œâ”€â”€ processors/          # æ•°æ®å¤„ç†å™¨
â”‚   â”œâ”€â”€ batch/
â”‚   â”œâ”€â”€ filter/
â”‚   â””â”€â”€ transform/
â”œâ”€â”€ exporters/           # æ•°æ®å¯¼å‡ºå™¨
â”‚   â”œâ”€â”€ http/
â”‚   â”œâ”€â”€ grpc/
â”‚   â””â”€â”€ file/
â”œâ”€â”€ models/              # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ span.ts
â”‚   â”œâ”€â”€ metric.ts
â”‚   â””â”€â”€ log.ts
â”œâ”€â”€ config/              # é…ç½®ç®¡ç†
â””â”€â”€ utils/               # å·¥å…·å‡½æ•°
```

#### 2.2 ç±»ç»“æ„è§„èŒƒ

```typescript
export class OtlpSpanProcessor {
  // 1. é™æ€å¸¸é‡
  private static readonly DEFAULT_BATCH_SIZE = 100;
  private static readonly DEFAULT_TIMEOUT = 5000;

  // 2. ç§æœ‰å­—æ®µ
  private readonly config: ProcessorConfig;
  private readonly exporter: IOtlpExporter;
  private readonly buffer: Span[] = [];

  // 3. æ„é€ å‡½æ•°
  constructor(config: ProcessorConfig, exporter: IOtlpExporter) {
    this.config = config;
    this.exporter = exporter;
  }

  // 4. å…¬å…±æ–¹æ³•
  public async processSpan(span: Span): Promise<void> {
    // å®ç°é€»è¾‘
  }

  // 5. ç§æœ‰æ–¹æ³•
  private async flushBuffer(): Promise<void> {
    // å®ç°é€»è¾‘
  }
}
```

### 3. æ³¨é‡Šè§„èŒƒ

#### 3.1 JSDocæ³¨é‡Šè§„èŒƒ

```typescript
/**
 * OTLP Spanå¤„ç†å™¨ï¼Œè´Ÿè´£æ‰¹å¤„ç†å’Œå¯¼å‡ºSpanæ•°æ®
 * 
 * @class OtlpSpanProcessor
 * @implements {ISpanProcessor}
 * 
 * @example
 * ```typescript
 * const processor = new OtlpSpanProcessor(config, exporter);
 * await processor.processSpan(span);
 * ```
 */
export class OtlpSpanProcessor implements ISpanProcessor {
  /**
   * å¤„ç†å•ä¸ªSpan
   * 
   * @param span - è¦å¤„ç†çš„Spanå¯¹è±¡
   * @returns Promise<void> å¤„ç†å®Œæˆåçš„Promise
   * 
   * @throws {ValidationError} å½“Spanæ•°æ®æ— æ•ˆæ—¶æŠ›å‡º
   * @throws {ExportError} å½“å¯¼å‡ºå¤±è´¥æ—¶æŠ›å‡º
   */
  public async processSpan(span: Span): Promise<void> {
    // å®ç°é€»è¾‘
  }
}
```

#### 3.2 å†…è”æ³¨é‡Šè§„èŒƒ

```typescript
public async processSpan(span: Span): Promise<void> {
  // éªŒè¯Spanæ•°æ®çš„æœ‰æ•ˆæ€§
  if (!this.isValidSpan(span)) {
    throw new ValidationError('Invalid span data');
  }

  // æ·»åŠ åˆ°æ‰¹å¤„ç†ç¼“å†²åŒº
  this.buffer.push(span);

  // æ£€æŸ¥æ˜¯å¦éœ€è¦ç«‹å³åˆ·æ–°ç¼“å†²åŒº
  if (this.shouldFlush()) {
    await this.flushBuffer();
  }
}
```

### 4. é”™è¯¯å¤„ç†è§„èŒƒ

#### 4.1 é”™è¯¯ç±»å‹å®šä¹‰

```typescript
// åŸºç¡€é”™è¯¯ç±»
export abstract class OtlpError extends Error {
  public readonly code: string;
  public readonly timestamp: Date;

  constructor(message: string, code: string) {
    super(message);
    this.code = code;
    this.timestamp = new Date();
  }
}

// å…·ä½“é”™è¯¯ç±»å‹
export class ValidationError extends OtlpError {
  constructor(message: string) {
    super(message, 'VALIDATION_ERROR');
  }
}

export class ExportError extends OtlpError {
  constructor(message: string, public readonly cause?: Error) {
    super(message, 'EXPORT_ERROR');
  }
}

export class ConfigurationError extends OtlpError {
  constructor(message: string) {
    super(message, 'CONFIGURATION_ERROR');
  }
}
```

#### 4.2 é”™è¯¯å¤„ç†æ¨¡å¼

```typescript
export class OtlpSpanProcessor {
  public async processSpan(span: Span): Promise<void> {
    try {
      // éªŒè¯æ•°æ®
      this.validateSpan(span);
      
      // å¤„ç†æ•°æ®
      await this.processSpanData(span);
      
    } catch (error) {
      // é”™è¯¯åˆ†ç±»å¤„ç†
      if (error instanceof ValidationError) {
        this.handleValidationError(error);
      } else if (error instanceof ExportError) {
        this.handleExportError(error);
      } else {
        this.handleUnknownError(error);
      }
      
      // é‡æ–°æŠ›å‡ºæˆ–è®°å½•é”™è¯¯
      throw error;
    }
  }

  private handleValidationError(error: ValidationError): void {
    // è®°å½•éªŒè¯é”™è¯¯
    console.warn(`Validation failed: ${error.message}`);
  }

  private handleExportError(error: ExportError): void {
    // è®°å½•å¯¼å‡ºé”™è¯¯å¹¶å°è¯•é‡è¯•
    console.error(`Export failed: ${error.message}`, error.cause);
  }
}
```

## ğŸ”§ ç¼–ç¨‹æƒ¯ç”¨æ³•

### 1. æ•°æ®æ”¶é›†æƒ¯ç”¨æ³•

#### 1.1 å¼‚æ­¥æ•°æ®æ”¶é›†

```typescript
export class OtlpTraceCollector {
  private readonly collectors: Map<string, ISpanCollector> = new Map();

  /**
   * å¼‚æ­¥æ”¶é›†Spanæ•°æ®
   */
  public async collectSpanAsync(span: Span): Promise<void> {
    // ä½¿ç”¨Promise.allå¹¶è¡Œæ”¶é›†
    const collectionPromises = Array.from(this.collectors.values())
      .map(collector => this.safeCollect(collector, span));

    await Promise.allSettled(collectionPromises);
  }

  private async safeCollect(collector: ISpanCollector, span: Span): Promise<void> {
    try {
      await collector.collect(span);
    } catch (error) {
      // å•ä¸ªæ”¶é›†å™¨å¤±è´¥ä¸å½±å“å…¶ä»–æ”¶é›†å™¨
      console.warn(`Collector failed: ${error.message}`);
    }
  }
}
```

#### 1.2 æ‰¹å¤„ç†æ”¶é›†

```typescript
export class OtlpBatchCollector {
  private readonly buffer: Span[] = [];
  private readonly batchSize: number;
  private readonly flushInterval: number;

  constructor(config: BatchConfig) {
    this.batchSize = config.batchSize;
    this.flushInterval = config.flushInterval;
    
    // å®šæ—¶åˆ·æ–°
    setInterval(() => this.flush(), this.flushInterval);
  }

  public async collect(span: Span): Promise<void> {
    this.buffer.push(span);
    
    if (this.buffer.length >= this.batchSize) {
      await this.flush();
    }
  }

  private async flush(): Promise<void> {
    if (this.buffer.length === 0) return;

    const batch = this.buffer.splice(0, this.batchSize);
    await this.processBatch(batch);
  }
}
```

### 2. æ•°æ®å¤„ç†æƒ¯ç”¨æ³•

#### 2.1 ç®¡é“å¤„ç†æ¨¡å¼

```typescript
export class OtlpDataPipeline {
  private readonly processors: IDataProcessor[] = [];

  public addProcessor(processor: IDataProcessor): void {
    this.processors.push(processor);
  }

  public async process(data: OtlpData): Promise<OtlpData> {
    let result = data;
    
    for (const processor of this.processors) {
      result = await processor.process(result);
    }
    
    return result;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const pipeline = new OtlpDataPipeline();
pipeline.addProcessor(new ValidationProcessor());
pipeline.addProcessor(new FilterProcessor());
pipeline.addProcessor(new TransformProcessor());
```

#### 2.2 æµå¼å¤„ç†

```typescript
export class OtlpStreamProcessor {
  private readonly stream: ReadableStream<OtlpData>;
  private readonly processor: IDataProcessor;

  constructor(stream: ReadableStream<OtlpData>, processor: IDataProcessor) {
    this.stream = stream;
    this.processor = processor;
  }

  public async process(): Promise<void> {
    const reader = this.stream.getReader();
    
    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        await this.processor.process(value);
      }
    } finally {
      reader.releaseLock();
    }
  }
}
```

### 3. æ•°æ®ä¼ è¾“æƒ¯ç”¨æ³•

#### 3.1 é‡è¯•æœºåˆ¶

```typescript
export class OtlpRetryExporter implements IOtlpExporter {
  private readonly maxRetries: number;
  private readonly retryDelay: number;
  private readonly backoffMultiplier: number;

  constructor(config: RetryConfig) {
    this.maxRetries = config.maxRetries;
    this.retryDelay = config.retryDelay;
    this.backoffMultiplier = config.backoffMultiplier;
  }

  public async export(data: OtlpData): Promise<void> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        await this.doExport(data);
        return; // æˆåŠŸï¼Œé€€å‡ºé‡è¯•å¾ªç¯
      } catch (error) {
        lastError = error as Error;
        
        if (attempt < this.maxRetries) {
          const delay = this.calculateDelay(attempt);
          await this.sleep(delay);
        }
      }
    }
    
    throw new ExportError(`Export failed after ${this.maxRetries} retries`, lastError);
  }

  private calculateDelay(attempt: number): number {
    return this.retryDelay * Math.pow(this.backoffMultiplier, attempt);
  }
}
```

#### 3.2 èƒŒå‹æ§åˆ¶

```typescript
export class OtlpBackpressureExporter implements IOtlpExporter {
  private readonly maxQueueSize: number;
  private readonly queue: OtlpData[] = [];
  private isProcessing = false;

  constructor(maxQueueSize: number) {
    this.maxQueueSize = maxQueueSize;
  }

  public async export(data: OtlpData): Promise<void> {
    // æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦å·²æ»¡
    if (this.queue.length >= this.maxQueueSize) {
      throw new BackpressureError('Export queue is full');
    }

    this.queue.push(data);
    
    if (!this.isProcessing) {
      this.processQueue();
    }
  }

  private async processQueue(): Promise<void> {
    this.isProcessing = true;
    
    try {
      while (this.queue.length > 0) {
        const data = this.queue.shift()!;
        await this.doExport(data);
      }
    } finally {
      this.isProcessing = false;
    }
  }
}
```

### 4. é”™è¯¯å¤„ç†æƒ¯ç”¨æ³•

#### 4.1 æ–­è·¯å™¨æ¨¡å¼

```typescript
export class OtlpCircuitBreaker implements IOtlpExporter {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount = 0;
  private lastFailureTime = 0;

  constructor(
    private readonly threshold: number,
    private readonly timeout: number,
    private readonly exporter: IOtlpExporter
  ) {}

  public async export(data: OtlpData): Promise<void> {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new CircuitBreakerError('Circuit breaker is open');
      }
    }

    try {
      await this.exporter.export(data);
      this.onSuccess();
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failureCount = 0;
    this.state = CircuitState.CLOSED;
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.threshold) {
      this.state = CircuitState.OPEN;
    }
  }
}
```

## ğŸ—ï¸ è®¾è®¡æ¨¡å¼

### 1. åˆ›å»ºå‹æ¨¡å¼

#### 1.1 å·¥å‚æ¨¡å¼

```typescript
export interface IOtlpExporterFactory {
  createExporter(config: ExporterConfig): IOtlpExporter;
}

export class OtlpExporterFactory implements IOtlpExporterFactory {
  public createExporter(config: ExporterConfig): IOtlpExporter {
    switch (config.type) {
      case 'http':
        return new HttpOtlpExporter(config);
      case 'grpc':
        return new GrpcOtlpExporter(config);
      case 'file':
        return new FileOtlpExporter(config);
      default:
        throw new ConfigurationError(`Unsupported exporter type: ${config.type}`);
    }
  }
}
```

#### 1.2 å»ºé€ è€…æ¨¡å¼

```typescript
export class OtlpCollectorBuilder {
  private config: CollectorConfig = {};
  private processors: IDataProcessor[] = [];
  private exporters: IOtlpExporter[] = [];

  public withConfig(config: Partial<CollectorConfig>): this {
    this.config = { ...this.config, ...config };
    return this;
  }

  public withProcessor(processor: IDataProcessor): this {
    this.processors.push(processor);
    return this;
  }

  public withExporter(exporter: IOtlpExporter): this {
    this.exporters.push(exporter);
    return this;
  }

  public build(): OtlpCollector {
    return new OtlpCollector(this.config, this.processors, this.exporters);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const collector = new OtlpCollectorBuilder()
  .withConfig({ batchSize: 1000, timeout: 5000 })
  .withProcessor(new ValidationProcessor())
  .withProcessor(new FilterProcessor())
  .withExporter(new HttpOtlpExporter(httpConfig))
  .build();
```

### 2. ç»“æ„å‹æ¨¡å¼

#### 2.1 é€‚é…å™¨æ¨¡å¼

```typescript
export interface ILegacyExporter {
  send(data: any): void;
}

export class OtlpAdapter implements IOtlpExporter {
  constructor(private readonly legacyExporter: ILegacyExporter) {}

  public async export(data: OtlpData): Promise<void> {
    // å°†OTLPæ•°æ®è½¬æ¢ä¸ºé—ç•™æ ¼å¼
    const legacyData = this.convertToLegacyFormat(data);
    this.legacyExporter.send(legacyData);
  }

  private convertToLegacyFormat(data: OtlpData): any {
    // è½¬æ¢é€»è¾‘
    return {
      // è½¬æ¢åçš„æ•°æ®æ ¼å¼
    };
  }
}
```

#### 2.2 è£…é¥°å™¨æ¨¡å¼

```typescript
export class OtlpExporterDecorator implements IOtlpExporter {
  constructor(private readonly exporter: IOtlpExporter) {}

  public async export(data: OtlpData): Promise<void> {
    // å‰ç½®å¤„ç†
    await this.beforeExport(data);
    
    try {
      // æ‰§è¡Œå®é™…å¯¼å‡º
      await this.exporter.export(data);
      
      // åç½®å¤„ç†
      await this.afterExport(data);
    } catch (error) {
      // é”™è¯¯å¤„ç†
      await this.onExportError(data, error);
      throw error;
    }
  }

  protected async beforeExport(data: OtlpData): Promise<void> {
    // å‰ç½®å¤„ç†é€»è¾‘
  }

  protected async afterExport(data: OtlpData): Promise<void> {
    // åç½®å¤„ç†é€»è¾‘
  }

  protected async onExportError(data: OtlpData, error: Error): Promise<void> {
    // é”™è¯¯å¤„ç†é€»è¾‘
  }
}

// å…·ä½“è£…é¥°å™¨
export class MetricsExporterDecorator extends OtlpExporterDecorator {
  protected async beforeExport(data: OtlpData): Promise<void> {
    // è®°å½•å¯¼å‡ºå¼€å§‹æ—¶é—´
    console.time('export-duration');
  }

  protected async afterExport(data: OtlpData): Promise<void> {
    // è®°å½•å¯¼å‡ºå®Œæˆæ—¶é—´
    console.timeEnd('export-duration');
  }
}
```

### 3. è¡Œä¸ºå‹æ¨¡å¼

#### 3.1 è§‚å¯Ÿè€…æ¨¡å¼

```typescript
export interface IOtlpObserver {
  onDataCollected(data: OtlpData): void;
  onDataProcessed(data: OtlpData): void;
  onDataExported(data: OtlpData): void;
}

export class OtlpSubject {
  private readonly observers: IOtlpObserver[] = [];

  public addObserver(observer: IOtlpObserver): void {
    this.observers.push(observer);
  }

  public removeObserver(observer: IOtlpObserver): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  protected notifyDataCollected(data: OtlpData): void {
    this.observers.forEach(observer => observer.onDataCollected(data));
  }

  protected notifyDataProcessed(data: OtlpData): void {
    this.observers.forEach(observer => observer.onDataProcessed(data));
  }

  protected notifyDataExported(data: OtlpData): void {
    this.observers.forEach(observer => observer.onDataExported(data));
  }
}
```

#### 3.2 ç­–ç•¥æ¨¡å¼

```typescript
export interface IProcessingStrategy {
  process(data: OtlpData): Promise<OtlpData>;
}

export class OtlpDataProcessor {
  private strategy: IProcessingStrategy;

  constructor(strategy: IProcessingStrategy) {
    this.strategy = strategy;
  }

  public setStrategy(strategy: IProcessingStrategy): void {
    this.strategy = strategy;
  }

  public async process(data: OtlpData): Promise<OtlpData> {
    return await this.strategy.process(data);
  }
}

// å…·ä½“ç­–ç•¥
export class ValidationStrategy implements IProcessingStrategy {
  public async process(data: OtlpData): Promise<OtlpData> {
    // éªŒè¯é€»è¾‘
    this.validate(data);
    return data;
  }
}

export class FilterStrategy implements IProcessingStrategy {
  public async process(data: OtlpData): Promise<OtlpData> {
    // è¿‡æ»¤é€»è¾‘
    return this.filter(data);
  }
}
```

## ğŸ“Š è¯­ä¹‰æ¨¡å‹é›†æˆ

### 1. ç±»å‹ç³»ç»Ÿé›†æˆ

```typescript
// åŸºç¡€ç±»å‹å®šä¹‰
export type OtlpDataType = 'span' | 'metric' | 'log';

export interface OtlpData {
  readonly type: OtlpDataType;
  readonly timestamp: Date;
  readonly attributes: Map<string, any>;
}

// æ³›å‹çº¦æŸ
export interface IOtlpProcessor<T extends OtlpData> {
  process(data: T): Promise<T>;
}

// ç±»å‹å®ˆå«
export function isSpanData(data: OtlpData): data is SpanData {
  return data.type === 'span';
}

export function isMetricData(data: OtlpData): data is MetricData {
  return data.type === 'metric';
}
```

### 2. è¯­ä¹‰çº¦æŸ

```typescript
export class OtlpSemanticConstraints {
  // æ•°æ®å®Œæ•´æ€§çº¦æŸ
  public static validateDataIntegrity(data: OtlpData): boolean {
    return data.timestamp !== null && 
           data.attributes !== null &&
           Object.keys(data.attributes).length > 0;
  }

  // æ—¶é—´é¡ºåºçº¦æŸ
  public static validateTimeOrder(events: OtlpData[]): boolean {
    for (let i = 1; i < events.length; i++) {
      if (events[i].timestamp < events[i-1].timestamp) {
        return false;
      }
    }
    return true;
  }

  // å› æœå…³ç³»çº¦æŸ
  public static validateCausality(parent: SpanData, child: SpanData): boolean {
    return child.timestamp >= parent.timestamp &&
           child.attributes.get('parent_span_id') === parent.attributes.get('span_id');
  }
}
```

## âœ… æœ€ä½³å®è·µ

### 1. æ€§èƒ½ä¼˜åŒ–

```typescript
export class OtlpPerformanceOptimizer {
  // å¯¹è±¡æ± æ¨¡å¼
  private readonly spanPool: Span[] = [];
  private readonly maxPoolSize = 1000;

  public getSpan(): Span {
    return this.spanPool.pop() || new Span();
  }

  public releaseSpan(span: Span): void {
    if (this.spanPool.length < this.maxPoolSize) {
      span.reset();
      this.spanPool.push(span);
    }
  }

  // æ‰¹é‡å¤„ç†ä¼˜åŒ–
  public async processBatch(data: OtlpData[]): Promise<void> {
    const chunks = this.chunkArray(data, 100);
    
    await Promise.all(
      chunks.map(chunk => this.processChunk(chunk))
    );
  }

  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}
```

### 2. å†…å­˜ç®¡ç†

```typescript
export class OtlpMemoryManager {
  private readonly maxMemoryUsage: number;
  private currentMemoryUsage = 0;

  constructor(maxMemoryUsage: number) {
    this.maxMemoryUsage = maxMemoryUsage;
  }

  public checkMemoryUsage(): boolean {
    return this.currentMemoryUsage < this.maxMemoryUsage;
  }

  public allocateMemory(size: number): boolean {
    if (this.currentMemoryUsage + size > this.maxMemoryUsage) {
      return false;
    }
    
    this.currentMemoryUsage += size;
    return true;
  }

  public deallocateMemory(size: number): void {
    this.currentMemoryUsage = Math.max(0, this.currentMemoryUsage - size);
  }
}
```

## ğŸ” è´¨é‡ä¿è¯

### 1. å•å…ƒæµ‹è¯•

```typescript
describe('OtlpSpanProcessor', () => {
  let processor: OtlpSpanProcessor;
  let mockExporter: jest.Mocked<IOtlpExporter>;

  beforeEach(() => {
    mockExporter = createMockExporter();
    processor = new OtlpSpanProcessor(config, mockExporter);
  });

  it('should process valid span data', async () => {
    const span = createTestSpan();
    
    await processor.processSpan(span);
    
    expect(mockExporter.export).toHaveBeenCalledWith(span);
  });

  it('should handle validation errors', async () => {
    const invalidSpan = createInvalidSpan();
    
    await expect(processor.processSpan(invalidSpan))
      .rejects.toThrow(ValidationError);
  });
});
```

### 2. é›†æˆæµ‹è¯•

```typescript
describe('OtlpIntegration', () => {
  it('should collect, process, and export data end-to-end', async () => {
    const collector = new OtlpCollector(config);
    const processor = new OtlpSpanProcessor(processorConfig, exporter);
    const exporter = new HttpOtlpExporter(exporterConfig);

    // é›†æˆæµ‹è¯•é€»è¾‘
    const span = createTestSpan();
    await collector.collect(span);
    await processor.processSpan(span);
    await exporter.export(span);
  });
});
```

### 3. æ€§èƒ½æµ‹è¯•

```typescript
describe('OtlpPerformance', () => {
  it('should handle high throughput', async () => {
    const processor = new OtlpSpanProcessor(config, exporter);
    const spans = generateTestSpans(10000);
    
    const startTime = Date.now();
    
    await Promise.all(
      spans.map(span => processor.processSpan(span))
    );
    
    const duration = Date.now() - startTime;
    expect(duration).toBeLessThan(5000); // 5ç§’å†…å¤„ç†å®Œæˆ
  });
});
```

---

## ğŸ“ æ€»ç»“

æœ¬æŒ‡å—æä¾›äº†OTLPç¼–ç¨‹çš„å®Œæ•´è§„èŒƒä½“ç³»ï¼ŒåŒ…æ‹¬ï¼š

1. **ç¼–ç¨‹è§„èŒƒ** - ç»Ÿä¸€çš„å‘½åã€ç»“æ„ã€æ³¨é‡Šå’Œé”™è¯¯å¤„ç†è§„èŒƒ
2. **ç¼–ç¨‹æƒ¯ç”¨æ³•** - æ•°æ®æ”¶é›†ã€å¤„ç†ã€ä¼ è¾“å’Œé”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µ
3. **è®¾è®¡æ¨¡å¼** - åˆ›å»ºå‹ã€ç»“æ„å‹å’Œè¡Œä¸ºå‹æ¨¡å¼çš„åº”ç”¨
4. **è¯­ä¹‰æ¨¡å‹é›†æˆ** - ç±»å‹ç³»ç»Ÿå’Œè¯­ä¹‰çº¦æŸçš„é›†æˆ
5. **æœ€ä½³å®è·µ** - æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†
6. **è´¨é‡ä¿è¯** - å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•

é€šè¿‡éµå¾ªè¿™äº›è§„èŒƒå’Œæ¨¡å¼ï¼Œå¯ä»¥ç¡®ä¿OTLPåº”ç”¨çš„é«˜è´¨é‡ã€é«˜æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚
