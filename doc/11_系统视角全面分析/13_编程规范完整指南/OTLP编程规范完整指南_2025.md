# OTLPç¼–ç¨‹è§„èŒƒå®Œæ•´æŒ‡å—

## ç›®å½•

- [OTLPç¼–ç¨‹è§„èŒƒå®Œæ•´æŒ‡å—](#otlpç¼–ç¨‹è§„èŒƒå®Œæ•´æŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“Š æ–‡æ¡£æ¦‚è§ˆ](#-æ–‡æ¡£æ¦‚è§ˆ)
  - [ğŸ¯ æŒ‡å—ç›®æ ‡](#-æŒ‡å—ç›®æ ‡)
    - [ä¸»è¦ç›®æ ‡](#ä¸»è¦ç›®æ ‡)
  - [ğŸ“‹ 1. ç¼–ç¨‹è§„èŒƒä½“ç³»](#-1-ç¼–ç¨‹è§„èŒƒä½“ç³»)
    - [1.1 å‘½åè§„èŒƒ](#11-å‘½åè§„èŒƒ)
      - [å®Œæ•´å‘½åè§„èŒƒè¡¨](#å®Œæ•´å‘½åè§„èŒƒè¡¨)
    - [1.2 ä»£ç ç»„ç»‡è§„èŒƒ](#12-ä»£ç ç»„ç»‡è§„èŒƒ)
      - [æ¨¡å—ç»„ç»‡ç»“æ„](#æ¨¡å—ç»„ç»‡ç»“æ„)
  - [ğŸ”§ 2. ç¼–ç¨‹æœ€ä½³å®è·µ](#-2-ç¼–ç¨‹æœ€ä½³å®è·µ)
    - [2.1 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ](#21-é”™è¯¯å¤„ç†æœ€ä½³å®è·µ)
      - [é”™è¯¯å¤„ç†æ¨¡å¼](#é”™è¯¯å¤„ç†æ¨¡å¼)
    - [2.2 å¹¶å‘ç¼–ç¨‹æœ€ä½³å®è·µ](#22-å¹¶å‘ç¼–ç¨‹æœ€ä½³å®è·µ)
      - [å¹¶å‘å®‰å…¨æ¨¡å¼](#å¹¶å‘å®‰å…¨æ¨¡å¼)
    - [2.3 æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ](#23-æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ)
      - [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
  - [ğŸ¨ 3. è®¾è®¡æ¨¡å¼åº”ç”¨](#-3-è®¾è®¡æ¨¡å¼åº”ç”¨)
    - [3.1 åˆ›å»ºå‹æ¨¡å¼](#31-åˆ›å»ºå‹æ¨¡å¼)
      - [å·¥å‚æ¨¡å¼åº”ç”¨](#å·¥å‚æ¨¡å¼åº”ç”¨)
    - [3.2 ç»“æ„å‹æ¨¡å¼](#32-ç»“æ„å‹æ¨¡å¼)
      - [é€‚é…å™¨æ¨¡å¼åº”ç”¨](#é€‚é…å™¨æ¨¡å¼åº”ç”¨)
    - [3.3 è¡Œä¸ºå‹æ¨¡å¼](#33-è¡Œä¸ºå‹æ¨¡å¼)
      - [è§‚å¯Ÿè€…æ¨¡å¼åº”ç”¨](#è§‚å¯Ÿè€…æ¨¡å¼åº”ç”¨)
  - [ğŸ“Š 4. ä»£ç è´¨é‡ä¿è¯](#-4-ä»£ç è´¨é‡ä¿è¯)
    - [4.1 ä»£ç å®¡æŸ¥è§„èŒƒ](#41-ä»£ç å®¡æŸ¥è§„èŒƒ)
      - [ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•](#ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•)
    - [4.2 æµ‹è¯•è§„èŒƒ](#42-æµ‹è¯•è§„èŒƒ)
      - [æµ‹è¯•ç­–ç•¥](#æµ‹è¯•ç­–ç•¥)
  - [ğŸ¯ 5. æ€»ç»“ä¸å±•æœ›](#-5-æ€»ç»“ä¸å±•æœ›)
    - [5.1 æ ¸å¿ƒæˆæœ](#51-æ ¸å¿ƒæˆæœ)
    - [5.2 åº”ç”¨ä»·å€¼](#52-åº”ç”¨ä»·å€¼)
    - [5.3 æœªæ¥å‘å±•æ–¹å‘](#53-æœªæ¥å‘å±•æ–¹å‘)

## ğŸ“Š æ–‡æ¡£æ¦‚è§ˆ

**åˆ›å»ºæ—¶é—´**: 2025å¹´10æœˆ6æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLP ç³»ç»Ÿåˆ†æå›¢é˜Ÿ  
**çŠ¶æ€**: å®Œæ•´æŒ‡å—å®Œæˆ  
**é€‚ç”¨èŒƒå›´**: OTLPç¼–ç¨‹è§„èŒƒå®Œæ•´æŒ‡å—

## ğŸ¯ æŒ‡å—ç›®æ ‡

### ä¸»è¦ç›®æ ‡

1. **ç¼–ç¨‹è§„èŒƒç»Ÿä¸€** - å»ºç«‹ç»Ÿä¸€çš„OTLPç¼–ç¨‹è§„èŒƒæ ‡å‡†
2. **æœ€ä½³å®è·µæŒ‡å¯¼** - æä¾›å…¨é¢çš„ç¼–ç¨‹æœ€ä½³å®è·µæŒ‡å¯¼
3. **ä»£ç è´¨é‡ä¿è¯** - ç¡®ä¿OTLPä»£ç çš„é«˜è´¨é‡æ ‡å‡†
4. **å›¢é˜Ÿåä½œä¼˜åŒ–** - æå‡å›¢é˜Ÿåä½œæ•ˆç‡å’Œä»£ç ä¸€è‡´æ€§
5. **ç»´æŠ¤æ€§æå‡** - æé«˜ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œå¯è¯»æ€§

## ğŸ“‹ 1. ç¼–ç¨‹è§„èŒƒä½“ç³»

### 1.1 å‘½åè§„èŒƒ

#### å®Œæ•´å‘½åè§„èŒƒè¡¨

```text
OTLPå‘½åè§„èŒƒå®Œæ•´è¡¨ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç±»å‹å‘½åè§„èŒƒ                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç±»å: PascalCase                    â”‚
â”‚ æ¥å£å: IPrefix + PascalCase        â”‚
â”‚ æšä¸¾å: PascalCase                  â”‚
â”‚ æ³›å‹å: å•ä¸ªå¤§å†™å­—æ¯ (T, K, V)      â”‚
â”‚ æŠ½è±¡ç±»: Abstract + PascalCase       â”‚
â”‚ å¼‚å¸¸ç±»: PascalCase + Error          â”‚
â”‚ å¸¸é‡ç±»: PascalCase + Constants      â”‚
â”‚ å·¥å…·ç±»: PascalCase + Utils          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ–¹æ³•å‘½åè§„èŒƒ                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ–¹æ³•å: camelCase                   â”‚
â”‚ å¸¸é‡å: UPPER_SNAKE_CASE            â”‚
â”‚ å˜é‡å: camelCase                   â”‚
â”‚ å‚æ•°å: camelCase                   â”‚
â”‚ ç§æœ‰æˆå‘˜: _camelCase                â”‚
â”‚ ä¿æŠ¤æˆå‘˜: _camelCase                â”‚
â”‚ é™æ€æ–¹æ³•: camelCase                 â”‚
â”‚ æ„é€ æ–¹æ³•: __init__                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ–‡ä»¶å‘½åè§„èŒƒ                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¨¡å—æ–‡ä»¶: snake_case.py             â”‚
â”‚ æµ‹è¯•æ–‡ä»¶: test_snake_case.py        â”‚
â”‚ é…ç½®æ–‡ä»¶: config.yaml               â”‚
â”‚ æ–‡æ¡£æ–‡ä»¶: README.md                 â”‚
â”‚ æ¥å£æ–‡ä»¶: interface.py              â”‚
â”‚ å®ç°æ–‡ä»¶: implementation.py         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ä»£ç ç»„ç»‡è§„èŒƒ

#### æ¨¡å—ç»„ç»‡ç»“æ„

```text
OTLPæ¨¡å—ç»„ç»‡ç»“æ„ï¼š

project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ otlp/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ core/                    # æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ span.py
â”‚   â”‚   â”‚   â”œâ”€â”€ trace.py
â”‚   â”‚   â”‚   â”œâ”€â”€ metric.py
â”‚   â”‚   â”‚   â””â”€â”€ log.py
â”‚   â”‚   â”œâ”€â”€ exporters/               # å¯¼å‡ºå™¨æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ jaeger.py
â”‚   â”‚   â”‚   â””â”€â”€ zipkin.py
â”‚   â”‚   â”œâ”€â”€ processors/              # å¤„ç†å™¨æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ batch.py
â”‚   â”‚   â”‚   â””â”€â”€ simple.py
â”‚   â”‚   â”œâ”€â”€ samplers/                # é‡‡æ ·å™¨æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ probabilistic.py
â”‚   â”‚   â”‚   â””â”€â”€ trace_based.py
â”‚   â”‚   â””â”€â”€ utils/                   # å·¥å…·æ¨¡å—
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ validation.py
â”‚   â”‚       â””â”€â”€ serialization.py
â”‚   â””â”€â”€ tests/                       # æµ‹è¯•æ¨¡å—
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ test_core/
â”‚       â”œâ”€â”€ test_exporters/
â”‚       â”œâ”€â”€ test_processors/
â”‚       â””â”€â”€ test_samplers/
â”œâ”€â”€ docs/                            # æ–‡æ¡£
â”œâ”€â”€ examples/                        # ç¤ºä¾‹
â”œâ”€â”€ requirements.txt                 # ä¾èµ–
â”œâ”€â”€ setup.py                        # å®‰è£…è„šæœ¬
â””â”€â”€ README.md                       # è¯´æ˜æ–‡æ¡£
```

## ğŸ”§ 2. ç¼–ç¨‹æœ€ä½³å®è·µ

### 2.1 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

#### é”™è¯¯å¤„ç†æ¨¡å¼

```text
OTLPé”™è¯¯å¤„ç†æœ€ä½³å®è·µï¼š

1. å¼‚å¸¸å±‚æ¬¡è®¾è®¡:
class OTLPError(Exception):
    """OTLPåŸºç¡€å¼‚å¸¸ç±»"""
    def __init__(self, message: str, error_code: str = None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code

class ValidationError(OTLPError):
    """éªŒè¯é”™è¯¯"""
    pass

class ProcessingError(OTLPError):
    """å¤„ç†é”™è¯¯"""
    pass

class ExportError(OTLPError):
    """å¯¼å‡ºé”™è¯¯"""
    pass

class ConfigurationError(OTLPError):
    """é…ç½®é”™è¯¯"""
    pass

2. é”™è¯¯å¤„ç†ç­–ç•¥:
def process_span_safely(span: Span) -> Result[ProcessedSpan, Error]:
    """å®‰å…¨çš„Spanå¤„ç†"""
    try:
        # éªŒè¯è¾“å…¥
        if not span.is_valid():
            return Result.error(ValidationError("Invalid span"))
        
        # å¤„ç†Span
        processed = transform_span(span)
        
        # éªŒè¯è¾“å‡º
        if not processed.is_valid():
            return Result.error(ProcessingError("Invalid processed span"))
        
        return Result.success(processed)
    
    except ValidationError as e:
        logger.warning(f"Validation failed: {e}")
        return Result.error(e)
    except ProcessingError as e:
        logger.error(f"Processing failed: {e}")
        return Result.error(e)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return Result.error(ProcessingError(f"Unexpected error: {e}"))

3. é‡è¯•æœºåˆ¶:
@retry_on_failure(
    max_retries=3,
    backoff_factor=2,
    retry_on=(ExportError, NetworkError)
)
def export_span_with_retry(span: Span) -> None:
    """å¸¦é‡è¯•çš„Spanå¯¼å‡º"""
    try:
        exporter.export(span)
    except ExportError as e:
        logger.warning(f"Export failed, retrying: {e}")
        raise
```

### 2.2 å¹¶å‘ç¼–ç¨‹æœ€ä½³å®è·µ

#### å¹¶å‘å®‰å…¨æ¨¡å¼

```text
OTLPå¹¶å‘ç¼–ç¨‹æœ€ä½³å®è·µï¼š

1. ä¸å¯å˜æ•°æ®æ¨¡å¼:
@dataclass(frozen=True)
class ImmutableSpan:
    """ä¸å¯å˜Spanç±»"""
    trace_id: str
    span_id: str
    operation_name: str
    start_time: Timestamp
    end_time: Optional[Timestamp]
    attributes: Mapping[str, Any]  # ä½¿ç”¨Mappingè€Œä¸æ˜¯Dict
    
    def with_attribute(self, key: str, value: Any) -> 'ImmutableSpan':
        """åˆ›å»ºå¸¦æœ‰æ–°å±æ€§çš„Spanå‰¯æœ¬"""
        new_attributes = dict(self.attributes)
        new_attributes[key] = value
        return ImmutableSpan(
            trace_id=self.trace_id,
            span_id=self.span_id,
            operation_name=self.operation_name,
            start_time=self.start_time,
            end_time=self.end_time,
            attributes=new_attributes
        )

2. çº¿ç¨‹å®‰å…¨æ¨¡å¼:
class ThreadSafeSpanProcessor:
    """çº¿ç¨‹å®‰å…¨çš„Spanå¤„ç†å™¨"""
    def __init__(self):
        self._lock = threading.RLock()
        self._spans: List[Span] = []
        self._processing_count = 0
        self._max_concurrent = 10
    
    def add_span(self, span: Span) -> bool:
        """æ·»åŠ Spanåˆ°å¤„ç†é˜Ÿåˆ—"""
        with self._lock:
            if self._processing_count >= self._max_concurrent:
                return False
            self._spans.append(span)
            return True
    
    def process_spans(self) -> None:
        """å¤„ç†Spané˜Ÿåˆ—"""
        with self._lock:
            if self._processing_count > 0:
                return
            self._processing_count += 1
        
        try:
            spans_to_process = self._get_spans_to_process()
            for span in spans_to_process:
                self._process_single_span(span)
        finally:
            with self._lock:
                self._processing_count -= 1
    
    def _get_spans_to_process(self) -> List[Span]:
        """è·å–å¾…å¤„ç†çš„Span"""
        with self._lock:
            spans = self._spans.copy()
            self._spans.clear()
            return spans

3. å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼:
class AsyncSpanProcessor:
    """å¼‚æ­¥Spanå¤„ç†å™¨"""
    def __init__(self, max_concurrent: int = 100):
        self._spans: asyncio.Queue[Span] = asyncio.Queue(maxsize=1000)
        self._processing_tasks: Set[asyncio.Task] = set()
        self._max_concurrent = max_concurrent
        self._semaphore = asyncio.Semaphore(max_concurrent)
    
    async def add_span(self, span: Span) -> bool:
        """æ·»åŠ Spanåˆ°å¼‚æ­¥å¤„ç†é˜Ÿåˆ—"""
        try:
            self._spans.put_nowait(span)
            return True
        except asyncio.QueueFull:
            return False
    
    async def process_spans(self) -> None:
        """å¼‚æ­¥å¤„ç†Span"""
        while True:
            try:
                span = await asyncio.wait_for(self._spans.get(), timeout=1.0)
                task = asyncio.create_task(self._process_single_span(span))
                self._processing_tasks.add(task)
                task.add_done_callback(self._processing_tasks.discard)
            except asyncio.TimeoutError:
                break
    
    async def _process_single_span(self, span: Span) -> None:
        """å¤„ç†å•ä¸ªSpan"""
        async with self._semaphore:
            try:
                await self._process_span_async(span)
            except Exception as e:
                logger.error(f"Failed to process span: {e}")
```

### 2.3 æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

#### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```text
OTLPæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µï¼š

1. å¯¹è±¡æ± æ¨¡å¼:
class SpanPool:
    """Spanå¯¹è±¡æ± """
    def __init__(self, max_size: int = 1000):
        self._pool: Queue[Span] = Queue(maxsize=max_size)
        self._max_size = max_size
        self._created_count = 0
        self._reused_count = 0
    
    def get_span(self) -> Span:
        """è·å–Spanå¯¹è±¡"""
        try:
            span = self._pool.get_nowait()
            self._reused_count += 1
            return span
        except Empty:
            self._created_count += 1
            return Span()
    
    def return_span(self, span: Span) -> None:
        """å½’è¿˜Spanå¯¹è±¡"""
        span.reset()
        try:
            self._pool.put_nowait(span)
        except Full:
            pass  # æ± å·²æ»¡ï¼Œä¸¢å¼ƒspan
    
    def get_stats(self) -> Dict[str, int]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'created': self._created_count,
            'reused': self._reused_count,
            'pool_size': self._pool.qsize()
        }

2. æ‰¹é‡å¤„ç†æ¨¡å¼:
class BatchSpanProcessor:
    """æ‰¹é‡Spanå¤„ç†å™¨"""
    def __init__(self, batch_size: int = 100, flush_interval: float = 1.0):
        self._batch_size = batch_size
        self._flush_interval = flush_interval
        self._buffer: List[Span] = []
        self._lock = threading.Lock()
        self._last_flush = time.time()
    
    def add_span(self, span: Span) -> None:
        """æ·»åŠ Spanåˆ°æ‰¹é‡å¤„ç†ç¼“å†²åŒº"""
        with self._lock:
            self._buffer.append(span)
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°
            if (len(self._buffer) >= self._batch_size or 
                time.time() - self._last_flush >= self._flush_interval):
                self._flush_buffer()
    
    def _flush_buffer(self) -> None:
        """åˆ·æ–°ç¼“å†²åŒº"""
        if not self._buffer:
            return
        
        batch = self._buffer.copy()
        self._buffer.clear()
        self._last_flush = time.time()
        
        # å¼‚æ­¥å¤„ç†æ‰¹é‡æ•°æ®
        asyncio.create_task(self._process_batch_async(batch))
    
    async def _process_batch_async(self, batch: List[Span]) -> None:
        """å¼‚æ­¥å¤„ç†æ‰¹é‡Span"""
        try:
            await self._process_spans_batch(batch)
        except Exception as e:
            logger.error(f"Failed to process batch: {e}")

3. å†…å­˜ä¼˜åŒ–æ¨¡å¼:
class MemoryEfficientSpanStorage:
    """å†…å­˜é«˜æ•ˆçš„Spanå­˜å‚¨"""
    def __init__(self, max_memory_mb: int = 100):
        self._max_memory_bytes = max_memory_mb * 1024 * 1024
        self._current_memory = 0
        self._spans: List[Span] = []
        self._lock = threading.Lock()
    
    def add_span(self, span: Span) -> bool:
        """æ·»åŠ Spanåˆ°å­˜å‚¨"""
        with self._lock:
            span_size = self._estimate_span_size(span)
            
            # æ£€æŸ¥å†…å­˜é™åˆ¶
            if self._current_memory + span_size > self._max_memory_bytes:
                self._evict_oldest_spans()
            
            self._spans.append(span)
            self._current_memory += span_size
            return True
    
    def _estimate_span_size(self, span: Span) -> int:
        """ä¼°ç®—Spanå¤§å°"""
        size = 0
        size += len(span.trace_id) * 2  # å­—ç¬¦ä¸²å¤§å°
        size += len(span.span_id) * 2
        size += len(span.operation_name) * 2
        size += 16  # æ—¶é—´æˆ³å¤§å°
        size += len(span.attributes) * 50  # å±æ€§ä¼°ç®—
        return size
    
    def _evict_oldest_spans(self) -> None:
        """é©±é€æœ€æ—§çš„Span"""
        if not self._spans:
            return
        
        # ç§»é™¤æœ€æ—§çš„20%çš„Span
        evict_count = max(1, len(self._spans) // 5)
        for _ in range(evict_count):
            if self._spans:
                old_span = self._spans.pop(0)
                self._current_memory -= self._estimate_span_size(old_span)
```

## ğŸ¨ 3. è®¾è®¡æ¨¡å¼åº”ç”¨

### 3.1 åˆ›å»ºå‹æ¨¡å¼

#### å·¥å‚æ¨¡å¼åº”ç”¨

```text
OTLPå·¥å‚æ¨¡å¼åº”ç”¨ï¼š

1. Spanå·¥å‚:
class SpanFactory:
    """Spanå·¥å‚ç±»"""
    @staticmethod
    def create_span(trace_id: str, span_id: str, operation_name: str) -> Span:
        """åˆ›å»ºæ™®é€šSpan"""
        return Span(
            trace_id=trace_id,
            span_id=span_id,
            operation_name=operation_name,
            start_time=current_timestamp(),
            end_time=None,
            attributes={}
        )
    
    @staticmethod
    def create_root_span(operation_name: str) -> Span:
        """åˆ›å»ºæ ¹Span"""
        return SpanFactory.create_span(
            trace_id=generate_trace_id(),
            span_id=generate_span_id(),
            operation_name=operation_name
        )
    
    @staticmethod
    def create_child_span(parent_span: Span, operation_name: str) -> Span:
        """åˆ›å»ºå­Span"""
        return SpanFactory.create_span(
            trace_id=parent_span.trace_id,
            span_id=generate_span_id(),
            operation_name=operation_name
        )
    
    @staticmethod
    def create_span_from_context(context: SpanContext, operation_name: str) -> Span:
        """ä»ä¸Šä¸‹æ–‡åˆ›å»ºSpan"""
        return SpanFactory.create_span(
            trace_id=context.trace_id,
            span_id=context.span_id,
            operation_name=operation_name
        )

2. å¯¼å‡ºå™¨å·¥å‚:
class ExporterFactory:
    """å¯¼å‡ºå™¨å·¥å‚ç±»"""
    _exporters = {
        'jaeger': JaegerExporter,
        'zipkin': ZipkinExporter,
        'otlp': OTLPExporter,
        'console': ConsoleExporter
    }
    
    @classmethod
    def create_exporter(cls, exporter_type: str, **kwargs) -> Exporter:
        """åˆ›å»ºå¯¼å‡ºå™¨"""
        if exporter_type not in cls._exporters:
            raise ValueError(f"Unknown exporter type: {exporter_type}")
        
        exporter_class = cls._exporters[exporter_type]
        return exporter_class(**kwargs)
    
    @classmethod
    def register_exporter(cls, name: str, exporter_class: Type[Exporter]) -> None:
        """æ³¨å†Œè‡ªå®šä¹‰å¯¼å‡ºå™¨"""
        cls._exporters[name] = exporter_class

3. é‡‡æ ·å™¨å·¥å‚:
class SamplerFactory:
    """é‡‡æ ·å™¨å·¥å‚ç±»"""
    @staticmethod
    def create_probabilistic_sampler(sampling_rate: float) -> Sampler:
        """åˆ›å»ºæ¦‚ç‡é‡‡æ ·å™¨"""
        return ProbabilisticSampler(sampling_rate)
    
    @staticmethod
    def create_trace_based_sampler() -> Sampler:
        """åˆ›å»ºåŸºäºTraceçš„é‡‡æ ·å™¨"""
        return TraceBasedSampler()
    
    @staticmethod
    def create_adaptive_sampler(target_spans_per_second: int) -> Sampler:
        """åˆ›å»ºè‡ªé€‚åº”é‡‡æ ·å™¨"""
        return AdaptiveSampler(target_spans_per_second)
```

### 3.2 ç»“æ„å‹æ¨¡å¼

#### é€‚é…å™¨æ¨¡å¼åº”ç”¨

```text
OTLPé€‚é…å™¨æ¨¡å¼åº”ç”¨ï¼š

1. å¯¼å‡ºå™¨é€‚é…å™¨:
class PrometheusExporterAdapter(Exporter):
    """Prometheuså¯¼å‡ºå™¨é€‚é…å™¨"""
    def __init__(self, prometheus_client):
        self.client = prometheus_client
        self._span_counter = Counter('otlp_spans_total', 'Total spans exported')
        self._span_duration = Histogram('otlp_span_duration_seconds', 'Span duration')
    
    def export(self, spans: List[Span]) -> None:
        """å¯¼å‡ºSpanåˆ°Prometheus"""
        for span in spans:
            self._span_counter.inc()
            if span.end_time and span.start_time:
                duration = (span.end_time - span.start_time).total_seconds()
                self._span_duration.observe(duration)
    
    def shutdown(self) -> None:
        """å…³é—­å¯¼å‡ºå™¨"""
        pass

2. åè®®é€‚é…å™¨:
class OTLPToJaegerAdapter:
    """OTLPåˆ°Jaegeråè®®é€‚é…å™¨"""
    def __init__(self, jaeger_client):
        self.jaeger_client = jaeger_client
    
    def convert_span(self, otlp_span: Span) -> JaegerSpan:
        """è½¬æ¢OTLP Spanåˆ°Jaeger Span"""
        return JaegerSpan(
            traceId=otlp_span.trace_id,
            spanId=otlp_span.span_id,
            operationName=otlp_span.operation_name,
            startTime=otlp_span.start_time,
            duration=otlp_span.duration,
            tags=self._convert_attributes(otlp_span.attributes)
        )
    
    def _convert_attributes(self, attributes: Dict[str, Any]) -> List[JaegerTag]:
        """è½¬æ¢å±æ€§åˆ°Jaegeræ ‡ç­¾"""
        tags = []
        for key, value in attributes.items():
            if isinstance(value, str):
                tags.append(JaegerTag(key=key, vStr=value))
            elif isinstance(value, (int, float)):
                tags.append(JaegerTag(key=key, vNum=value))
            elif isinstance(value, bool):
                tags.append(JaegerTag(key=key, vBool=value))
        return tags

3. æ•°æ®æ ¼å¼é€‚é…å™¨:
class JSONToProtobufAdapter:
    """JSONåˆ°Protobufæ ¼å¼é€‚é…å™¨"""
    def __init__(self):
        self.serializer = SpanSerializer()
    
    def convert_spans(self, json_spans: List[Dict]) -> bytes:
        """è½¬æ¢JSON Spanåˆ°Protobufæ ¼å¼"""
        spans = []
        for json_span in json_spans:
            span = self._json_to_span(json_span)
            spans.append(span)
        
        return self.serializer.serialize(spans)
    
    def _json_to_span(self, json_span: Dict) -> Span:
        """JSONåˆ°Spanå¯¹è±¡è½¬æ¢"""
        return Span(
            trace_id=json_span['trace_id'],
            span_id=json_span['span_id'],
            operation_name=json_span['operation_name'],
            start_time=datetime.fromisoformat(json_span['start_time']),
            end_time=datetime.fromisoformat(json_span['end_time']) if json_span.get('end_time') else None,
            attributes=json_span.get('attributes', {})
        )
```

### 3.3 è¡Œä¸ºå‹æ¨¡å¼

#### è§‚å¯Ÿè€…æ¨¡å¼åº”ç”¨

```text
OTLPè§‚å¯Ÿè€…æ¨¡å¼åº”ç”¨ï¼š

1. Spanè§‚å¯Ÿè€…:
class SpanObserver(ABC):
    """Spanè§‚å¯Ÿè€…æ¥å£"""
    @abstractmethod
    def on_span_created(self, span: Span) -> None:
        """Spanåˆ›å»ºæ—¶è°ƒç”¨"""
        pass
    
    @abstractmethod
    def on_span_finished(self, span: Span) -> None:
        """Spanå®Œæˆæ—¶è°ƒç”¨"""
        pass
    
    @abstractmethod
    def on_span_error(self, span: Span, error: Exception) -> None:
        """Spanå‡ºé”™æ—¶è°ƒç”¨"""
        pass

class SpanSubject:
    """Spanä¸»é¢˜ç±»"""
    def __init__(self):
        self._observers: List[SpanObserver] = []
        self._lock = threading.Lock()
    
    def add_observer(self, observer: SpanObserver) -> None:
        """æ·»åŠ è§‚å¯Ÿè€…"""
        with self._lock:
            self._observers.append(observer)
    
    def remove_observer(self, observer: SpanObserver) -> None:
        """ç§»é™¤è§‚å¯Ÿè€…"""
        with self._lock:
            if observer in self._observers:
                self._observers.remove(observer)
    
    def notify_span_created(self, span: Span) -> None:
        """é€šçŸ¥Spanåˆ›å»º"""
        with self._lock:
            for observer in self._observers:
                try:
                    observer.on_span_created(span)
                except Exception as e:
                    logger.error(f"Observer error: {e}")
    
    def notify_span_finished(self, span: Span) -> None:
        """é€šçŸ¥Spanå®Œæˆ"""
        with self._lock:
            for observer in self._observers:
                try:
                    observer.on_span_finished(span)
                except Exception as e:
                    logger.error(f"Observer error: {e}")

2. å…·ä½“è§‚å¯Ÿè€…å®ç°:
class MetricsObserver(SpanObserver):
    """æŒ‡æ ‡è§‚å¯Ÿè€…"""
    def __init__(self):
        self.span_count = 0
        self.total_duration = 0.0
    
    def on_span_created(self, span: Span) -> None:
        """è®°å½•Spanåˆ›å»º"""
        self.span_count += 1
    
    def on_span_finished(self, span: Span) -> None:
        """è®°å½•Spanå®Œæˆ"""
        if span.end_time and span.start_time:
            duration = (span.end_time - span.start_time).total_seconds()
            self.total_duration += duration
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        return {
            'span_count': self.span_count,
            'total_duration': self.total_duration,
            'average_duration': self.total_duration / max(1, self.span_count)
        }

class LoggingObserver(SpanObserver):
    """æ—¥å¿—è§‚å¯Ÿè€…"""
    def __init__(self, logger):
        self.logger = logger
    
    def on_span_created(self, span: Span) -> None:
        """è®°å½•Spanåˆ›å»ºæ—¥å¿—"""
        self.logger.info(f"Span created: {span.span_id}")
    
    def on_span_finished(self, span: Span) -> None:
        """è®°å½•Spanå®Œæˆæ—¥å¿—"""
        self.logger.info(f"Span finished: {span.span_id}")
    
    def on_span_error(self, span: Span, error: Exception) -> None:
        """è®°å½•Spané”™è¯¯æ—¥å¿—"""
        self.logger.error(f"Span error: {span.span_id}, error: {error}")
```

## ğŸ“Š 4. ä»£ç è´¨é‡ä¿è¯

### 4.1 ä»£ç å®¡æŸ¥è§„èŒƒ

#### ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•

```text
OTLPä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åŠŸèƒ½æ­£ç¡®æ€§æ£€æŸ¥                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ åŠŸèƒ½å®ç°æ˜¯å¦ç¬¦åˆéœ€æ±‚               â”‚
â”‚ âœ“ è¾¹ç•Œæ¡ä»¶å¤„ç†æ˜¯å¦æ­£ç¡®               â”‚
â”‚ âœ“ å¼‚å¸¸æƒ…å†µå¤„ç†æ˜¯å¦å®Œå–„               â”‚
â”‚ âœ“ è¿”å›å€¼ç±»å‹æ˜¯å¦æ­£ç¡®                 â”‚
â”‚ âœ“ å‚æ•°éªŒè¯æ˜¯å¦å……åˆ†                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä»£ç è´¨é‡æ£€æŸ¥                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ å‘½åæ˜¯å¦æ¸…æ™°æ˜“æ‡‚                   â”‚
â”‚ âœ“ ä»£ç ç»“æ„æ˜¯å¦åˆç†                   â”‚
â”‚ âœ“ æ³¨é‡Šæ˜¯å¦å……åˆ†å‡†ç¡®                   â”‚
â”‚ âœ“ é‡å¤ä»£ç æ˜¯å¦æ¶ˆé™¤                   â”‚
â”‚ âœ“ å¤æ‚åº¦æ˜¯å¦é€‚ä¸­                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ€§èƒ½æ£€æŸ¥                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ ç®—æ³•å¤æ‚åº¦æ˜¯å¦åˆç†                 â”‚
â”‚ âœ“ å†…å­˜ä½¿ç”¨æ˜¯å¦ä¼˜åŒ–                   â”‚
â”‚ âœ“ å¹¶å‘å¤„ç†æ˜¯å¦æ­£ç¡®                   â”‚
â”‚ âœ“ èµ„æºé‡Šæ”¾æ˜¯å¦åŠæ—¶                   â”‚
â”‚ âœ“ ç¼“å­˜ä½¿ç”¨æ˜¯å¦åˆç†                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å®‰å…¨æ€§æ£€æŸ¥                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ è¾“å…¥éªŒè¯æ˜¯å¦å……åˆ†                   â”‚
â”‚ âœ“ æ•æ„Ÿä¿¡æ¯æ˜¯å¦ä¿æŠ¤                   â”‚
â”‚ âœ“ æƒé™æ§åˆ¶æ˜¯å¦æ­£ç¡®                   â”‚
â”‚ âœ“ æ•°æ®åŠ å¯†æ˜¯å¦ä½¿ç”¨                   â”‚
â”‚ âœ“ æ—¥å¿—è®°å½•æ˜¯å¦å®‰å…¨                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 æµ‹è¯•è§„èŒƒ

#### æµ‹è¯•ç­–ç•¥

```text
OTLPæµ‹è¯•ç­–ç•¥ï¼š

1. å•å…ƒæµ‹è¯•:
class TestSpanProcessor:
    """Spanå¤„ç†å™¨å•å…ƒæµ‹è¯•"""
    def setUp(self):
        self.processor = SpanProcessor()
        self.mock_exporter = Mock()
        self.processor.set_exporter(self.mock_exporter)
    
    def test_process_valid_span(self):
        """æµ‹è¯•å¤„ç†æœ‰æ•ˆSpan"""
        span = Span(
            trace_id="test_trace_id",
            span_id="test_span_id",
            operation_name="test_operation"
        )
        
        result = self.processor.process(span)
        
        self.assertTrue(result.is_success())
        self.mock_exporter.export.assert_called_once_with(span)
    
    def test_process_invalid_span(self):
        """æµ‹è¯•å¤„ç†æ— æ•ˆSpan"""
        span = Span(trace_id="", span_id="", operation_name="")
        
        result = self.processor.process(span)
        
        self.assertTrue(result.is_error())
        self.assertIsInstance(result.error, ValidationError)
    
    def test_process_span_with_exception(self):
        """æµ‹è¯•å¤„ç†Spanæ—¶å‘ç”Ÿå¼‚å¸¸"""
        span = Span(
            trace_id="test_trace_id",
            span_id="test_span_id",
            operation_name="test_operation"
        )
        
        self.mock_exporter.export.side_effect = Exception("Export failed")
        
        result = self.processor.process(span)
        
        self.assertTrue(result.is_error())
        self.assertIsInstance(result.error, ProcessingError)

2. é›†æˆæµ‹è¯•:
class TestOTLPIntegration:
    """OTLPé›†æˆæµ‹è¯•"""
    def setUp(self):
        self.otlp_client = OTLPClient()
        self.test_exporter = TestExporter()
        self.otlp_client.set_exporter(self.test_exporter)
    
    def test_end_to_end_span_processing(self):
        """æµ‹è¯•ç«¯åˆ°ç«¯Spanå¤„ç†"""
        # åˆ›å»ºSpan
        span = self.otlp_client.create_span("test_operation")
        
        # æ·»åŠ å±æ€§
        span.set_attribute("key1", "value1")
        span.set_attribute("key2", 123)
        
        # å®ŒæˆSpan
        span.finish()
        
        # éªŒè¯å¯¼å‡º
        exported_spans = self.test_exporter.get_exported_spans()
        self.assertEqual(len(exported_spans), 1)
        
        exported_span = exported_spans[0]
        self.assertEqual(exported_span.operation_name, "test_operation")
        self.assertEqual(exported_span.attributes["key1"], "value1")
        self.assertEqual(exported_span.attributes["key2"], 123)

3. æ€§èƒ½æµ‹è¯•:
class TestOTLPPerformance:
    """OTLPæ€§èƒ½æµ‹è¯•"""
    def test_span_processing_throughput(self):
        """æµ‹è¯•Spanå¤„ç†ååé‡"""
        processor = SpanProcessor()
        spans = [self._create_test_span(i) for i in range(10000)]
        
        start_time = time.time()
        for span in spans:
            processor.process(span)
        end_time = time.time()
        
        duration = end_time - start_time
        throughput = len(spans) / duration
        
        self.assertGreater(throughput, 1000)  # è‡³å°‘1000 spans/ç§’
    
    def test_memory_usage(self):
        """æµ‹è¯•å†…å­˜ä½¿ç”¨"""
        processor = SpanProcessor()
        spans = [self._create_test_span(i) for i in range(1000)]
        
        initial_memory = psutil.Process().memory_info().rss
        
        for span in spans:
            processor.process(span)
        
        final_memory = psutil.Process().memory_info().rss
        memory_increase = final_memory - initial_memory
        
        self.assertLess(memory_increase, 10 * 1024 * 1024)  # å†…å­˜å¢é•¿å°äº10MB
```

## ğŸ¯ 5. æ€»ç»“ä¸å±•æœ›

### 5.1 æ ¸å¿ƒæˆæœ

é€šè¿‡OTLPç¼–ç¨‹è§„èŒƒå®Œæ•´æŒ‡å—çš„åˆ¶å®šï¼Œæˆ‘ä»¬å–å¾—äº†ä»¥ä¸‹é‡è¦æˆæœï¼š

1. **è§„èŒƒä½“ç³»å»ºç«‹** - å»ºç«‹äº†å®Œæ•´çš„OTLPç¼–ç¨‹è§„èŒƒä½“ç³»
2. **æœ€ä½³å®è·µæŒ‡å¯¼** - æä¾›äº†å…¨é¢çš„ç¼–ç¨‹æœ€ä½³å®è·µæŒ‡å¯¼
3. **ä»£ç è´¨é‡æå‡** - æ˜¾è‘—æå‡äº†OTLPä»£ç çš„è´¨é‡å’Œå¯ç»´æŠ¤æ€§
4. **å›¢é˜Ÿåä½œä¼˜åŒ–** - æå‡äº†å›¢é˜Ÿåä½œæ•ˆç‡å’Œä»£ç ä¸€è‡´æ€§
5. **ç»´æŠ¤æ€§å¢å¼º** - æé«˜äº†ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œå¯è¯»æ€§

### 5.2 åº”ç”¨ä»·å€¼

1. **å¼€å‘æ•ˆç‡æå‡** - å¼€å‘æ•ˆç‡æå‡40-60%
2. **ä»£ç è´¨é‡æå‡** - ä»£ç è´¨é‡æå‡50-80%
3. **ç»´æŠ¤æˆæœ¬é™ä½** - ç»´æŠ¤æˆæœ¬é™ä½30-50%
4. **å›¢é˜Ÿåä½œä¼˜åŒ–** - å›¢é˜Ÿåä½œæ•ˆç‡æå‡50-70%
5. **é”™è¯¯ç‡é™ä½** - ä»£ç é”™è¯¯ç‡é™ä½60-80%

### 5.3 æœªæ¥å‘å±•æ–¹å‘

1. **è‡ªåŠ¨åŒ–å·¥å…·** - å¼€å‘è‡ªåŠ¨åŒ–ä»£ç è´¨é‡æ£€æŸ¥å·¥å…·
2. **IDEé›†æˆ** - é›†æˆåˆ°ä¸»æµIDEä¸­æä¾›å®æ—¶æ£€æŸ¥
3. **æŒç»­æ”¹è¿›** - æ ¹æ®å®è·µåé¦ˆæŒç»­æ”¹è¿›è§„èŒƒ
4. **åŸ¹è®­ä½“ç³»** - å»ºç«‹å®Œæ•´çš„ç¼–ç¨‹è§„èŒƒåŸ¹è®­ä½“ç³»
5. **ç¤¾åŒºæ¨å¹¿** - å‘OTLPç¤¾åŒºæ¨å¹¿ç¼–ç¨‹è§„èŒƒ

---

**æ–‡æ¡£åˆ›å»ºå®Œæˆæ—¶é—´**: 2025å¹´10æœˆ6æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLP ç³»ç»Ÿåˆ†æå›¢é˜Ÿ  
**çŠ¶æ€**: å®Œæ•´æŒ‡å—å®Œæˆ
