# 时态逻辑验证

**文档版本**: 2.0.0  
**创建日期**: 2025年10月7日  
**更新日期**: 2025年10月7日  
**状态**: ✅ 已完成

---

## 📋 目录

- [时态逻辑验证](#时态逻辑验证)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [核心应用](#核心应用)
  - [时态逻辑基础](#时态逻辑基础)
    - [时态算子](#时态算子)
  - [LTL线性时态逻辑](#ltl线性时态逻辑)
    - [LTL算子实现](#ltl算子实现)
    - [LTL验证器](#ltl验证器)
  - [CTL计算树逻辑](#ctl计算树逻辑)
    - [CTL算子实现](#ctl算子实现)
    - [CTL验证器](#ctl验证器)
  - [模型检测](#模型检测)
    - [符号模型检测](#符号模型检测)
  - [OTLP属性规范](#otlp属性规范)
    - [安全性属性](#安全性属性)
    - [活性属性](#活性属性)
  - [验证工具](#验证工具)
    - [NuSMV集成](#nusmv集成)
  - [实践案例](#实践案例)
    - [案例：验证Span导出无丢失](#案例验证span导出无丢失)
  - [总结](#总结)
    - [核心价值](#核心价值)
    - [最佳实践](#最佳实践)
    - [应用场景](#应用场景)
  - [相关文档](#相关文档)

---

## 概述

时态逻辑（Temporal Logic）是一种用于描述和推理系统随时间演化行为的形式化逻辑。在OTLP智能运维中，时态逻辑用于规范和验证系统的时态性质，如安全性、活性和公平性。

### 核心应用

```text
时态逻辑在OTLP中的应用
├── 安全性属性（Safety）
│   ├── 数据不丢失
│   ├── 顺序一致性
│   ├── 资源边界
│   └── 状态不变性
├── 活性属性（Liveness）
│   ├── 最终传递
│   ├── 响应性
│   ├── 进展保证
│   └── 公平性
├── 实时属性（Real-time）
│   ├── 超时保证
│   ├── 延迟界限
│   ├── 吞吐量保证
│   └── 周期性约束
└── 复合属性
    ├── 因果关系
    ├── 依赖约束
    ├── 互斥性
    └── 优先级
```

---

## 时态逻辑基础

### 时态算子

```go
package temporal

// 时态算子
type TemporalOperator string

const (
 // LTL算子
 Next       TemporalOperator = "X"  // 下一个状态
 Always     TemporalOperator = "G"  // 全局（总是）
 Eventually TemporalOperator = "F"  // 最终
 Until      TemporalOperator = "U"  // 直到
 Release    TemporalOperator = "R"  // 释放
 
 // CTL算子
 AllPaths   TemporalOperator = "A"  // 所有路径
 ExistPath  TemporalOperator = "E"  // 存在路径
)

// 时态公式
type TemporalFormula interface {
 Evaluate(trace *Trace) bool
 String() string
}

// 原子命题
type AtomicProposition struct {
 Name      string
 Predicate func(*State) bool
}

func (ap *AtomicProposition) Evaluate(trace *Trace) bool {
 if len(trace.States) == 0 {
  return false
 }
 return ap.Predicate(trace.States[0])
}

func (ap *AtomicProposition) String() string {
 return ap.Name
}

// 否定
type Not struct {
 Formula TemporalFormula
}

func (n *Not) Evaluate(trace *Trace) bool {
 return !n.Formula.Evaluate(trace)
}

func (n *Not) String() string {
 return fmt.Sprintf("¬(%s)", n.Formula.String())
}

// 合取
type And struct {
 Left  TemporalFormula
 Right TemporalFormula
}

func (a *And) Evaluate(trace *Trace) bool {
 return a.Left.Evaluate(trace) && a.Right.Evaluate(trace)
}

func (a *And) String() string {
 return fmt.Sprintf("(%s ∧ %s)", a.Left.String(), a.Right.String())
}

// 析取
type Or struct {
 Left  TemporalFormula
 Right TemporalFormula
}

func (o *Or) Evaluate(trace *Trace) bool {
 return o.Left.Evaluate(trace) || o.Right.Evaluate(trace)
}

func (o *Or) String() string {
 return fmt.Sprintf("(%s ∨ %s)", o.Left.String(), o.Right.String())
}

// 蕴含
type Implies struct {
 Antecedent TemporalFormula
 Consequent TemporalFormula
}

func (i *Implies) Evaluate(trace *Trace) bool {
 return !i.Antecedent.Evaluate(trace) || i.Consequent.Evaluate(trace)
}

func (i *Implies) String() string {
 return fmt.Sprintf("(%s → %s)", i.Antecedent.String(), i.Consequent.String())
}
```

---

## LTL线性时态逻辑

### LTL算子实现

```go
// Next算子（X）
type Next struct {
 Formula TemporalFormula
}

func (x *Next) Evaluate(trace *Trace) bool {
 if len(trace.States) < 2 {
  return false
 }
 
 nextTrace := &Trace{
  States: trace.States[1:],
 }
 
 return x.Formula.Evaluate(nextTrace)
}

func (x *Next) String() string {
 return fmt.Sprintf("X(%s)", x.Formula.String())
}

// Always算子（G - Globally）
type Always struct {
 Formula TemporalFormula
}

func (g *Always) Evaluate(trace *Trace) bool {
 for i := 0; i < len(trace.States); i++ {
  subTrace := &Trace{
   States: trace.States[i:],
  }
  
  if !g.Formula.Evaluate(subTrace) {
   return false
  }
 }
 
 return true
}

func (g *Always) String() string {
 return fmt.Sprintf("G(%s)", g.Formula.String())
}

// Eventually算子（F - Finally）
type Eventually struct {
 Formula TemporalFormula
}

func (f *Eventually) Evaluate(trace *Trace) bool {
 for i := 0; i < len(trace.States); i++ {
  subTrace := &Trace{
   States: trace.States[i:],
  }
  
  if f.Formula.Evaluate(subTrace) {
   return true
  }
 }
 
 return false
}

func (f *Eventually) String() string {
 return fmt.Sprintf("F(%s)", f.Formula.String())
}

// Until算子（U）
type Until struct {
 Left  TemporalFormula
 Right TemporalFormula
}

func (u *Until) Evaluate(trace *Trace) bool {
 for i := 0; i < len(trace.States); i++ {
  rightTrace := &Trace{
   States: trace.States[i:],
  }
  
  if u.Right.Evaluate(rightTrace) {
   // 检查之前所有状态是否满足Left
   for j := 0; j < i; j++ {
    leftTrace := &Trace{
     States: trace.States[j:],
    }
    
    if !u.Left.Evaluate(leftTrace) {
     return false
    }
   }
   return true
  }
 }
 
 return false
}

func (u *Until) String() string {
 return fmt.Sprintf("(%s U %s)", u.Left.String(), u.Right.String())
}

// Release算子（R）
type Release struct {
 Left  TemporalFormula
 Right TemporalFormula
}

func (r *Release) Evaluate(trace *Trace) bool {
 // p R q ≡ ¬(¬p U ¬q)
 notP := &Not{Formula: r.Left}
 notQ := &Not{Formula: r.Right}
 until := &Until{Left: notP, Right: notQ}
 not := &Not{Formula: until}
 
 return not.Evaluate(trace)
}

func (r *Release) String() string {
 return fmt.Sprintf("(%s R %s)", r.Left.String(), r.Right.String())
}
```

### LTL验证器

```go
// LTL验证器
type LTLVerifier struct {
 model   *TransitionSystem
 formula TemporalFormula
}

// 转换系统
type TransitionSystem struct {
 States      map[string]*State
 InitialState string
 Transitions map[string][]Transition
 Labels      map[string][]string
}

// 状态
type State struct {
 ID         string
 Properties map[string]interface{}
}

// 转换
type Transition struct {
 From   string
 To     string
 Action string
}

// 轨迹
type Trace struct {
 States []*State
}

// 验证LTL公式
func (lv *LTLVerifier) Verify() (*VerificationResult, error) {
 result := &VerificationResult{
  Formula:  lv.formula.String(),
  Satisfied: true,
 }
 
 // 生成所有可能的轨迹
 traces := lv.generateTraces(lv.model.InitialState, 100) // 限制深度
 
 // 检查每条轨迹
 for _, trace := range traces {
  if !lv.formula.Evaluate(trace) {
   result.Satisfied = false
   result.Counterexample = trace
   break
  }
 }
 
 return result, nil
}

// 验证结果
type VerificationResult struct {
 Formula        string
 Satisfied      bool
 Counterexample *Trace
 Statistics     map[string]interface{}
}

// 生成轨迹
func (lv *LTLVerifier) generateTraces(startState string, maxDepth int) []*Trace {
 traces := []*Trace{}
 
 var dfs func(currentState string, path []*State, depth int)
 dfs = func(currentState string, path []*State, depth int) {
  if depth >= maxDepth {
   traces = append(traces, &Trace{States: append([]*State{}, path...)})
   return
  }
  
  state := lv.model.States[currentState]
  newPath := append(path, state)
  
  transitions := lv.model.Transitions[currentState]
  
  if len(transitions) == 0 {
   // 终止状态
   traces = append(traces, &Trace{States: newPath})
   return
  }
  
  for _, trans := range transitions {
   dfs(trans.To, newPath, depth+1)
  }
 }
 
 dfs(startState, []*State{}, 0)
 
 return traces
}
```

---

## CTL计算树逻辑

### CTL算子实现

```go
// CTL公式
type CTLFormula interface {
 Evaluate(model *TransitionSystem, state string) bool
 String() string
}

// EX算子（存在下一个）
type EX struct {
 Formula CTLFormula
}

func (ex *EX) Evaluate(model *TransitionSystem, state string) bool {
 transitions := model.Transitions[state]
 
 for _, trans := range transitions {
  if ex.Formula.Evaluate(model, trans.To) {
   return true
  }
 }
 
 return false
}

func (ex *EX) String() string {
 return fmt.Sprintf("EX(%s)", ex.Formula.String())
}

// AX算子（所有下一个）
type AX struct {
 Formula CTLFormula
}

func (ax *AX) Evaluate(model *TransitionSystem, state string) bool {
 transitions := model.Transitions[state]
 
 if len(transitions) == 0 {
  return false
 }
 
 for _, trans := range transitions {
  if !ax.Formula.Evaluate(model, trans.To) {
   return false
  }
 }
 
 return true
}

func (ax *AX) String() string {
 return fmt.Sprintf("AX(%s)", ax.Formula.String())
}

// EF算子（存在最终）
type EF struct {
 Formula CTLFormula
}

func (ef *EF) Evaluate(model *TransitionSystem, state string) bool {
 visited := make(map[string]bool)
 
 var dfs func(s string) bool
 dfs = func(s string) bool {
  if visited[s] {
   return false
  }
  visited[s] = true
  
  if ef.Formula.Evaluate(model, s) {
   return true
  }
  
  for _, trans := range model.Transitions[s] {
   if dfs(trans.To) {
    return true
   }
  }
  
  return false
 }
 
 return dfs(state)
}

func (ef *EF) String() string {
 return fmt.Sprintf("EF(%s)", ef.Formula.String())
}

// AG算子（所有全局）
type AG struct {
 Formula CTLFormula
}

func (ag *AG) Evaluate(model *TransitionSystem, state string) bool {
 visited := make(map[string]bool)
 
 var dfs func(s string) bool
 dfs = func(s string) bool {
  if visited[s] {
   return true
  }
  visited[s] = true
  
  if !ag.Formula.Evaluate(model, s) {
   return false
  }
  
  for _, trans := range model.Transitions[s] {
   if !dfs(trans.To) {
    return false
   }
  }
  
  return true
 }
 
 return dfs(state)
}

func (ag *AG) String() string {
 return fmt.Sprintf("AG(%s)", ag.Formula.String())
}

// EU算子（存在直到）
type EU struct {
 Left  CTLFormula
 Right CTLFormula
}

func (eu *EU) Evaluate(model *TransitionSystem, state string) bool {
 visited := make(map[string]bool)
 
 var dfs func(s string) bool
 dfs = func(s string) bool {
  if visited[s] {
   return false
  }
  visited[s] = true
  
  if eu.Right.Evaluate(model, s) {
   return true
  }
  
  if !eu.Left.Evaluate(model, s) {
   return false
  }
  
  for _, trans := range model.Transitions[s] {
   if dfs(trans.To) {
    return true
   }
  }
  
  return false
 }
 
 return dfs(state)
}

func (eu *EU) String() string {
 return fmt.Sprintf("E(%s U %s)", eu.Left.String(), eu.Right.String())
}

// AU算子（所有直到）
type AU struct {
 Left  CTLFormula
 Right CTLFormula
}

func (au *AU) Evaluate(model *TransitionSystem, state string) bool {
 // 使用不动点算法
 // AU(p, q) = q ∨ (p ∧ AX(AU(p, q)))
 
 visited := make(map[string]bool)
 
 var check func(s string) bool
 check = func(s string) bool {
  if visited[s] {
   return false
  }
  visited[s] = true
  
  if au.Right.Evaluate(model, s) {
   return true
  }
  
  if !au.Left.Evaluate(model, s) {
   return false
  }
  
  transitions := model.Transitions[s]
  if len(transitions) == 0 {
   return false
  }
  
  for _, trans := range transitions {
   if !check(trans.To) {
    return false
   }
  }
  
  return true
 }
 
 return check(state)
}

func (au *AU) String() string {
 return fmt.Sprintf("A(%s U %s)", au.Left.String(), au.Right.String())
}
```

### CTL验证器

```go
// CTL验证器
type CTLVerifier struct {
 model   *TransitionSystem
 formula CTLFormula
}

// 验证CTL公式
func (cv *CTLVerifier) Verify() (*VerificationResult, error) {
 result := &VerificationResult{
  Formula:   cv.formula.String(),
  Satisfied: true,
 }
 
 // 从初始状态开始验证
 if !cv.formula.Evaluate(cv.model, cv.model.InitialState) {
  result.Satisfied = false
  result.Counterexample = cv.findCounterexample()
 }
 
 return result, nil
}

// 查找反例
func (cv *CTLVerifier) findCounterexample() *Trace {
 // 使用BFS查找违反公式的路径
 queue := []string{cv.model.InitialState}
 parent := make(map[string]string)
 visited := make(map[string]bool)
 
 for len(queue) > 0 {
  current := queue[0]
  queue = queue[1:]
  
  if visited[current] {
   continue
  }
  visited[current] = true
  
  if !cv.formula.Evaluate(cv.model, current) {
   // 找到反例，重构路径
   return cv.reconstructPath(current, parent)
  }
  
  for _, trans := range cv.model.Transitions[current] {
   if !visited[trans.To] {
    parent[trans.To] = current
    queue = append(queue, trans.To)
   }
  }
 }
 
 return nil
}

// 重构路径
func (cv *CTLVerifier) reconstructPath(endState string, parent map[string]string) *Trace {
 path := []*State{}
 current := endState
 
 for current != "" {
  path = append([]*State{cv.model.States[current]}, path...)
  current = parent[current]
 }
 
 return &Trace{States: path}
}
```

---

## 模型检测

### 符号模型检测

```go
// 符号模型检测器
type SymbolicModelChecker struct {
 model *TransitionSystem
 bdd   *BDD // Binary Decision Diagram
}

// BDD（简化实现）
type BDD struct {
 root *BDDNode
}

type BDDNode struct {
 variable string
 low      *BDDNode
 high     *BDDNode
 isLeaf   bool
 value    bool
}

// 符号状态集
type SymbolicStateSet struct {
 bdd *BDD
}

// 计算前驱状态集
func (smc *SymbolicModelChecker) Pre(states *SymbolicStateSet) *SymbolicStateSet {
 // 计算所有能够一步转换到states中状态的状态集合
 pre := &SymbolicStateSet{}
 
 // 实现略...
 
 return pre
}

// 计算后继状态集
func (smc *SymbolicModelChecker) Post(states *SymbolicStateSet) *SymbolicStateSet {
 // 计算从states中状态一步能够到达的所有状态集合
 post := &SymbolicStateSet{}
 
 // 实现略...
 
 return post
}

// 不动点计算
func (smc *SymbolicModelChecker) LeastFixedPoint(f func(*SymbolicStateSet) *SymbolicStateSet) *SymbolicStateSet {
 current := &SymbolicStateSet{} // 空集
 
 for {
  next := f(current)
  
  if smc.Equal(current, next) {
   return current
  }
  
  current = next
 }
}

// 最大不动点
func (smc *SymbolicModelChecker) GreatestFixedPoint(f func(*SymbolicStateSet) *SymbolicStateSet) *SymbolicStateSet {
 current := smc.AllStates() // 全集
 
 for {
  next := f(current)
  
  if smc.Equal(current, next) {
   return current
  }
  
  current = next
 }
}

// 验证EF公式（符号方法）
func (smc *SymbolicModelChecker) VerifyEF(p *SymbolicStateSet) *SymbolicStateSet {
 // EF(p) = μZ. p ∨ EX(Z)
 return smc.LeastFixedPoint(func(Z *SymbolicStateSet) *SymbolicStateSet {
  exZ := smc.Pre(Z)
  return smc.Union(p, exZ)
 })
}

// 验证AG公式（符号方法）
func (smc *SymbolicModelChecker) VerifyAG(p *SymbolicStateSet) *SymbolicStateSet {
 // AG(p) = νZ. p ∧ AX(Z)
 return smc.GreatestFixedPoint(func(Z *SymbolicStateSet) *SymbolicStateSet {
  axZ := smc.AllStates() // 简化
  // 实际实现需要计算AX(Z)
  return smc.Intersection(p, axZ)
 })
}
```

---

## OTLP属性规范

### 安全性属性

```go
// OTLP安全性属性
type OTLPSafetyProperties struct {
 verifier *LTLVerifier
}

// 属性1：Span不丢失
// G(SpanCreated → F(SpanExported))
func (osp *OTLPSafetyProperties) NoSpanLoss() TemporalFormula {
 spanCreated := &AtomicProposition{
  Name: "SpanCreated",
  Predicate: func(s *State) bool {
   return s.Properties["span_created"].(bool)
  },
 }
 
 spanExported := &AtomicProposition{
  Name: "SpanExported",
  Predicate: func(s *State) bool {
   return s.Properties["span_exported"].(bool)
  },
 }
 
 eventuallyExported := &Eventually{Formula: spanExported}
 implies := &Implies{
  Antecedent: spanCreated,
  Consequent: eventuallyExported,
 }
 
 return &Always{Formula: implies}
}

// 属性2：顺序一致性
// G(Span1Before Span2 → ¬(Span2Exported ∧ ¬Span1Exported))
func (osp *OTLPSafetyProperties) OrderConsistency() TemporalFormula {
 span1BeforeSpan2 := &AtomicProposition{
  Name: "Span1BeforeSpan2",
  Predicate: func(s *State) bool {
   return s.Properties["span1_timestamp"].(int64) < s.Properties["span2_timestamp"].(int64)
  },
 }
 
 span2Exported := &AtomicProposition{
  Name: "Span2Exported",
  Predicate: func(s *State) bool {
   return s.Properties["span2_exported"].(bool)
  },
 }
 
 span1NotExported := &Not{
  Formula: &AtomicProposition{
   Name: "Span1Exported",
   Predicate: func(s *State) bool {
    return s.Properties["span1_exported"].(bool)
   },
  },
 }
 
 violation := &And{Left: span2Exported, Right: span1NotExported}
 notViolation := &Not{Formula: violation}
 
 implies := &Implies{
  Antecedent: span1BeforeSpan2,
  Consequent: notViolation,
 }
 
 return &Always{Formula: implies}
}

// 属性3：资源边界
// G(QueueSize ≤ MaxQueueSize)
func (osp *OTLPSafetyProperties) ResourceBounds() TemporalFormula {
 queueBounded := &AtomicProposition{
  Name: "QueueBounded",
  Predicate: func(s *State) bool {
   queueSize := s.Properties["queue_size"].(int)
   maxSize := s.Properties["max_queue_size"].(int)
   return queueSize <= maxSize
  },
 }
 
 return &Always{Formula: queueBounded}
}

// 属性4：Trace完整性
// G(TraceComplete → AllSpansExported)
func (osp *OTLPSafetyProperties) TraceCompleteness() TemporalFormula {
 traceComplete := &AtomicProposition{
  Name: "TraceComplete",
  Predicate: func(s *State) bool {
   return s.Properties["trace_complete"].(bool)
  },
 }
 
 allSpansExported := &AtomicProposition{
  Name: "AllSpansExported",
  Predicate: func(s *State) bool {
   return s.Properties["all_spans_exported"].(bool)
  },
 }
 
 implies := &Implies{
  Antecedent: traceComplete,
  Consequent: allSpansExported,
 }
 
 return &Always{Formula: implies}
}
```

### 活性属性

```go
// OTLP活性属性
type OTLPLivenessProperties struct {
 verifier *LTLVerifier
}

// 属性1：最终传递
// G(SpanEnqueued → F(SpanExported))
func (olp *OTLPLivenessProperties) EventualDelivery() TemporalFormula {
 spanEnqueued := &AtomicProposition{
  Name: "SpanEnqueued",
  Predicate: func(s *State) bool {
   return s.Properties["span_enqueued"].(bool)
  },
 }
 
 spanExported := &AtomicProposition{
  Name: "SpanExported",
  Predicate: func(s *State) bool {
   return s.Properties["span_exported"].(bool)
  },
 }
 
 eventuallyExported := &Eventually{Formula: spanExported}
 implies := &Implies{
  Antecedent: spanEnqueued,
  Consequent: eventuallyExported,
 }
 
 return &Always{Formula: implies}
}

// 属性2：响应性
// G(Request → F(Response))
func (olp *OTLPLivenessProperties) Responsiveness() TemporalFormula {
 request := &AtomicProposition{
  Name: "Request",
  Predicate: func(s *State) bool {
   return s.Properties["request_received"].(bool)
  },
 }
 
 response := &AtomicProposition{
  Name: "Response",
  Predicate: func(s *State) bool {
   return s.Properties["response_sent"].(bool)
  },
 }
 
 eventuallyResponse := &Eventually{Formula: response}
 implies := &Implies{
  Antecedent: request,
  Consequent: eventuallyResponse,
 }
 
 return &Always{Formula: implies}
}

// 属性3：公平性
// GF(ProcessorAvailable) → GF(SpanProcessed)
func (olp *OTLPLivenessProperties) Fairness() TemporalFormula {
 processorAvailable := &AtomicProposition{
  Name: "ProcessorAvailable",
  Predicate: func(s *State) bool {
   return s.Properties["processor_available"].(bool)
  },
 }
 
 spanProcessed := &AtomicProposition{
  Name: "SpanProcessed",
  Predicate: func(s *State) bool {
   return s.Properties["span_processed"].(bool)
  },
 }
 
 infinitelyOftenAvailable := &Always{
  Formula: &Eventually{Formula: processorAvailable},
 }
 
 infinitelyOftenProcessed := &Always{
  Formula: &Eventually{Formula: spanProcessed},
 }
 
 return &Implies{
  Antecedent: infinitelyOftenAvailable,
  Consequent: infinitelyOftenProcessed,
 }
}

// 属性4：无饥饿
// G(SpanWaiting → F(SpanProcessed))
func (olp *OTLPLivenessProperties) NoStarvation() TemporalFormula {
 spanWaiting := &AtomicProposition{
  Name: "SpanWaiting",
  Predicate: func(s *State) bool {
   return s.Properties["span_waiting"].(bool)
  },
 }
 
 spanProcessed := &AtomicProposition{
  Name: "SpanProcessed",
  Predicate: func(s *State) bool {
   return s.Properties["span_processed"].(bool)
  },
 }
 
 eventuallyProcessed := &Eventually{Formula: spanProcessed}
 implies := &Implies{
  Antecedent: spanWaiting,
  Consequent: eventuallyProcessed,
 }
 
 return &Always{Formula: implies}
}
```

---

## 验证工具

### NuSMV集成

```go
// NuSMV模型检查器集成
type NuSMVChecker struct {
 modelFile string
 nusmvPath string
}

// 生成NuSMV模型
func (nc *NuSMVChecker) GenerateModel(system *TransitionSystem, properties []TemporalFormula) error {
 var sb strings.Builder
 
 // 模块定义
 sb.WriteString("MODULE main\n")
 sb.WriteString("VAR\n")
 
 // 状态变量
 for stateID := range system.States {
  sb.WriteString(fmt.Sprintf("  state_%s : boolean;\n", stateID))
 }
 
 // 定义转换
 sb.WriteString("\nASSIGN\n")
 sb.WriteString("  init(state_" + system.InitialState + ") := TRUE;\n")
 
 for stateID := range system.States {
  if stateID != system.InitialState {
   sb.WriteString(fmt.Sprintf("  init(state_%s) := FALSE;\n", stateID))
  }
 }
 
 // 转换关系
 for from, transitions := range system.Transitions {
  sb.WriteString(fmt.Sprintf("\n  next(state_%s) := case\n", from))
  
  for _, trans := range transitions {
   sb.WriteString(fmt.Sprintf("    state_%s : {TRUE, FALSE};\n", from))
  }
  
  sb.WriteString("    TRUE : FALSE;\n")
  sb.WriteString("  esac;\n")
 }
 
 // 规范
 sb.WriteString("\n-- Specifications\n")
 for i, prop := range properties {
  sb.WriteString(fmt.Sprintf("LTLSPEC NAME spec_%d := %s\n", i, nc.convertToNuSMV(prop)))
 }
 
 // 写入文件
 return os.WriteFile(nc.modelFile, []byte(sb.String()), 0644)
}

// 转换为NuSMV语法
func (nc *NuSMVChecker) convertToNuSMV(formula TemporalFormula) string {
 switch f := formula.(type) {
 case *Always:
  return fmt.Sprintf("G(%s)", nc.convertToNuSMV(f.Formula))
 case *Eventually:
  return fmt.Sprintf("F(%s)", nc.convertToNuSMV(f.Formula))
 case *Next:
  return fmt.Sprintf("X(%s)", nc.convertToNuSMV(f.Formula))
 case *Until:
  return fmt.Sprintf("(%s U %s)", nc.convertToNuSMV(f.Left), nc.convertToNuSMV(f.Right))
 case *And:
  return fmt.Sprintf("(%s & %s)", nc.convertToNuSMV(f.Left), nc.convertToNuSMV(f.Right))
 case *Or:
  return fmt.Sprintf("(%s | %s)", nc.convertToNuSMV(f.Left), nc.convertToNuSMV(f.Right))
 case *Not:
  return fmt.Sprintf("!(%s)", nc.convertToNuSMV(f.Formula))
 case *Implies:
  return fmt.Sprintf("(%s -> %s)", nc.convertToNuSMV(f.Antecedent), nc.convertToNuSMV(f.Consequent))
 case *AtomicProposition:
  return f.Name
 default:
  return "TRUE"
 }
}

// 运行NuSMV
func (nc *NuSMVChecker) Run() (*NuSMVResult, error) {
 cmd := exec.Command(nc.nusmvPath, nc.modelFile)
 output, err := cmd.CombinedOutput()
 
 if err != nil {
  return nil, err
 }
 
 return nc.parseOutput(string(output)), nil
}

// NuSMV结果
type NuSMVResult struct {
 Specifications []SpecResult
}

type SpecResult struct {
 Name      string
 Satisfied bool
 Counterexample *Trace
}

// 解析输出
func (nc *NuSMVChecker) parseOutput(output string) *NuSMVResult {
 result := &NuSMVResult{
  Specifications: []SpecResult{},
 }
 
 // 解析输出
 lines := strings.Split(output, "\n")
 
 for _, line := range lines {
  if strings.Contains(line, "specification") {
   spec := SpecResult{}
   
   if strings.Contains(line, "is true") {
    spec.Satisfied = true
   } else if strings.Contains(line, "is false") {
    spec.Satisfied = false
   }
   
   result.Specifications = append(result.Specifications, spec)
  }
 }
 
 return result
}
```

---

## 实践案例

### 案例：验证Span导出无丢失

```go
func ExampleVerifyNoSpanLoss() {
 // 构建转换系统
 system := &TransitionSystem{
  States: map[string]*State{
   "s0": {ID: "s0", Properties: map[string]interface{}{
    "span_created": false,
    "span_exported": false,
   }},
   "s1": {ID: "s1", Properties: map[string]interface{}{
    "span_created": true,
    "span_exported": false,
   }},
   "s2": {ID: "s2", Properties: map[string]interface{}{
    "span_created": true,
    "span_exported": true,
   }},
  },
  InitialState: "s0",
  Transitions: map[string][]Transition{
   "s0": {{From: "s0", To: "s1", Action: "create_span"}},
   "s1": {{From: "s1", To: "s2", Action: "export_span"}},
  },
 }
 
 // 创建属性
 safetyProps := &OTLPSafetyProperties{}
 noLossProperty := safetyProps.NoSpanLoss()
 
 // 创建验证器
 verifier := &LTLVerifier{
  model:   system,
  formula: noLossProperty,
 }
 
 // 验证
 result, err := verifier.Verify()
 if err != nil {
  log.Fatal(err)
 }
 
 fmt.Printf("属性: %s\n", result.Formula)
 fmt.Printf("满足: %v\n", result.Satisfied)
 
 if !result.Satisfied {
  fmt.Println("反例:")
  for i, state := range result.Counterexample.States {
   fmt.Printf("  状态%d: %v\n", i, state.Properties)
  }
 }
 
 // 输出:
 // 属性: G(SpanCreated → F(SpanExported))
 // 满足: true
}
```

---

## 总结

### 核心价值

1. **形式化规范**
   - 精确描述系统属性
   - 消除歧义
   - 可验证性

2. **自动化验证**
   - 模型检测
   - 反例生成
   - 全面覆盖

3. **早期发现问题**
   - 设计阶段验证
   - 避免实现错误
   - 降低成本

4. **文档化**
   - 属性目录
   - 验证报告
   - 可追溯性

### 最佳实践

- 🎯 **分层规范**: 从高层到底层逐步细化
- 📝 **模式库**: 建立常用属性模式库
- 🔍 **增量验证**: 逐步添加属性验证
- 🧪 **反例驱动**: 利用反例改进设计
- 🔄 **持续验证**: 集成到CI/CD流程

### 应用场景

- 协议正确性验证
- 并发算法验证
- 安全性分析
- 活性检查
- 性能属性验证

---

## 相关文档

- [23_TLA+集成.md](23_TLA+集成.md) - TLA+形式化方法
- [24_Petri网集成.md](24_Petri网集成.md) - Petri网建模
- [17_协议形式化规范.md](17_协议形式化规范.md) - 协议规范基础

---

*最后更新: 2025年10月7日*-
