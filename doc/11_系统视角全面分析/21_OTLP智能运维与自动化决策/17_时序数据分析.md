# 时序数据分析

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第六部分 - 多维度数据分析  

---

## 目录

- [时序数据分析](#时序数据分析)
  - [目录](#目录)
  - [概述](#概述)
  - [6.1.1 时序数据存储](#611-时序数据存储)
    - [时序数据库选型](#时序数据库选型)
    - [数据模型设计](#数据模型设计)
  - [6.1.2 时序分析算法](#612-时序分析算法)
    - [趋势分析](#趋势分析)
    - [周期性检测](#周期性检测)
    - [变点检测](#变点检测)
  - [6.1.3 时序预测](#613-时序预测)
    - [Prophet预测](#prophet预测)
    - [LSTM预测](#lstm预测)
  - [6.1.4 时序异常检测](#614-时序异常检测)
    - [STL分解](#stl分解)
    - [自编码器](#自编码器)
  - [总结](#总结)

---

## 概述

本文档介绍OTLP时序数据的存储、分析、预测和异常检测技术。

---

## 6.1.1 时序数据存储

### 时序数据库选型

**主流时序数据库对比**：

```go
// 时序数据库接口
type TimeSeriesDB interface {
    Write(points []DataPoint) error
    Query(query string, start, end time.Time) ([]DataPoint, error)
    Aggregate(metric string, window time.Duration, fn AggFunc) ([]DataPoint, error)
}

// InfluxDB实现
type InfluxDBClient struct {
    client influxdb2.Client
    org    string
    bucket string
}

func (idb *InfluxDBClient) Write(points []DataPoint) error {
    writeAPI := idb.client.WriteAPIBlocking(idb.org, idb.bucket)
    
    for _, point := range points {
        p := influxdb2.NewPoint(
            point.Measurement,
            point.Tags,
            map[string]interface{}{
                "value": point.Value,
            },
            point.Timestamp,
        )
        
        err := writeAPI.WritePoint(context.Background(), p)
        if err != nil {
            return err
        }
    }
    
    return nil
}

func (idb *InfluxDBClient) Query(
    query string,
    start, end time.Time,
) ([]DataPoint, error) {
    queryAPI := idb.client.QueryAPI(idb.org)
    
    fluxQuery := fmt.Sprintf(`
        from(bucket: "%s")
        |> range(start: %s, stop: %s)
        |> filter(fn: (r) => %s)
    `, idb.bucket, start.Format(time.RFC3339), end.Format(time.RFC3339), query)
    
    result, err := queryAPI.Query(context.Background(), fluxQuery)
    if err != nil {
        return nil, err
    }
    
    points := []DataPoint{}
    for result.Next() {
        points = append(points, DataPoint{
            Timestamp: result.Record().Time(),
            Value:     result.Record().Value().(float64),
            Tags:      result.Record().Values(),
        })
    }
    
    return points, nil
}

// Prometheus实现
type PrometheusClient struct {
    api v1.API
}

func (pc *PrometheusClient) Query(
    query string,
    start, end time.Time,
) ([]DataPoint, error) {
    r := v1.Range{
        Start: start,
        End:   end,
        Step:  time.Minute,
    }
    
    result, warnings, err := pc.api.QueryRange(
        context.Background(),
        query,
        r,
    )
    if err != nil {
        return nil, err
    }
    
    if len(warnings) > 0 {
        log.Printf("Warnings: %v", warnings)
    }
    
    points := []DataPoint{}
    matrix := result.(model.Matrix)
    
    for _, sample := range matrix {
        for _, value := range sample.Values {
            points = append(points, DataPoint{
                Timestamp: value.Timestamp.Time(),
                Value:     float64(value.Value),
            })
        }
    }
    
    return points, nil
}
```

### 数据模型设计

**时序数据建模**：

```go
// 时序数据点
type DataPoint struct {
    Measurement string                 // 指标名称
    Tags        map[string]string      // 标签（维度）
    Fields      map[string]interface{} // 字段（值）
    Timestamp   time.Time              // 时间戳
    Value       float64                // 主值
}

// 时间序列
type TimeSeries struct {
    Metric     string
    Labels     map[string]string
    Points     []DataPoint
    Resolution time.Duration
}

// 时序数据建模器
type TimeSeriesModeler struct {
    resolution time.Duration
}

func (tsm *TimeSeriesModeler) CreateTimeSeries(
    metric string,
    labels map[string]string,
    start, end time.Time,
) *TimeSeries {
    ts := &TimeSeries{
        Metric:     metric,
        Labels:     labels,
        Resolution: tsm.resolution,
        Points:     []DataPoint{},
    }
    
    // 生成时间点
    for t := start; t.Before(end); t = t.Add(tsm.resolution) {
        ts.Points = append(ts.Points, DataPoint{
            Timestamp: t,
            Value:     0, // 初始值
        })
    }
    
    return ts
}

// 数据对齐
func (tsm *TimeSeriesModeler) Align(series []*TimeSeries) []*TimeSeries {
    if len(series) == 0 {
        return series
    }
    
    // 找到公共时间范围
    minTime := series[0].Points[0].Timestamp
    maxTime := series[0].Points[len(series[0].Points)-1].Timestamp
    
    for _, ts := range series[1:] {
        if ts.Points[0].Timestamp.After(minTime) {
            minTime = ts.Points[0].Timestamp
        }
        if ts.Points[len(ts.Points)-1].Timestamp.Before(maxTime) {
            maxTime = ts.Points[len(ts.Points)-1].Timestamp
        }
    }
    
    // 对齐所有序列
    aligned := []*TimeSeries{}
    for _, ts := range series {
        alignedTS := tsm.alignSeries(ts, minTime, maxTime)
        aligned = append(aligned, alignedTS)
    }
    
    return aligned
}

func (tsm *TimeSeriesModeler) alignSeries(
    ts *TimeSeries,
    start, end time.Time,
) *TimeSeries {
    aligned := &TimeSeries{
        Metric:     ts.Metric,
        Labels:     ts.Labels,
        Resolution: ts.Resolution,
        Points:     []DataPoint{},
    }
    
    for _, point := range ts.Points {
        if !point.Timestamp.Before(start) && !point.Timestamp.After(end) {
            aligned.Points = append(aligned.Points, point)
        }
    }
    
    return aligned
}
```

---

## 6.1.2 时序分析算法

### 趋势分析

**线性回归趋势**：

```go
// 趋势分析器
type TrendAnalyzer struct{}

func (ta *TrendAnalyzer) LinearTrend(ts *TimeSeries) TrendResult {
    n := len(ts.Points)
    if n < 2 {
        return TrendResult{}
    }
    
    // 准备数据
    x := make([]float64, n)
    y := make([]float64, n)
    
    for i, point := range ts.Points {
        x[i] = float64(i)
        y[i] = point.Value
    }
    
    // 计算线性回归
    slope, intercept := ta.linearRegression(x, y)
    
    // 计算R²
    r2 := ta.calculateR2(x, y, slope, intercept)
    
    return TrendResult{
        Slope:     slope,
        Intercept: intercept,
        R2:        r2,
        Direction: ta.getTrendDirection(slope),
    }
}

func (ta *TrendAnalyzer) linearRegression(x, y []float64) (float64, float64) {
    n := float64(len(x))
    
    // 计算均值
    meanX := ta.mean(x)
    meanY := ta.mean(y)
    
    // 计算斜率
    var numerator, denominator float64
    for i := range x {
        numerator += (x[i] - meanX) * (y[i] - meanY)
        denominator += (x[i] - meanX) * (x[i] - meanX)
    }
    
    slope := numerator / denominator
    intercept := meanY - slope*meanX
    
    return slope, intercept
}

func (ta *TrendAnalyzer) calculateR2(
    x, y []float64,
    slope, intercept float64,
) float64 {
    meanY := ta.mean(y)
    
    var ssRes, ssTot float64
    for i := range x {
        predicted := slope*x[i] + intercept
        ssRes += (y[i] - predicted) * (y[i] - predicted)
        ssTot += (y[i] - meanY) * (y[i] - meanY)
    }
    
    return 1.0 - (ssRes / ssTot)
}

// 移动平均趋势
type MovingAverageTrend struct {
    window int
}

func (mat *MovingAverageTrend) Calculate(ts *TimeSeries) []float64 {
    n := len(ts.Points)
    result := make([]float64, n)
    
    for i := 0; i < n; i++ {
        start := max(0, i-mat.window+1)
        end := i + 1
        
        sum := 0.0
        for j := start; j < end; j++ {
            sum += ts.Points[j].Value
        }
        
        result[i] = sum / float64(end-start)
    }
    
    return result
}
```

### 周期性检测

**自相关分析**：

```go
// 周期性检测器
type PeriodicityDetector struct{}

func (pd *PeriodicityDetector) DetectPeriod(ts *TimeSeries) PeriodResult {
    // 1. 计算自相关函数
    acf := pd.autocorrelation(ts)
    
    // 2. 找到峰值
    peaks := pd.findPeaks(acf)
    
    // 3. 确定周期
    if len(peaks) == 0 {
        return PeriodResult{HasPeriod: false}
    }
    
    // 第一个显著峰值对应的lag就是周期
    period := peaks[0].Lag
    confidence := peaks[0].Value
    
    return PeriodResult{
        HasPeriod:  true,
        Period:     period,
        Confidence: confidence,
    }
}

func (pd *PeriodicityDetector) autocorrelation(ts *TimeSeries) []float64 {
    n := len(ts.Points)
    values := make([]float64, n)
    for i, p := range ts.Points {
        values[i] = p.Value
    }
    
    mean := pd.mean(values)
    
    // 计算ACF
    maxLag := n / 2
    acf := make([]float64, maxLag)
    
    for lag := 0; lag < maxLag; lag++ {
        var numerator, denominator float64
        
        for i := 0; i < n-lag; i++ {
            numerator += (values[i] - mean) * (values[i+lag] - mean)
        }
        
        for i := 0; i < n; i++ {
            denominator += (values[i] - mean) * (values[i] - mean)
        }
        
        acf[lag] = numerator / denominator
    }
    
    return acf
}

func (pd *PeriodicityDetector) findPeaks(acf []float64) []Peak {
    peaks := []Peak{}
    
    for i := 1; i < len(acf)-1; i++ {
        // 局部最大值
        if acf[i] > acf[i-1] && acf[i] > acf[i+1] {
            // 显著性检验（大于阈值）
            if acf[i] > 0.3 {
                peaks = append(peaks, Peak{
                    Lag:   i,
                    Value: acf[i],
                })
            }
        }
    }
    
    // 按值排序
    sort.Slice(peaks, func(i, j int) bool {
        return peaks[i].Value > peaks[j].Value
    })
    
    return peaks
}

// FFT周期检测
type FFTPeriodicityDetector struct{}

func (fpd *FFTPeriodicityDetector) DetectPeriod(ts *TimeSeries) PeriodResult {
    n := len(ts.Points)
    values := make([]complex128, n)
    
    for i, p := range ts.Points {
        values[i] = complex(p.Value, 0)
    }
    
    // FFT
    fft := fpd.fft(values)
    
    // 计算功率谱
    powerSpectrum := make([]float64, n/2)
    for i := 0; i < n/2; i++ {
        powerSpectrum[i] = real(fft[i]*complex(real(fft[i]), -imag(fft[i])))
    }
    
    // 找到最大功率对应的频率
    maxPower := 0.0
    maxIdx := 0
    for i := 1; i < len(powerSpectrum); i++ {
        if powerSpectrum[i] > maxPower {
            maxPower = powerSpectrum[i]
            maxIdx = i
        }
    }
    
    // 周期 = 采样点数 / 频率索引
    period := n / maxIdx
    
    return PeriodResult{
        HasPeriod:  maxPower > 0,
        Period:     period,
        Confidence: maxPower,
    }
}
```

### 变点检测

**CUSUM算法**：

```go
// 变点检测器
type ChangePointDetector struct {
    threshold float64
    drift     float64
}

func (cpd *ChangePointDetector) Detect(ts *TimeSeries) []ChangePoint {
    n := len(ts.Points)
    values := make([]float64, n)
    for i, p := range ts.Points {
        values[i] = p.Value
    }
    
    // 计算均值和标准差
    mean := cpd.mean(values)
    stddev := cpd.stddev(values, mean)
    
    // CUSUM
    var cumSum float64
    changePoints := []ChangePoint{}
    
    for i := 0; i < n; i++ {
        // 标准化
        normalized := (values[i] - mean) / stddev
        
        // 累积和
        cumSum += normalized - cpd.drift
        cumSum = math.Max(0, cumSum)
        
        // 检测变点
        if cumSum > cpd.threshold {
            changePoints = append(changePoints, ChangePoint{
                Index:     i,
                Timestamp: ts.Points[i].Timestamp,
                Value:     values[i],
                Score:     cumSum,
            })
            
            // 重置
            cumSum = 0
        }
    }
    
    return changePoints
}

// PELT算法（Pruned Exact Linear Time）
type PELTDetector struct {
    penalty float64
}

func (pd *PELTDetector) Detect(ts *TimeSeries) []ChangePoint {
    n := len(ts.Points)
    values := make([]float64, n)
    for i, p := range ts.Points {
        values[i] = p.Value
    }
    
    // 动态规划
    F := make([]float64, n+1)
    cp := make([]int, n+1)
    
    for t := 1; t <= n; t++ {
        minCost := math.Inf(1)
        bestCP := 0
        
        for s := 0; s < t; s++ {
            cost := F[s] + pd.segmentCost(values, s, t) + pd.penalty
            if cost < minCost {
                minCost = cost
                bestCP = s
            }
        }
        
        F[t] = minCost
        cp[t] = bestCP
    }
    
    // 回溯变点
    changePoints := []ChangePoint{}
    t := n
    for t > 0 {
        if cp[t] > 0 {
            changePoints = append(changePoints, ChangePoint{
                Index:     cp[t],
                Timestamp: ts.Points[cp[t]].Timestamp,
            })
        }
        t = cp[t]
    }
    
    return changePoints
}

func (pd *PELTDetector) segmentCost(
    values []float64,
    start, end int,
) float64 {
    if start >= end {
        return 0
    }
    
    segment := values[start:end]
    mean := pd.mean(segment)
    
    var cost float64
    for _, v := range segment {
        cost += (v - mean) * (v - mean)
    }
    
    return cost
}
```

---

## 6.1.3 时序预测

### Prophet预测

**Facebook Prophet实现**：

```go
// Prophet预测器（简化版）
type ProphetPredictor struct {
    trend      TrendComponent
    seasonality SeasonalityComponent
    holidays   HolidayComponent
}

type TrendComponent struct {
    changepoints []time.Time
    growth       string // "linear" or "logistic"
}

type SeasonalityComponent struct {
    yearly bool
    weekly bool
    daily  bool
}

func (pp *ProphetPredictor) Fit(ts *TimeSeries) error {
    // 1. 拟合趋势
    pp.fitTrend(ts)
    
    // 2. 拟合季节性
    pp.fitSeasonality(ts)
    
    return nil
}

func (pp *ProphetPredictor) Predict(periods int) []DataPoint {
    predictions := make([]DataPoint, periods)
    
    lastTime := time.Now()
    
    for i := 0; i < periods; i++ {
        t := lastTime.Add(time.Duration(i) * time.Hour)
        
        // 趋势 + 季节性
        trend := pp.predictTrend(t)
        seasonality := pp.predictSeasonality(t)
        
        predictions[i] = DataPoint{
            Timestamp: t,
            Value:     trend + seasonality,
        }
    }
    
    return predictions
}

func (pp *ProphetPredictor) fitTrend(ts *TimeSeries) {
    // 线性趋势或逻辑增长
    // 简化实现：使用线性回归
}

func (pp *ProphetPredictor) fitSeasonality(ts *TimeSeries) {
    // 傅里叶级数拟合季节性
    // y_seasonal = Σ(a_n * sin(2πnt/P) + b_n * cos(2πnt/P))
}
```

### LSTM预测

**长短期记忆网络**：

```go
// LSTM预测器（概念实现）
type LSTMPredictor struct {
    inputSize  int
    hiddenSize int
    outputSize int
    
    // 权重矩阵
    Wf, Wi, Wc, Wo *Matrix
    bf, bi, bc, bo *Vector
    
    // 状态
    h, c *Vector
}

func (lstm *LSTMPredictor) Forward(x []float64) []float64 {
    // 1. 遗忘门
    ft := lstm.sigmoid(lstm.Wf.Mul(x).Add(lstm.bf))
    
    // 2. 输入门
    it := lstm.sigmoid(lstm.Wi.Mul(x).Add(lstm.bi))
    
    // 3. 候选值
    ct_tilde := lstm.tanh(lstm.Wc.Mul(x).Add(lstm.bc))
    
    // 4. 更新细胞状态
    lstm.c = ft.Mul(lstm.c).Add(it.Mul(ct_tilde))
    
    // 5. 输出门
    ot := lstm.sigmoid(lstm.Wo.Mul(x).Add(lstm.bo))
    
    // 6. 隐藏状态
    lstm.h = ot.Mul(lstm.tanh(lstm.c))
    
    return lstm.h.Data
}

func (lstm *LSTMPredictor) Predict(
    ts *TimeSeries,
    steps int,
) []DataPoint {
    // 准备输入序列
    sequence := lstm.prepareSequence(ts)
    
    predictions := []DataPoint{}
    
    for i := 0; i < steps; i++ {
        // 前向传播
        output := lstm.Forward(sequence)
        
        // 预测值
        predicted := output[0]
        
        predictions = append(predictions, DataPoint{
            Timestamp: ts.Points[len(ts.Points)-1].Timestamp.Add(
                time.Duration(i+1) * ts.Resolution,
            ),
            Value: predicted,
        })
        
        // 更新序列（滑动窗口）
        sequence = append(sequence[1:], predicted)
    }
    
    return predictions
}
```

---

## 6.1.4 时序异常检测

### STL分解

**Seasonal-Trend decomposition using Loess**：

```go
// STL分解器
type STLDecomposer struct {
    period int
}

func (stl *STLDecomposer) Decompose(ts *TimeSeries) STLResult {
    n := len(ts.Points)
    values := make([]float64, n)
    for i, p := range ts.Points {
        values[i] = p.Value
    }
    
    // 初始化
    trend := make([]float64, n)
    seasonal := make([]float64, n)
    residual := make([]float64, n)
    
    // 迭代分解
    for iter := 0; iter < 10; iter++ {
        // 1. 去趋势
        detrended := make([]float64, n)
        for i := range values {
            detrended[i] = values[i] - trend[i]
        }
        
        // 2. 提取季节性
        seasonal = stl.extractSeasonality(detrended)
        
        // 3. 去季节性
        deseasoned := make([]float64, n)
        for i := range values {
            deseasoned[i] = values[i] - seasonal[i]
        }
        
        // 4. 提取趋势（LOESS平滑）
        trend = stl.loessSmooth(deseasoned)
    }
    
    // 5. 计算残差
    for i := range values {
        residual[i] = values[i] - trend[i] - seasonal[i]
    }
    
    return STLResult{
        Trend:    trend,
        Seasonal: seasonal,
        Residual: residual,
    }
}

func (stl *STLDecomposer) extractSeasonality(data []float64) []float64 {
    n := len(data)
    seasonal := make([]float64, n)
    
    // 按周期分组并取平均
    for i := 0; i < stl.period; i++ {
        sum := 0.0
        count := 0
        
        for j := i; j < n; j += stl.period {
            sum += data[j]
            count++
        }
        
        avg := sum / float64(count)
        
        // 填充季节性分量
        for j := i; j < n; j += stl.period {
            seasonal[j] = avg
        }
    }
    
    return seasonal
}

// 基于STL的异常检测
type STLAnomalyDetector struct {
    decomposer *STLDecomposer
    threshold  float64
}

func (sad *STLAnomalyDetector) Detect(ts *TimeSeries) []Anomaly {
    // 1. STL分解
    result := sad.decomposer.Decompose(ts)
    
    // 2. 分析残差
    mean := sad.mean(result.Residual)
    stddev := sad.stddev(result.Residual, mean)
    
    // 3. 检测异常（残差超过阈值）
    anomalies := []Anomaly{}
    
    for i, residual := range result.Residual {
        zscore := math.Abs((residual - mean) / stddev)
        
        if zscore > sad.threshold {
            anomalies = append(anomalies, Anomaly{
                Index:     i,
                Timestamp: ts.Points[i].Timestamp,
                Value:     ts.Points[i].Value,
                Score:     zscore,
            })
        }
    }
    
    return anomalies
}
```

### 自编码器

**深度学习异常检测**：

```go
// 自编码器异常检测器
type AutoencoderDetector struct {
    encoder *NeuralNetwork
    decoder *NeuralNetwork
    threshold float64
}

func (aed *AutoencoderDetector) Train(ts *TimeSeries) {
    // 准备训练数据（滑动窗口）
    windowSize := 24
    sequences := aed.createSequences(ts, windowSize)
    
    // 训练自编码器
    for epoch := 0; epoch < 100; epoch++ {
        for _, seq := range sequences {
            // 前向传播
            encoded := aed.encoder.Forward(seq)
            decoded := aed.decoder.Forward(encoded)
            
            // 计算重构误差
            loss := aed.reconstructionLoss(seq, decoded)
            
            // 反向传播
            aed.encoder.Backward(loss)
            aed.decoder.Backward(loss)
        }
    }
}

func (aed *AutoencoderDetector) Detect(ts *TimeSeries) []Anomaly {
    windowSize := 24
    sequences := aed.createSequences(ts, windowSize)
    
    anomalies := []Anomaly{}
    
    for i, seq := range sequences {
        // 重构
        encoded := aed.encoder.Forward(seq)
        decoded := aed.decoder.Forward(encoded)
        
        // 计算重构误差
        error := aed.reconstructionLoss(seq, decoded)
        
        // 判断异常
        if error > aed.threshold {
            anomalies = append(anomalies, Anomaly{
                Index:     i,
                Timestamp: ts.Points[i+windowSize-1].Timestamp,
                Value:     ts.Points[i+windowSize-1].Value,
                Score:     error,
            })
        }
    }
    
    return anomalies
}

func (aed *AutoencoderDetector) reconstructionLoss(
    original, reconstructed []float64,
) float64 {
    var sum float64
    for i := range original {
        diff := original[i] - reconstructed[i]
        sum += diff * diff
    }
    return math.Sqrt(sum / float64(len(original)))
}
```

---

## 总结

时序数据分析核心技术：

**数据存储**：

- InfluxDB：高性能写入
- Prometheus：查询灵活
- 数据对齐：时间同步

**分析算法**：

- 趋势：线性回归、移动平均
- 周期：自相关、FFT
- 变点：CUSUM、PELT

**预测方法**：

- Prophet：趋势+季节性
- LSTM：深度学习
- 多步预测

**异常检测**：

- STL分解：残差分析
- 自编码器：重构误差
- 阈值动态调整

**最佳实践**：

- 数据预处理（去噪、插值）
- 多算法融合
- 在线学习更新
- 可视化分析

---

**上一篇**: [16_流量控制与限流.md](16_流量控制与限流.md)  
**下一篇**: [18_多维关联分析.md](18_多维关联分析.md)

---

*最后更新: 2025年10月7日*-
