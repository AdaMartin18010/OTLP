# 分布式追踪与问题定位

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第三部分 - 排错与故障定位  

---

## 目录

- [分布式追踪与问题定位](#分布式追踪与问题定位)
  - [目录](#目录)
  - [概述](#概述)
  - [3.1.1 分布式追踪原理](#311-分布式追踪原理)
    - [Trace因果关系图](#trace因果关系图)
    - [关键路径分析](#关键路径分析)
  - [3.1.2 根因分析算法](#312-根因分析算法)
    - [5-Why自动化分析](#5-why自动化分析)
    - [因果推理引擎](#因果推理引擎)
  - [3.1.3 异常检测算法](#313-异常检测算法)
    - [统计异常检测](#统计异常检测)
    - [机器学习异常检测](#机器学习异常检测)
  - [总结](#总结)

---

## 概述

本文档介绍基于OTLP的分布式追踪原理、根因分析算法和异常检测技术。

---

## 3.1.1 分布式追踪原理

### Trace因果关系图

**形式化定义**：

```text
分布式追踪因果图 TCG = (V, E, L, T)

其中：
  V = {s₁, s₂, ..., sₙ} - Span节点集合
  E ⊆ V × V - Span间的因果关系边
  L: V → Label - Span标签函数
  T: V → Timestamp - Span时间戳函数
  
因果关系：
  (sᵢ, sⱼ) ∈ E ⟺ sᵢ happens-before sⱼ
  
传递性：
  (sᵢ, sⱼ) ∈ E ∧ (sⱼ, sₖ) ∈ E ⟹ (sᵢ, sₖ) ∈ E
```

### 关键路径分析

**算法实现**：

```go
// 关键路径算法（找到最长路径）
type CriticalPathAnalyzer struct {
    spans map[string]*Span
    graph map[string][]string // adjacency list
}

func (a *CriticalPathAnalyzer) FindCriticalPath(traceID string) []*Span {
    // 1. 构建DAG
    dag := a.buildDAG(traceID)
    
    // 2. 拓扑排序
    sorted := a.topologicalSort(dag)
    
    // 3. 计算最长路径（关键路径）
    distances := make(map[string]time.Duration)
    predecessors := make(map[string]string)
    
    for _, spanID := range sorted {
        span := a.spans[spanID]
        maxDist := time.Duration(0)
        maxPred := ""
        
        // 找到所有前驱中距离最大的
        for _, predID := range a.graph[spanID] {
            dist := distances[predID] + span.Duration()
            if dist > maxDist {
                maxDist = dist
                maxPred = predID
            }
        }
        
        distances[spanID] = maxDist
        predecessors[spanID] = maxPred
    }
    
    // 4. 回溯构建关键路径
    path := []*Span{}
    current := a.findLeafSpan(sorted)
    
    for current != "" {
        path = append([]*Span{a.spans[current]}, path...)
        current = predecessors[current]
    }
    
    return path
}

// 瓶颈识别
func (a *CriticalPathAnalyzer) IdentifyBottlenecks(
    path []*Span, 
    threshold time.Duration,
) []*Span {
    bottlenecks := []*Span{}
    
    for _, span := range path {
        if span.Duration() > threshold {
            bottlenecks = append(bottlenecks, span)
        }
    }
    
    return bottlenecks
}
```

---

## 3.1.2 根因分析算法

### 5-Why自动化分析

**自动化实现**：

```go
// 自动化5-Why根因分析
type RootCauseAnalyzer struct {
    knowledgeBase *KnowledgeBase
    reasoner      *CausalReasoner
}

type Issue struct {
    Symptom     string
    Span        *Span
    Metrics     map[string]float64
    Logs        []LogEntry
}

type RootCause struct {
    Cause       string
    Confidence  float64
    Evidence    []Evidence
    Depth       int  // Why的深度
}

func (rca *RootCauseAnalyzer) Analyze(issue Issue) []RootCause {
    causes := []RootCause{}
    currentIssue := issue
    depth := 0
    maxDepth := 5
    
    for depth < maxDepth {
        // 提取当前问题的特征
        features := rca.extractFeatures(currentIssue)
        
        // 在知识库中查找可能的原因
        candidates := rca.knowledgeBase.Query(features)
        
        if len(candidates) == 0 {
            break // 无法继续深入
        }
        
        // 选择置信度最高的原因
        bestCause := candidates[0]
        
        // 收集证据
        evidence := rca.collectEvidence(currentIssue, bestCause)
        
        causes = append(causes, RootCause{
            Cause:      bestCause.Description,
            Confidence: bestCause.Confidence,
            Evidence:   evidence,
            Depth:      depth,
        })
        
        // 如果置信度足够高，认为找到根因
        if bestCause.Confidence > 0.9 {
            break
        }
        
        // 继续深入：为什么会发生这个原因？
        currentIssue = Issue{
            Symptom: bestCause.Description,
            // ... 更新相关数据
        }
        depth++
    }
    
    return causes
}

// 特征提取
func (rca *RootCauseAnalyzer) extractFeatures(issue Issue) []Feature {
    features := []Feature{}
    
    // 1. Span特征
    if issue.Span != nil {
        features = append(features, Feature{
            Name:  "span_duration",
            Value: issue.Span.Duration().Seconds(),
        })
        features = append(features, Feature{
            Name:  "span_status",
            Value: issue.Span.Status.Code,
        })
    }
    
    // 2. Metric特征
    for name, value := range issue.Metrics {
        features = append(features, Feature{
            Name:  "metric_" + name,
            Value: value,
        })
    }
    
    // 3. Log特征
    errorCount := 0
    for _, log := range issue.Logs {
        if log.Level == "ERROR" {
            errorCount++
        }
    }
    features = append(features, Feature{
        Name:  "error_log_count",
        Value: float64(errorCount),
    })
    
    return features
}
```

### 因果推理引擎

**贝叶斯网络推理**：

```go
// 贝叶斯网络因果推理
type BayesianNetwork struct {
    nodes map[string]*BayesNode
    edges map[string][]string
}

type BayesNode struct {
    Name        string
    States      []string
    CPT         [][]float64  // Conditional Probability Table
    Parents     []*BayesNode
    Probability map[string]float64
}

func (bn *BayesianNetwork) InferCause(
    evidence map[string]string,
) map[string]float64 {
    // 使用变量消除算法进行推理
    
    // 1. 初始化所有节点的概率
    for _, node := range bn.nodes {
        node.initProbability()
    }
    
    // 2. 设置证据
    for nodeName, state := range evidence {
        if node, ok := bn.nodes[nodeName]; ok {
            node.setEvidence(state)
        }
    }
    
    // 3. 消息传播（Belief Propagation）
    bn.propagateBeliefs()
    
    // 4. 计算后验概率
    posteriors := make(map[string]float64)
    for name, node := range bn.nodes {
        if _, isEvidence := evidence[name]; !isEvidence {
            posteriors[name] = node.getPosterior()
        }
    }
    
    return posteriors
}

// 因果图分析
type CausalGraph struct {
    nodes map[string]*CausalNode
    edges []*CausalEdge
}

type CausalNode struct {
    Name   string
    Type   string  // "cause", "effect", "mediator"
    Weight float64
}

type CausalEdge struct {
    From     string
    To       string
    Strength float64  // 因果强度
    Type     string   // "direct", "indirect"
}

func (cg *CausalGraph) FindRootCauses(effect string) []*CausalNode {
    // 使用反向BFS找到所有可能的根因
    visited := make(map[string]bool)
    queue := []string{effect}
    rootCauses := []*CausalNode{}
    
    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]
        
        if visited[current] {
            continue
        }
        visited[current] = true
        
        // 找到所有指向当前节点的边
        hasPredecessor := false
        for _, edge := range cg.edges {
            if edge.To == current {
                hasPredecessor = true
                if !visited[edge.From] {
                    queue = append(queue, edge.From)
                }
            }
        }
        
        // 如果没有前驱，则是根因
        if !hasPredecessor && current != effect {
            rootCauses = append(rootCauses, cg.nodes[current])
        }
    }
    
    return rootCauses
}
```

---

## 3.1.3 异常检测算法

### 统计异常检测

**基于统计的方法**：

```go
// 基于统计的异常检测
type StatisticalAnomalyDetector struct {
    window     time.Duration
    threshold  float64  // Z-score阈值
    history    *TimeSeriesBuffer
}

func (sad *StatisticalAnomalyDetector) Detect(
    value float64, 
    timestamp time.Time,
) bool {
    // 1. 添加到历史数据
    sad.history.Add(value, timestamp)
    
    // 2. 计算统计量
    mean := sad.history.Mean()
    stddev := sad.history.StdDev()
    
    // 3. 计算Z-score
    zscore := (value - mean) / stddev
    
    // 4. 判断是否异常
    return math.Abs(zscore) > sad.threshold
}

// 移动平均异常检测
type MovingAverageDetector struct {
    window    int
    threshold float64
    values    []float64
}

func (mad *MovingAverageDetector) Detect(value float64) bool {
    // 1. 更新窗口
    mad.values = append(mad.values, value)
    if len(mad.values) > mad.window {
        mad.values = mad.values[1:]
    }
    
    // 2. 计算移动平均
    ma := mad.movingAverage()
    
    // 3. 计算偏差
    deviation := math.Abs(value - ma) / ma
    
    // 4. 判断是否异常
    return deviation > mad.threshold
}

// EWMA (Exponentially Weighted Moving Average)
type EWMADetector struct {
    alpha     float64  // 平滑系数
    ewma      float64
    threshold float64
}

func (ed *EWMADetector) Detect(value float64) bool {
    // 1. 更新EWMA
    if ed.ewma == 0 {
        ed.ewma = value
    } else {
        ed.ewma = ed.alpha*value + (1-ed.alpha)*ed.ewma
    }
    
    // 2. 计算偏差
    deviation := math.Abs(value - ed.ewma)
    
    // 3. 判断是否异常
    return deviation > ed.threshold
}
```

### 机器学习异常检测

**Isolation Forest**：

```go
// Isolation Forest异常检测
type IsolationForest struct {
    trees      []*IsolationTree
    numTrees   int
    sampleSize int
}

type IsolationTree struct {
    root *ITreeNode
}

type ITreeNode struct {
    feature   int
    threshold float64
    left      *ITreeNode
    right     *ITreeNode
    size      int
}

func (iforest *IsolationForest) Train(data [][]float64) {
    iforest.trees = make([]*IsolationTree, iforest.numTrees)
    
    for i := 0; i < iforest.numTrees; i++ {
        // 随机采样
        sample := iforest.randomSample(data, iforest.sampleSize)
        
        // 构建隔离树
        tree := &IsolationTree{}
        tree.root = iforest.buildTree(sample, 0, len(sample[0]))
        iforest.trees[i] = tree
    }
}

func (iforest *IsolationForest) AnomalyScore(point []float64) float64 {
    // 计算平均路径长度
    avgPathLength := 0.0
    
    for _, tree := range iforest.trees {
        pathLength := tree.pathLength(point)
        avgPathLength += pathLength
    }
    
    avgPathLength /= float64(iforest.numTrees)
    
    // 归一化异常分数
    c := iforest.averagePathLength(iforest.sampleSize)
    score := math.Pow(2, -avgPathLength/c)
    
    return score
}

func (iforest *IsolationForest) IsAnomaly(
    point []float64, 
    threshold float64,
) bool {
    score := iforest.AnomalyScore(point)
    return score > threshold
}
```

---

## 总结

分布式追踪与问题定位核心技术：

**追踪原理**：

- 因果关系图（TCG）
- 关键路径分析
- 瓶颈识别

**根因分析**：

- 5-Why自动化
- 贝叶斯网络推理
- 因果图分析

**异常检测**：

- 统计方法（Z-score、MA、EWMA）
- 机器学习（Isolation Forest）
- 实时检测

**应用场景**：

- 性能瓶颈定位
- 故障根因分析
- 异常行为检测
- 服务依赖分析

---

**上一篇**: [07_容错性能分析.md](07_容错性能分析.md)  
**下一篇**: [09_日志分析与关联.md](09_日志分析与关联.md)

---

*最后更新: 2025年10月7日*:
