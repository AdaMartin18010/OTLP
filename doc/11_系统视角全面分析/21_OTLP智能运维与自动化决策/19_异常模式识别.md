# 异常模式识别

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第六部分 - 多维度数据分析  

---

## 目录

- [异常模式识别](#异常模式识别)
  - [目录](#目录)
  - [概述](#概述)
  - [6.3.1 统计异常检测](#631-统计异常检测)
    - [3-Sigma规则](#3-sigma规则)
    - [箱线图方法](#箱线图方法)
  - [6.3.2 机器学习异常检测](#632-机器学习异常检测)
    - [Isolation Forest](#isolation-forest)
    - [One-Class SVM](#one-class-svm)
    - [LOF算法](#lof算法)
  - [6.3.3 深度学习异常检测](#633-深度学习异常检测)
    - [自编码器](#自编码器)
    - [VAE](#vae)
    - [GAN](#gan)
  - [6.3.4 集成异常检测](#634-集成异常检测)
    - [投票机制](#投票机制)
    - [加权融合](#加权融合)
  - [总结](#总结)

---

## 概述

本文档介绍OTLP的异常模式识别技术，包括统计方法、机器学习和深度学习方法。

---

## 6.3.1 统计异常检测

### 3-Sigma规则

**基于正态分布的异常检测**：

```go
// 3-Sigma异常检测器
type ThreeSigmaDetector struct {
    window time.Duration
    sigma  float64 // 标准差倍数，默认3
}

func (tsd *ThreeSigmaDetector) Detect(
    data []float64,
) []AnomalyPoint {
    // 1. 计算均值和标准差
    mean := tsd.mean(data)
    stddev := tsd.stddev(data, mean)
    
    // 2. 计算上下界
    upperBound := mean + tsd.sigma*stddev
    lowerBound := mean - tsd.sigma*stddev
    
    // 3. 检测异常
    anomalies := []AnomalyPoint{}
    
    for i, value := range data {
        if value > upperBound || value < lowerBound {
            score := math.Abs((value - mean) / stddev)
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: value,
                Score: score,
                Type:  tsd.getAnomalyType(value, upperBound, lowerBound),
            })
        }
    }
    
    return anomalies
}

func (tsd *ThreeSigmaDetector) getAnomalyType(
    value, upper, lower float64,
) string {
    if value > upper {
        return "spike"
    }
    return "dip"
}

// 移动窗口3-Sigma
type MovingThreeSigmaDetector struct {
    windowSize int
    sigma      float64
}

func (mtsd *MovingThreeSigmaDetector) Detect(
    data []float64,
) []AnomalyPoint {
    anomalies := []AnomalyPoint{}
    
    for i := mtsd.windowSize; i < len(data); i++ {
        // 取窗口数据
        window := data[i-mtsd.windowSize : i]
        
        // 计算统计量
        mean := mtsd.mean(window)
        stddev := mtsd.stddev(window, mean)
        
        // 检测当前点
        value := data[i]
        zscore := (value - mean) / stddev
        
        if math.Abs(zscore) > mtsd.sigma {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: value,
                Score: math.Abs(zscore),
            })
        }
    }
    
    return anomalies
}
```

### 箱线图方法

**基于四分位数的异常检测**：

```go
// 箱线图异常检测器
type BoxPlotDetector struct {
    iqrMultiplier float64 // IQR倍数，默认1.5
}

func (bpd *BoxPlotDetector) Detect(data []float64) []AnomalyPoint {
    // 1. 排序
    sorted := make([]float64, len(data))
    copy(sorted, data)
    sort.Float64s(sorted)
    
    // 2. 计算四分位数
    q1 := bpd.percentile(sorted, 0.25)
    q3 := bpd.percentile(sorted, 0.75)
    iqr := q3 - q1
    
    // 3. 计算上下界
    lowerBound := q1 - bpd.iqrMultiplier*iqr
    upperBound := q3 + bpd.iqrMultiplier*iqr
    
    // 4. 检测异常
    anomalies := []AnomalyPoint{}
    
    for i, value := range data {
        if value < lowerBound || value > upperBound {
            // 计算异常分数
            if value < lowerBound {
                score := (lowerBound - value) / iqr
                anomalies = append(anomalies, AnomalyPoint{
                    Index: i,
                    Value: value,
                    Score: score,
                    Type:  "outlier_low",
                })
            } else {
                score := (value - upperBound) / iqr
                anomalies = append(anomalies, AnomalyPoint{
                    Index: i,
                    Value: value,
                    Score: score,
                    Type:  "outlier_high",
                })
            }
        }
    }
    
    return anomalies
}

func (bpd *BoxPlotDetector) percentile(
    sorted []float64,
    p float64,
) float64 {
    n := len(sorted)
    index := p * float64(n-1)
    lower := int(index)
    upper := lower + 1
    
    if upper >= n {
        return sorted[n-1]
    }
    
    weight := index - float64(lower)
    return sorted[lower]*(1-weight) + sorted[upper]*weight
}
```

---

## 6.3.2 机器学习异常检测

### Isolation Forest

**隔离森林算法**：

```go
// Isolation Forest（完整实现）
type IsolationForest struct {
    numTrees   int
    sampleSize int
    trees      []*IsolationTree
}

type IsolationTree struct {
    root       *ITreeNode
    heightLimit int
}

type ITreeNode struct {
    splitAttr  int
    splitValue float64
    left       *ITreeNode
    right      *ITreeNode
    size       int
}

func (iforest *IsolationForest) Fit(data [][]float64) {
    iforest.trees = make([]*IsolationTree, iforest.numTrees)
    
    for i := 0; i < iforest.numTrees; i++ {
        // 随机采样
        sample := iforest.randomSample(data)
        
        // 构建隔离树
        heightLimit := int(math.Ceil(math.Log2(float64(len(sample)))))
        tree := &IsolationTree{
            heightLimit: heightLimit,
        }
        tree.root = iforest.buildTree(sample, 0, heightLimit)
        iforest.trees[i] = tree
    }
}

func (iforest *IsolationForest) buildTree(
    data [][]float64,
    currentHeight, heightLimit int,
) *ITreeNode {
    n := len(data)
    
    // 终止条件
    if currentHeight >= heightLimit || n <= 1 {
        return &ITreeNode{size: n}
    }
    
    // 随机选择分割属性和值
    dim := len(data[0])
    splitAttr := rand.Intn(dim)
    
    // 找到该属性的最小最大值
    min, max := data[0][splitAttr], data[0][splitAttr]
    for _, point := range data {
        if point[splitAttr] < min {
            min = point[splitAttr]
        }
        if point[splitAttr] > max {
            max = point[splitAttr]
        }
    }
    
    // 随机分割值
    splitValue := min + rand.Float64()*(max-min)
    
    // 分割数据
    left, right := [][]float64{}, [][]float64{}
    for _, point := range data {
        if point[splitAttr] < splitValue {
            left = append(left, point)
        } else {
            right = append(right, point)
        }
    }
    
    // 递归构建子树
    return &ITreeNode{
        splitAttr:  splitAttr,
        splitValue: splitValue,
        left:       iforest.buildTree(left, currentHeight+1, heightLimit),
        right:      iforest.buildTree(right, currentHeight+1, heightLimit),
        size:       n,
    }
}

func (iforest *IsolationForest) AnomalyScore(point []float64) float64 {
    // 计算平均路径长度
    avgPathLength := 0.0
    
    for _, tree := range iforest.trees {
        pathLength := iforest.pathLength(point, tree.root, 0)
        avgPathLength += pathLength
    }
    
    avgPathLength /= float64(iforest.numTrees)
    
    // 归一化异常分数
    c := iforest.averagePathLength(iforest.sampleSize)
    score := math.Pow(2, -avgPathLength/c)
    
    return score
}

func (iforest *IsolationForest) pathLength(
    point []float64,
    node *ITreeNode,
    currentHeight float64,
) float64 {
    // 叶节点
    if node.left == nil && node.right == nil {
        return currentHeight + iforest.averagePathLength(node.size)
    }
    
    // 递归遍历
    if point[node.splitAttr] < node.splitValue {
        return iforest.pathLength(point, node.left, currentHeight+1)
    }
    return iforest.pathLength(point, node.right, currentHeight+1)
}

func (iforest *IsolationForest) averagePathLength(n int) float64 {
    if n <= 1 {
        return 0
    }
    
    // c(n) = 2H(n-1) - 2(n-1)/n
    // H(i) = ln(i) + 欧拉常数
    h := math.Log(float64(n-1)) + 0.5772156649
    return 2*h - 2*float64(n-1)/float64(n)
}
```

### One-Class SVM

**单类支持向量机**：

```go
// One-Class SVM异常检测器
type OneClassSVM struct {
    nu     float64  // 异常比例上界
    gamma  float64  // RBF核参数
    support [][]float64
    alphas  []float64
    rho     float64
}

func (ocsvm *OneClassSVM) Fit(data [][]float64) {
    // SMO算法训练（简化实现）
    n := len(data)
    
    // 初始化
    ocsvm.alphas = make([]float64, n)
    
    // 迭代优化
    for iter := 0; iter < 1000; iter++ {
        numChanged := 0
        
        for i := 0; i < n; i++ {
            // 选择违反KKT条件的样本
            if ocsvm.violatesKKT(data, i) {
                // 选择第二个样本
                j := ocsvm.selectSecond(data, i)
                
                // 更新alpha
                if ocsvm.updateAlphas(data, i, j) {
                    numChanged++
                }
            }
        }
        
        if numChanged == 0 {
            break
        }
    }
    
    // 提取支持向量
    ocsvm.extractSupportVectors(data)
}

func (ocsvm *OneClassSVM) Predict(point []float64) bool {
    // 计算决策函数值
    decision := -ocsvm.rho
    
    for i, sv := range ocsvm.support {
        decision += ocsvm.alphas[i] * ocsvm.kernel(sv, point)
    }
    
    // decision < 0 表示异常
    return decision < 0
}

func (ocsvm *OneClassSVM) kernel(x, y []float64) float64 {
    // RBF核
    var sum float64
    for i := range x {
        diff := x[i] - y[i]
        sum += diff * diff
    }
    return math.Exp(-ocsvm.gamma * sum)
}
```

### LOF算法

**局部异常因子**：

```go
// LOF异常检测器
type LOFDetector struct {
    k int // 邻居数量
}

func (lof *LOFDetector) Detect(data [][]float64) []AnomalyPoint {
    n := len(data)
    anomalies := []AnomalyPoint{}
    
    // 1. 计算每个点的k-距离和k-邻域
    kDistances := make([]float64, n)
    kNeighbors := make([][]int, n)
    
    for i := range data {
        distances := make([]struct {
            index int
            dist  float64
        }, n)
        
        for j := range data {
            distances[j].index = j
            distances[j].dist = lof.distance(data[i], data[j])
        }
        
        sort.Slice(distances, func(a, b int) bool {
            return distances[a].dist < distances[b].dist
        })
        
        kDistances[i] = distances[lof.k].dist
        kNeighbors[i] = make([]int, lof.k)
        for j := 0; j < lof.k; j++ {
            kNeighbors[i][j] = distances[j+1].index // 跳过自己
        }
    }
    
    // 2. 计算局部可达密度(LRD)
    lrd := make([]float64, n)
    for i := range data {
        sum := 0.0
        for _, neighbor := range kNeighbors[i] {
            reachDist := math.Max(
                lof.distance(data[i], data[neighbor]),
                kDistances[neighbor],
            )
            sum += reachDist
        }
        lrd[i] = float64(lof.k) / sum
    }
    
    // 3. 计算LOF
    for i := range data {
        sum := 0.0
        for _, neighbor := range kNeighbors[i] {
            sum += lrd[neighbor]
        }
        lofScore := sum / (float64(lof.k) * lrd[i])
        
        // LOF > 1表示异常
        if lofScore > 1.5 {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: data[i][0], // 简化：只取第一维
                Score: lofScore,
            })
        }
    }
    
    return anomalies
}

func (lof *LOFDetector) distance(a, b []float64) float64 {
    var sum float64
    for i := range a {
        diff := a[i] - b[i]
        sum += diff * diff
    }
    return math.Sqrt(sum)
}
```

---

## 6.3.3 深度学习异常检测

### 自编码器

**重构误差异常检测**：

```go
// 自编码器异常检测器（概念实现）
type AutoencoderAnomalyDetector struct {
    encoder    *NeuralNetwork
    decoder    *NeuralNetwork
    threshold  float64
    inputSize  int
    hiddenSize int
}

func (aad *AutoencoderAnomalyDetector) Train(
    data [][]float64,
    epochs int,
) {
    for epoch := 0; epoch < epochs; epoch++ {
        totalLoss := 0.0
        
        for _, sample := range data {
            // 前向传播
            encoded := aad.encoder.Forward(sample)
            decoded := aad.decoder.Forward(encoded)
            
            // 计算重构误差
            loss := aad.reconstructionLoss(sample, decoded)
            totalLoss += loss
            
            // 反向传播
            aad.backpropagate(sample, decoded, loss)
        }
        
        avgLoss := totalLoss / float64(len(data))
        
        // 更新阈值（训练集最大重构误差的某个倍数）
        if epoch == epochs-1 {
            aad.threshold = avgLoss * 3.0
        }
    }
}

func (aad *AutoencoderAnomalyDetector) Detect(
    data [][]float64,
) []AnomalyPoint {
    anomalies := []AnomalyPoint{}
    
    for i, sample := range data {
        // 重构
        encoded := aad.encoder.Forward(sample)
        decoded := aad.decoder.Forward(encoded)
        
        // 计算重构误差
        error := aad.reconstructionLoss(sample, decoded)
        
        // 判断异常
        if error > aad.threshold {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: sample[0],
                Score: error / aad.threshold,
            })
        }
    }
    
    return anomalies
}

func (aad *AutoencoderAnomalyDetector) reconstructionLoss(
    original, reconstructed []float64,
) float64 {
    var sum float64
    for i := range original {
        diff := original[i] - reconstructed[i]
        sum += diff * diff
    }
    return math.Sqrt(sum)
}
```

### VAE

**变分自编码器**：

```go
// VAE异常检测器
type VAEDetector struct {
    encoder    *VAEEncoder
    decoder    *VAEDecoder
    threshold  float64
}

type VAEEncoder struct {
    network *NeuralNetwork
    muLayer *Layer
    sigmaLayer *Layer
}

func (vae *VAEDetector) Detect(data [][]float64) []AnomalyPoint {
    anomalies := []AnomalyPoint{}
    
    for i, sample := range data {
        // 编码到潜在空间
        mu, sigma := vae.encoder.Encode(sample)
        
        // 采样
        z := vae.reparameterize(mu, sigma)
        
        // 解码
        reconstructed := vae.decoder.Decode(z)
        
        // 计算ELBO（Evidence Lower Bound）
        reconLoss := vae.reconstructionLoss(sample, reconstructed)
        kldLoss := vae.kldLoss(mu, sigma)
        elbo := reconLoss + kldLoss
        
        // 判断异常
        if elbo > vae.threshold {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: sample[0],
                Score: elbo,
            })
        }
    }
    
    return anomalies
}

func (vae *VAEDetector) reparameterize(
    mu, sigma []float64,
) []float64 {
    z := make([]float64, len(mu))
    for i := range z {
        epsilon := rand.NormFloat64()
        z[i] = mu[i] + sigma[i]*epsilon
    }
    return z
}

func (vae *VAEDetector) kldLoss(mu, sigma []float64) float64 {
    // KL散度: KL(q(z|x) || p(z))
    var sum float64
    for i := range mu {
        sum += sigma[i]*sigma[i] + mu[i]*mu[i] - math.Log(sigma[i]*sigma[i]) - 1
    }
    return 0.5 * sum
}
```

### GAN

**生成对抗网络**：

```go
// GAN异常检测器
type GANDetector struct {
    generator     *NeuralNetwork
    discriminator *NeuralNetwork
    threshold     float64
}

func (gand *GANDetector) Detect(data [][]float64) []AnomalyPoint {
    anomalies := []AnomalyPoint{}
    
    for i, sample := range data {
        // 判别器打分
        score := gand.discriminator.Forward(sample)[0]
        
        // score接近0表示判别器认为是假的（异常）
        if score < gand.threshold {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: sample[0],
                Score: 1.0 - score,
            })
        }
    }
    
    return anomalies
}
```

---

## 6.3.4 集成异常检测

### 投票机制

**多检测器投票**：

```go
// 集成异常检测器
type EnsembleDetector struct {
    detectors []AnomalyDetector
    threshold float64 // 投票阈值
}

type AnomalyDetector interface {
    Detect(data [][]float64) []AnomalyPoint
}

func (ed *EnsembleDetector) Detect(data [][]float64) []AnomalyPoint {
    n := len(data)
    
    // 收集所有检测器的结果
    votes := make([]int, n)
    scores := make([]float64, n)
    
    for _, detector := range ed.detectors {
        anomalies := detector.Detect(data)
        
        for _, anomaly := range anomalies {
            votes[anomaly.Index]++
            scores[anomaly.Index] += anomaly.Score
        }
    }
    
    // 投票决策
    anomalies := []AnomalyPoint{}
    numDetectors := float64(len(ed.detectors))
    
    for i := 0; i < n; i++ {
        voteRatio := float64(votes[i]) / numDetectors
        
        if voteRatio >= ed.threshold {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: data[i][0],
                Score: scores[i] / float64(votes[i]), // 平均分数
            })
        }
    }
    
    return anomalies
}
```

### 加权融合

**基于性能的加权**：

```go
// 加权集成检测器
type WeightedEnsembleDetector struct {
    detectors []AnomalyDetector
    weights   []float64
}

func (wed *WeightedEnsembleDetector) Detect(
    data [][]float64,
) []AnomalyPoint {
    n := len(data)
    
    // 加权分数
    weightedScores := make([]float64, n)
    
    for i, detector := range wed.detectors {
        anomalies := detector.Detect(data)
        
        for _, anomaly := range anomalies {
            weightedScores[anomaly.Index] += wed.weights[i] * anomaly.Score
        }
    }
    
    // 归一化
    totalWeight := 0.0
    for _, w := range wed.weights {
        totalWeight += w
    }
    
    // 计算阈值（动态）
    threshold := wed.calculateThreshold(weightedScores)
    
    // 生成结果
    anomalies := []AnomalyPoint{}
    for i, score := range weightedScores {
        normalizedScore := score / totalWeight
        
        if normalizedScore > threshold {
            anomalies = append(anomalies, AnomalyPoint{
                Index: i,
                Value: data[i][0],
                Score: normalizedScore,
            })
        }
    }
    
    return anomalies
}

func (wed *WeightedEnsembleDetector) calculateThreshold(
    scores []float64,
) float64 {
    // 使用箱线图方法计算动态阈值
    sorted := make([]float64, len(scores))
    copy(sorted, scores)
    sort.Float64s(sorted)
    
    q3 := sorted[int(float64(len(sorted))*0.75)]
    q1 := sorted[int(float64(len(sorted))*0.25)]
    iqr := q3 - q1
    
    return q3 + 1.5*iqr
}

// 自适应权重更新
func (wed *WeightedEnsembleDetector) UpdateWeights(
    trueAnomalies []int,
    predictions [][]AnomalyPoint,
) {
    // 计算每个检测器的F1分数
    for i, pred := range predictions {
        tp, fp, fn := wed.calculateMetrics(trueAnomalies, pred)
        
        precision := float64(tp) / float64(tp+fp)
        recall := float64(tp) / float64(tp+fn)
        f1 := 2 * precision * recall / (precision + recall)
        
        // 更新权重
        wed.weights[i] = f1
    }
    
    // 归一化权重
    sum := 0.0
    for _, w := range wed.weights {
        sum += w
    }
    for i := range wed.weights {
        wed.weights[i] /= sum
    }
}
```

---

## 总结

异常模式识别核心技术：

**统计方法**：

- 3-Sigma：简单高效
- 箱线图：鲁棒性好
- 适合单维数据

**机器学习**：

- Isolation Forest：高效
- One-Class SVM：精确
- LOF：局部异常

**深度学习**：

- 自编码器：重构误差
- VAE：概率建模
- GAN：生成对抗

**集成方法**：

- 投票：简单可靠
- 加权：性能优化
- 自适应：动态调整

**最佳实践**：

- 多方法结合
- 动态阈值
- 在线学习
- 可解释性
- 误报控制

---

**上一篇**: [18_多维关联分析.md](18_多维关联分析.md)  
**下一篇**: [20_状态推理引擎.md](20_状态推理引擎.md)

---

*最后更新: 2025年10月7日*-
