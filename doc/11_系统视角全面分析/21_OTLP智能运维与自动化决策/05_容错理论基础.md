# 容错理论基础

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第二部分 - 容错机制与策略  

---

## 目录

- [容错理论基础](#容错理论基础)
  - [目录](#目录)
  - [概述](#概述)
  - [2.1.1 故障模型分类](#211-故障模型分类)
    - [1. 崩溃故障 (Crash Failure)](#1-崩溃故障-crash-failure)
    - [2. 遗漏故障 (Omission Failure)](#2-遗漏故障-omission-failure)
    - [3. 时序故障 (Timing Failure)](#3-时序故障-timing-failure)
    - [4. 响应故障 (Response Failure)](#4-响应故障-response-failure)
    - [5. 拜占庭故障 (Byzantine Failure)](#5-拜占庭故障-byzantine-failure)
  - [2.1.2 容错策略](#212-容错策略)
    - [1. 故障预防 (Fault Prevention)](#1-故障预防-fault-prevention)
    - [2. 故障检测 (Fault Detection)](#2-故障检测-fault-detection)
    - [3. 故障隔离 (Fault Isolation)](#3-故障隔离-fault-isolation)
    - [4. 故障恢复 (Fault Recovery)](#4-故障恢复-fault-recovery)
  - [总结](#总结)

---

## 概述

本文档介绍容错理论基础，包括故障模型分类和四大容错策略：预防、检测、隔离、恢复。

---

## 2.1.1 故障模型分类

### 1. 崩溃故障 (Crash Failure)

**定义**：组件停止工作，不再响应

**OTLP场景**：

- Collector进程崩溃
- SDK进程终止
- Backend服务宕机

**检测方法**：

- 心跳检测
- 健康检查（/healthz）
- 超时检测

### 2. 遗漏故障 (Omission Failure)

**定义**：组件遗漏某些操作（如丢失消息）

**OTLP场景**：

- 网络丢包导致Span丢失
- 缓冲区满导致数据丢弃
- 采样导致数据遗漏

**检测方法**：

- 序列号检测
- 数据完整性校验
- 统计分析

### 3. 时序故障 (Timing Failure)

**定义**：响应时间超出预期范围

**OTLP场景**：

- 数据导出延迟过高
- 查询响应超时
- 时钟漂移导致时间戳错误

**检测方法**：

- 超时检测
- 延迟监控
- 时钟同步检查（NTP）

### 4. 响应故障 (Response Failure)

**定义**：组件返回错误的响应

**OTLP场景**：

- 错误的TraceID生成
- 错误的Span关系
- 错误的Metric计算

**检测方法**：

- 数据校验
- 一致性检查
- 冗余计算验证

### 5. 拜占庭故障 (Byzantine Failure)

**定义**：组件表现出任意异常行为

**OTLP场景**：

- 恶意Collector篡改数据
- 内存损坏导致随机错误
- 硬件故障导致计算错误

**检测方法**：

- 多副本对比
- 数字签名验证
- 拜占庭容错算法（BFT）

---

## 2.1.2 容错策略

### 1. 故障预防 (Fault Prevention)

**目标**：在故障发生前消除故障原因

**OTLP实践**：

```yaml
# 资源限制预防OOM
resources:
  limits:
    memory: 2Gi
    cpu: 2000m
  requests:
    memory: 1Gi
    cpu: 1000m

# 速率限制预防过载
rate_limiting:
  max_requests_per_second: 10000
  max_batch_size: 1000

# 输入验证预防错误数据
validation:
  - check: span_id_format
    regex: "^[0-9a-f]{16}$"
  - check: trace_id_format
    regex: "^[0-9a-f]{32}$"
```

### 2. 故障检测 (Fault Detection)

**目标**：快速检测故障发生

**检测机制**：

```go
// 心跳检测
type HealthChecker struct {
    interval time.Duration
    timeout  time.Duration
}

func (h *HealthChecker) Check(endpoint string) error {
    ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
    defer cancel()
    
    resp, err := http.Get(endpoint + "/healthz")
    if err != nil {
        return fmt.Errorf("health check failed: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unhealthy status: %d", resp.StatusCode)
    }
    return nil
}

// 数据完整性检测
type IntegrityChecker struct {
    expectedSequence uint64
    mu               sync.Mutex
}

func (c *IntegrityChecker) CheckSequence(seq uint64) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if seq != c.expectedSequence {
        return fmt.Errorf("sequence gap detected: expected %d, got %d", 
            c.expectedSequence, seq)
    }
    c.expectedSequence++
    return nil
}

// 性能异常检测
type PerformanceMonitor struct {
    baseline time.Duration
    threshold float64
}

func (m *PerformanceMonitor) CheckLatency(latency time.Duration) bool {
    ratio := float64(latency) / float64(m.baseline)
    return ratio > m.threshold // 超过阈值则异常
}
```

### 3. 故障隔离 (Fault Isolation)

**目标**：防止故障扩散

**隔离策略**：

```go
// 熔断器模式
type CircuitBreaker struct {
    maxFailures  int
    resetTimeout time.Duration
    state        State
    failures     int
    lastFailTime time.Time
    mu           sync.Mutex
}

type State int
const (
    StateClosed State = iota  // 正常状态
    StateOpen                  // 熔断状态
    StateHalfOpen             // 半开状态
)

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    // 检查是否可以尝试恢复
    if cb.state == StateOpen {
        if time.Since(cb.lastFailTime) > cb.resetTimeout {
            cb.state = StateHalfOpen
        } else {
            return errors.New("circuit breaker is open")
        }
    }
    
    // 执行调用
    err := fn()
    
    if err != nil {
        cb.failures++
        cb.lastFailTime = time.Now()
        
        if cb.failures >= cb.maxFailures {
            cb.state = StateOpen
        }
        return err
    }
    
    // 成功则重置
    if cb.state == StateHalfOpen {
        cb.state = StateClosed
    }
    cb.failures = 0
    return nil
}

// 舱壁模式（资源隔离）
type BulkheadPool struct {
    pools map[string]*WorkerPool
}

type WorkerPool struct {
    workers   chan struct{}
    maxWorkers int
}

func NewWorkerPool(max int) *WorkerPool {
    return &WorkerPool{
        workers:   make(chan struct{}, max),
        maxWorkers: max,
    }
}

func (p *WorkerPool) Acquire() error {
    select {
    case p.workers <- struct{}{}:
        return nil
    default:
        return errors.New("worker pool exhausted")
    }
}

func (p *WorkerPool) Release() {
    <-p.workers
}
```

### 4. 故障恢复 (Fault Recovery)

**目标**：从故障中恢复

**恢复策略**：

```go
// 重试机制（指数退避）
type RetryPolicy struct {
    maxRetries int
    baseDelay  time.Duration
    maxDelay   time.Duration
}

func (p *RetryPolicy) Execute(fn func() error) error {
    var err error
    for i := 0; i < p.maxRetries; i++ {
        err = fn()
        if err == nil {
            return nil
        }
        
        // 指数退避
        delay := p.baseDelay * time.Duration(1<<uint(i))
        if delay > p.maxDelay {
            delay = p.maxDelay
        }
        
        // 添加抖动避免惊群
        jitter := time.Duration(rand.Int63n(int64(delay / 10)))
        time.Sleep(delay + jitter)
    }
    return fmt.Errorf("max retries exceeded: %w", err)
}

// 故障转移（Failover）
type FailoverCollector struct {
    primary   string
    secondary []string
    current   int
    mu        sync.Mutex
}

func (f *FailoverCollector) Send(data []byte) error {
    f.mu.Lock()
    endpoint := f.getEndpoint()
    f.mu.Unlock()
    
    err := sendToEndpoint(endpoint, data)
    if err != nil {
        // 切换到下一个endpoint
        f.mu.Lock()
        f.current = (f.current + 1) % (len(f.secondary) + 1)
        f.mu.Unlock()
        
        // 重试
        return f.Send(data)
    }
    return nil
}

func (f *FailoverCollector) getEndpoint() string {
    if f.current == 0 {
        return f.primary
    }
    return f.secondary[f.current-1]
}

// 检查点与恢复
type Checkpoint struct {
    lastProcessedSeq uint64
    timestamp        time.Time
    state            map[string]interface{}
}

type CheckpointManager struct {
    storage Storage
}

func (m *CheckpointManager) Save(cp *Checkpoint) error {
    data, err := json.Marshal(cp)
    if err != nil {
        return err
    }
    return m.storage.Write("checkpoint", data)
}

func (m *CheckpointManager) Restore() (*Checkpoint, error) {
    data, err := m.storage.Read("checkpoint")
    if err != nil {
        return nil, err
    }
    
    var cp Checkpoint
    err = json.Unmarshal(data, &cp)
    return &cp, err
}
```

---

## 总结

容错理论提供了系统化的故障应对方法：

**故障模型**：

- 崩溃故障、遗漏故障、时序故障、响应故障、拜占庭故障

**容错策略**：

1. **预防** - 消除故障原因
2. **检测** - 快速发现故障
3. **隔离** - 防止故障扩散
4. **恢复** - 从故障中恢复

---

**上一篇**: [04_并发并行模型.md](04_并发并行模型.md)  
**下一篇**: [06_OTLP容错架构.md](06_OTLP容错架构.md)

---

*最后更新: 2025年10月7日*:
