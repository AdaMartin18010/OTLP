# 🔧 OTLP项目故障排查完整手册

> **目标**: 系统化整理常见问题和解决方案  
> **适用场景**: 开发、测试、生产环境  
> **更新时间**: 2025年10月20日

---

## 📋 目录

- [🔧 OTLP项目故障排查完整手册](#-otlp项目故障排查完整手册)
  - [📋 目录](#-目录)
  - [🔌 连接问题](#-连接问题)
    - [问题1: Collector连接失败](#问题1-collector连接失败)
      - [症状](#症状)
      - [诊断步骤](#诊断步骤)
      - [解决方案](#解决方案)
    - [问题2: 后端连接失败](#问题2-后端连接失败)
      - [症状](#症状-1)
      - [诊断步骤](#诊断步骤-1)
      - [解决方案](#解决方案-1)
  - [📊 数据问题](#-数据问题)
    - [问题3: Trace不完整](#问题3-trace不完整)
      - [症状](#症状-2)
      - [诊断步骤](#诊断步骤-2)
      - [解决方案](#解决方案-2)
    - [问题4: Span属性缺失](#问题4-span属性缺失)
      - [症状](#症状-3)
      - [诊断步骤](#诊断步骤-3)
      - [解决方案](#解决方案-3)
  - [⚡ 性能问题](#-性能问题)
    - [问题5: 高延迟](#问题5-高延迟)
      - [症状](#症状-4)
      - [诊断步骤](#诊断步骤-4)
      - [解决方案](#解决方案-4)
    - [问题6: 内存溢出](#问题6-内存溢出)
      - [症状](#症状-5)
      - [诊断步骤](#诊断步骤-5)
      - [解决方案](#解决方案-5)
  - [⚙️ 配置问题](#️-配置问题)
    - [问题7: 配置文件格式错误](#问题7-配置文件格式错误)
      - [症状](#症状-6)
      - [诊断步骤](#诊断步骤-6)
      - [解决方案](#解决方案-6)
    - [问题8: Pipeline配置错误](#问题8-pipeline配置错误)
      - [症状](#症状-7)
      - [诊断步骤](#诊断步骤-7)
      - [解决方案](#解决方案-7)
  - [🔗 SDK问题](#-sdk问题)
    - [问题9: SDK初始化失败](#问题9-sdk初始化失败)
      - [症状](#症状-8)
      - [诊断步骤](#诊断步骤-8)
      - [解决方案](#解决方案-8)
  - [📝 最佳实践建议](#-最佳实践建议)
    - [日志记录](#日志记录)
    - [健康检查](#健康检查)
    - [监控指标](#监控指标)
  - [🔗 相关资源](#-相关资源)

---

## 🔌 连接问题

### 问题1: Collector连接失败

#### 症状

```text
❌ Error: failed to connect to collector
❌ Error: context deadline exceeded
❌ Error: connection refused
```

#### 诊断步骤

```bash
# 1. 检查Collector是否运行
docker ps | grep otel-collector
# 或
kubectl get pods -n observability | grep otel-collector

# 2. 检查端口是否正确
# gRPC默认: 4317
# HTTP默认: 4318
netstat -an | grep 4317
netstat -an | grep 4318

# 3. 测试连接
curl http://localhost:4318/v1/traces
curl http://localhost:13133/  # 健康检查

# 4. 查看Collector日志
docker logs otel-collector
kubectl logs -f otel-collector-xxx -n observability
```

#### 解决方案

**方案A: Collector未运行**:

```bash
# Docker
docker-compose up -d otel-collector

# Kubernetes
kubectl apply -f otel-collector-deployment.yaml
```

**方案B: 端口配置错误**:

```go
// 确认SDK配置
exporter, err := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("localhost:4317"),  // ✅ 正确
    // otlptracegrpc.WithEndpoint("localhost:4318"),  // ❌ 错误 (HTTP端口)
    otlptracegrpc.WithInsecure(),
)
```

**方案C: 防火墙阻止**:

```bash
# Linux
sudo ufw allow 4317
sudo ufw allow 4318

# Windows
netsh advfirewall firewall add rule name="OTLP gRPC" dir=in action=allow protocol=TCP localport=4317
netsh advfirewall firewall add rule name="OTLP HTTP" dir=in action=allow protocol=TCP localport=4318
```

**方案D: Docker网络问题**:

```yaml
# docker-compose.yml
services:
  app:
    networks:
      - otel-network
  
  otel-collector:
    networks:
      - otel-network

networks:
  otel-network:
    driver: bridge
```

---

### 问题2: 后端连接失败

#### 症状

```text
❌ Error: failed to export spans to backend
❌ Error: connection to Jaeger failed
❌ Error: elasticsearch connection timeout
```

#### 诊断步骤

```bash
# 1. 检查后端是否运行
docker ps | grep jaeger
docker ps | grep elasticsearch

# 2. 测试后端连接
curl http://localhost:16686  # Jaeger UI
curl http://localhost:9200   # Elasticsearch

# 3. 查看Collector exporter配置
cat otel-config.yaml | grep -A 20 "exporters:"

# 4. 查看Collector日志
docker logs otel-collector | grep "export"
```

#### 解决方案

**方案A: 后端未启动**:

```bash
# 启动Jaeger
docker run -d --name jaeger \
  -e COLLECTOR_OTLP_ENABLED=true \
  -p 16686:16686 \
  -p 14250:14250 \
  jaegertracing/all-in-one:latest

# 启动Elasticsearch
docker run -d --name elasticsearch \
  -e "discovery.type=single-node" \
  -p 9200:9200 \
  elasticsearch:8.10.0
```

**方案B: 配置错误**:

```yaml
# otel-config.yaml
exporters:
  jaeger:
    endpoint: jaeger:14250  # ✅ Docker内部网络
    # endpoint: localhost:14250  # ❌ 如果Collector在容器内
    tls:
      insecure: true
  
  elasticsearch:
    endpoints: [http://elasticsearch:9200]  # ✅ 正确
    # endpoints: [http://localhost:9200]  # ❌ 容器网络
```

**方案C: 认证问题**:

```yaml
exporters:
  elasticsearch:
    endpoints: [https://elasticsearch:9200]
    auth:
      authenticator: basicauth
    tls:
      ca_file: /path/to/ca.crt
      insecure: false

extensions:
  basicauth:
    client_auth:
      username: elastic
      password: ${ELASTIC_PASSWORD}
```

---

## 📊 数据问题

### 问题3: Trace不完整

#### 症状

```text
⚠️ 只看到部分Span
⚠️ 缺少父Span
⚠️ Trace显示为多个片段
```

#### 诊断步骤

```bash
# 1. 检查采样配置
# 查看是否有采样导致数据丢失

# 2. 检查批处理超时
# 可能批处理未及时发送

# 3. 查看日志中的错误
docker logs app | grep "span"
docker logs otel-collector | grep "dropped"

# 4. 检查trace_id是否一致
# 在Jaeger UI中查看trace_id
```

#### 解决方案

**方案A: 采样配置问题**:

```go
// 确保开发环境100%采样
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter),
    sdktrace.WithSampler(sdktrace.AlwaysSample()),  // ✅ 开发环境
    // sdktrace.WithSampler(sdktrace.TraceIDRatioBased(0.01)),  // ❌ 生产环境1%采样
)
```

**方案B: 批处理配置**:

```yaml
# otel-config.yaml
processors:
  batch:
    timeout: 1s           # ✅ 减小超时
    send_batch_size: 128  # ✅ 减小批量大小
    # timeout: 10s        # ❌ 太长，导致延迟
```

**方案C: Context传播问题**:

```go
// 确保正确传播Context
func processOrder(ctx context.Context) {
    ctx, span := tracer.Start(ctx, "process_order")
    defer span.End()
    
    // ✅ 传递ctx
    validateOrder(ctx)
    
    // ❌ 不传递ctx，会导致Trace断裂
    // validateOrder(context.Background())
}
```

**方案D: 跨服务传播**:

```go
// HTTP客户端：注入Context
import "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

client := &http.Client{
    Transport: otelhttp.NewTransport(http.DefaultTransport),  // ✅ 自动注入
}

// HTTP服务端：提取Context
handler := otelhttp.NewHandler(http.HandlerFunc(handleRequest), "my-service")
```

---

### 问题4: Span属性缺失

#### 症状

```text
⚠️ 自定义属性未显示
⚠️ 标准属性值为空
⚠️ Resource属性丢失
```

#### 诊断步骤

```bash
# 1. 检查属性设置代码
# 确认是否正确调用SetAttributes

# 2. 检查Collector过滤器
# 可能被attributes processor删除

# 3. 查看原始OTLP数据
# 使用logging exporter查看
```

#### 解决方案

**方案A: 属性设置时机**:

```go
// ✅ 在Span创建时设置
ctx, span := tracer.Start(ctx, "operation",
    trace.WithAttributes(
        attribute.String("key", "value"),
    ),
)

// ✅ Span创建后设置（Span结束前）
span.SetAttributes(attribute.String("key", "value"))

// ❌ Span结束后设置（无效）
span.End()
span.SetAttributes(attribute.String("key", "value"))  // 太晚了
```

**方案B: Resource属性**:

```go
// 确保Resource正确配置
res, err := resource.New(ctx,
    resource.WithAttributes(
        semconv.ServiceName("my-service"),
        semconv.ServiceVersion("1.0.0"),
        semconv.DeploymentEnvironment("production"),
    ),
)

tp := sdktrace.NewTracerProvider(
    sdktrace.WithResource(res),  // ✅ 必须设置
)
```

**方案C: Collector过滤器检查**:

```yaml
# 确保没有误删属性
processors:
  attributes:
    actions:
      # - key: myapp.order.id
      #   action: delete  # ❌ 误删了需要的属性
      
      - key: http.request.header.authorization
        action: delete  # ✅ 正确：删除敏感数据
```

---

## ⚡ 性能问题

### 问题5: 高延迟

#### 症状

```text
⚠️ Span导出延迟>1秒
⚠️ 应用响应变慢
⚠️ CPU使用率升高
```

#### 诊断步骤

```bash
# 1. 查看Collector指标
curl http://localhost:8888/metrics | grep "duration"
curl http://localhost:8888/metrics | grep "queue"

# 2. 检查批处理配置
# 批量大小是否过小

# 3. 查看网络延迟
ping localhost
traceroute collector-host

# 4. 检查后端性能
# Jaeger/Elasticsearch是否过载
```

#### 解决方案

**方案A: 批处理优化**:

```yaml
processors:
  batch:
    timeout: 1s             # 平衡延迟和吞吐
    send_batch_size: 512    # ✅ 增大批量
    send_batch_max_size: 1024
```

**方案B: 异步导出**:

```go
// ✅ 使用BatchSpanProcessor（异步）
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter),  // ✅ 异步批处理
)

// ❌ 不要使用SimpleSpanProcessor（同步）
// tp := sdktrace.NewTracerProvider(
//     sdktrace.WithSpanProcessor(sdktrace.NewSimpleSpanProcessor(exporter)),
// )
```

**方案C: 采样策略**:

```yaml
# Collector端采样
processors:
  probabilistic_sampler:
    sampling_percentage: 10  # 10%采样，减少数据量
  
  tail_sampling:
    decision_wait: 10s
    policies:
      - name: errors
        type: status_code
        status_code:
          status_codes: [ERROR]
      - name: slow
        type: latency
        latency:
          threshold_ms: 1000
      - name: random
        type: probabilistic
        probabilistic:
          sampling_percentage: 1  # 其他1%采样
```

**方案D: 队列配置**:

```yaml
exporters:
  otlp:
    endpoint: backend:4317
    sending_queue:
      enabled: true
      num_consumers: 10      # ✅ 增加消费者
      queue_size: 5000       # ✅ 增大队列
```

---

### 问题6: 内存溢出

#### 症状

```text
❌ OOMKilled (Kubernetes)
❌ Memory limiter refusing data
❌ Collector重启
```

#### 诊断步骤

```bash
# 1. 查看内存使用
docker stats otel-collector
kubectl top pod otel-collector-xxx

# 2. 查看Collector配置
cat otel-config.yaml | grep "memory_limiter"

# 3. 查看日志
docker logs otel-collector | grep "memory"
```

#### 解决方案

**方案A: Memory Limiter配置**:

```yaml
processors:
  memory_limiter:
    check_interval: 1s
    limit_mib: 2048        # ✅ 设置合理限制
    spike_limit_mib: 512   # ✅ 允许突发
```

**方案B: 增加内存分配**:

```yaml
# docker-compose.yml
services:
  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    mem_limit: 4g          # ✅ 增加内存限制
    mem_reservation: 2g
```

```yaml
# Kubernetes
resources:
  requests:
    memory: "2Gi"
  limits:
    memory: "4Gi"
```

**方案C: 减少数据量**:

```yaml
processors:
  # 1. 启用采样
  probabilistic_sampler:
    sampling_percentage: 10
  
  # 2. 过滤不需要的数据
  filter:
    spans:
      exclude:
        match_type: strict
        attributes:
          - key: http.target
            value: "/health"
  
  # 3. 减小批处理大小
  batch:
    send_batch_size: 256
```

---

## ⚙️ 配置问题

### 问题7: 配置文件格式错误

#### 症状

```text
❌ Error: cannot load configuration
❌ Error: yaml: line X: mapping values are not allowed
❌ Error: unknown field
```

#### 诊断步骤

```bash
# 1. 验证YAML语法
yamllint otel-config.yaml

# 2. 使用Collector验证配置
docker run --rm \
  -v $(pwd)/otel-config.yaml:/etc/otel-config.yaml \
  otel/opentelemetry-collector-contrib:latest \
  validate --config=/etc/otel-config.yaml

# 3. 检查缩进
# YAML对缩进非常敏感
cat -A otel-config.yaml | head -20
```

#### 解决方案

**方案A: 常见YAML错误**:

```yaml
# ❌ 错误：缩进不一致
receivers:
  otlp:
   protocols:  # 缩进错误
      grpc:

# ✅ 正确：统一缩进（2空格）
receivers:
  otlp:
    protocols:
      grpc:

# ❌ 错误：使用Tab
receivers:
→otlp:  # Tab

# ✅ 正确：使用空格
receivers:
  otlp:  # 2空格
```

**方案B: 字段名错误**:

```yaml
# ❌ 错误字段名
exporters:
  jaeger:
    host: jaeger:14250  # 应该是endpoint

# ✅ 正确
exporters:
  jaeger:
    endpoint: jaeger:14250
```

**方案C: 使用配置验证工具**:

```bash
# 在线验证器
# https://www.yamllint.com/

# VS Code插件
# YAML (Red Hat)
# indent-rainbow

# 命令行工具
pip install yamllint
yamllint otel-config.yaml
```

---

### 问题8: Pipeline配置错误

#### 症状

```text
❌ Error: pipeline "traces" not found
❌ Error: receiver "otlp" not defined
❌ Warning: processor "batch" not used
```

#### 诊断步骤

```bash
# 1. 检查pipeline配置
cat otel-config.yaml | grep -A 20 "service:"

# 2. 确认所有组件都已定义
# receivers, processors, exporters

# 3. 检查组件名称拼写
```

#### 解决方案

**方案A: 完整Pipeline配置**:

```yaml
# 1. 定义组件
receivers:
  otlp:
    protocols:
      grpc:

processors:
  batch:
  memory_limiter:
    limit_mib: 512

exporters:
  jaeger:
    endpoint: jaeger:14250

# 2. 组装Pipeline
service:
  pipelines:
    traces:
      receivers: [otlp]       # ✅ 必须在receivers中定义
      processors: [memory_limiter, batch]  # ✅ 顺序重要
      exporters: [jaeger]     # ✅ 必须在exporters中定义
```

**方案B: 多Pipeline配置**:

```yaml
service:
  pipelines:
    # Traces Pipeline
    traces:
      receivers: [otlp, jaeger]
      processors: [batch]
      exporters: [jaeger, elasticsearch]
    
    # Metrics Pipeline
    metrics:
      receivers: [otlp, prometheus]
      processors: [batch]
      exporters: [prometheus]
    
    # Logs Pipeline
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [elasticsearch]
```

---

## 🔗 SDK问题

### 问题9: SDK初始化失败

#### 症状

```text
❌ Error: failed to create tracer provider
❌ Error: nil tracer
❌ Panic: runtime error
```

#### 诊断步骤

```bash
# 1. 检查SDK版本
go list -m go.opentelemetry.io/otel
# 或
pip show opentelemetry-api

# 2. 检查初始化代码
# 确保在main函数中正确初始化

# 3. 检查依赖版本兼容性
go mod graph | grep otel
```

#### 解决方案

**方案A: 正确的初始化顺序**:

```go
func main() {
    ctx := context.Background()
    
    // 1. 创建Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // 2. 创建Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("my-service"),
        ),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // 3. 创建TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
    )
    
    // 4. 设置全局Provider
    otel.SetTracerProvider(tp)
    
    // 5. 确保Shutdown
    defer func() {
        if err := tp.Shutdown(ctx); err != nil {
            log.Printf("Error shutting down tracer provider: %v", err)
        }
    }()
    
    // 6. 获取Tracer
    tracer := otel.Tracer("my-instrumentation")
    
    // 现在可以使用tracer
}
```

**方案B: 版本兼容性**:

```go
// go.mod
module myapp

go 1.21

require (
    go.opentelemetry.io/otel v1.21.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.21.0
    go.opentelemetry.io/otel/sdk v1.21.0
)

// ✅ 确保所有otel包版本一致
```

---

## 📝 最佳实践建议

### 日志记录

```go
// 启用详细日志
import "go.opentelemetry.io/otel/sdk/trace"

tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter),
    // 开发环境启用详细日志
    sdktrace.WithSampler(sdktrace.AlwaysSample()),
)
```

### 健康检查

```yaml
# Kubernetes liveness probe
livenessProbe:
  httpGet:
    path: /
    port: 13133
  initialDelaySeconds: 10
  periodSeconds: 10
```

### 监控指标

```bash
# 关键指标
curl http://localhost:8888/metrics | grep -E \
  "otelcol_receiver_accepted_spans|otelcol_exporter_sent_spans|otelcol_processor_batch_batch_send_size"
```

---

## 🔗 相关资源

- [PROJECT_DASHBOARD.md](PROJECT_DASHBOARD.md) - 项目仪表板
- [🎯 5分钟快速入门](🎯_5分钟快速入门指南.md) - 快速开始
- [Collector配置示例](examples/collector-configurations/README.md) - 配置参考

---

**更新时间**: 2025年10月20日  
**版本**: v1.0.0  
**维护者**: OTLP项目团队

---

**🔧 遇到问题？参考本手册快速解决！** 🚀
