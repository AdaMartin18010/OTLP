# ğŸ§ª OTLPè‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·å®Œæ•´æŒ‡å—

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´12æœˆ
> **æ–‡æ¡£ç±»å‹**: å·¥å…·æŒ‡å—
> **é¢„ä¼°ç¯‡å¹…**: 2,000+ è¡Œ

---

## ğŸ“‹ ç›®å½•

- [OTLPè‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·å®Œæ•´æŒ‡å—](#otlpè‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·å®Œæ•´æŒ‡å—)
  - [ç¬¬ä¸€éƒ¨åˆ†: å·¥å…·æ¦‚è¿°](#ç¬¬ä¸€éƒ¨åˆ†-å·¥å…·æ¦‚è¿°)
  - [ç¬¬äºŒéƒ¨åˆ†: å•å…ƒæµ‹è¯•å·¥å…·](#ç¬¬äºŒéƒ¨åˆ†-å•å…ƒæµ‹è¯•å·¥å…·)
  - [ç¬¬ä¸‰éƒ¨åˆ†: é›†æˆæµ‹è¯•å·¥å…·](#ç¬¬ä¸‰éƒ¨åˆ†-é›†æˆæµ‹è¯•å·¥å…·)
  - [ç¬¬å››éƒ¨åˆ†: ç«¯åˆ°ç«¯æµ‹è¯•å·¥å…·](#ç¬¬å››éƒ¨åˆ†-ç«¯åˆ°ç«¯æµ‹è¯•å·¥å…·)
  - [ç¬¬äº”éƒ¨åˆ†: æ€§èƒ½æµ‹è¯•å·¥å…·](#ç¬¬äº”éƒ¨åˆ†-æ€§èƒ½æµ‹è¯•å·¥å…·)
  - [ç¬¬å…­éƒ¨åˆ†: åè®®éªŒè¯å·¥å…·](#ç¬¬å…­éƒ¨åˆ†-åè®®éªŒè¯å·¥å…·)
  - [ç¬¬ä¸ƒéƒ¨åˆ†: é…ç½®éªŒè¯å·¥å…·](#ç¬¬ä¸ƒéƒ¨åˆ†-é…ç½®éªŒè¯å·¥å…·)
  - [ç¬¬å…«éƒ¨åˆ†: æµ‹è¯•æ•°æ®ç”Ÿæˆå·¥å…·](#ç¬¬å…«éƒ¨åˆ†-æµ‹è¯•æ•°æ®ç”Ÿæˆå·¥å…·)

---

## ç¬¬ä¸€éƒ¨åˆ†: å·¥å…·æ¦‚è¿°

### 1.1 å·¥å…·åˆ†ç±»

```text
OTLPæµ‹è¯•å·¥å…·ä½“ç³»:
  â”œâ”€ å•å…ƒæµ‹è¯•å·¥å…·
  â”‚   â”œâ”€ è¯­è¨€ç‰¹å®šæµ‹è¯•æ¡†æ¶
  â”‚   â”œâ”€ Mockå·¥å…·
  â”‚   â””â”€ è¦†ç›–ç‡å·¥å…·
  â”‚
  â”œâ”€ é›†æˆæµ‹è¯•å·¥å…·
  â”‚   â”œâ”€ Testcontainers
  â”‚   â”œâ”€ Docker Compose
  â”‚   â””â”€ Kubernetesæµ‹è¯•å·¥å…·
  â”‚
  â”œâ”€ ç«¯åˆ°ç«¯æµ‹è¯•å·¥å…·
  â”‚   â”œâ”€ è¿½è¸ªéªŒè¯å·¥å…·
  â”‚   â”œâ”€ é“¾è·¯å®Œæ•´æ€§å·¥å…·
  â”‚   â””â”€ æ•°æ®ä¸€è‡´æ€§å·¥å…·
  â”‚
  â”œâ”€ æ€§èƒ½æµ‹è¯•å·¥å…·
  â”‚   â”œâ”€ è´Ÿè½½æµ‹è¯•å·¥å…·
  â”‚   â”œâ”€ åŸºå‡†æµ‹è¯•å·¥å…·
  â”‚   â””â”€ æ€§èƒ½åˆ†æå·¥å…·
  â”‚
  â””â”€ åè®®éªŒè¯å·¥å…·
      â”œâ”€ OTLPåè®®éªŒè¯å™¨
      â”œâ”€ è¯­ä¹‰çº¦å®šéªŒè¯å™¨
      â””â”€ å…¼å®¹æ€§æµ‹è¯•å·¥å…·
```

---

## ç¬¬äºŒéƒ¨åˆ†: å•å…ƒæµ‹è¯•å·¥å…·

### 2.1 Goæµ‹è¯•å·¥å…·

#### æµ‹è¯•æ¡†æ¶

```go
// otlp_go_test.go - Goå•å…ƒæµ‹è¯•ç¤ºä¾‹
package otlp

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestSpanCreation(t *testing.T) {
    tracer := NewTracer("test-service")
    ctx := context.Background()

    ctx, span := tracer.Start(ctx, "test-operation")
    defer span.End()

    assert.NotNil(t, span)
    assert.Equal(t, "test-operation", span.Name())
}

// Mock Exporter
type MockExporter struct {
    mock.Mock
}

func (m *MockExporter) ExportSpans(ctx context.Context, spans []Span) error {
    args := m.Called(ctx, spans)
    return args.Error(0)
}

func TestExporter(t *testing.T) {
    mockExporter := new(MockExporter)
    mockExporter.On("ExportSpans", mock.Anything, mock.Anything).Return(nil)

    exporter := NewOTLPExporter(mockExporter)
    err := exporter.Export(context.Background(), []Span{})

    assert.NoError(t, err)
    mockExporter.AssertExpectations(t)
}
```

### 2.2 Pythonæµ‹è¯•å·¥å…·

#### pytesté…ç½®

```python
# pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    --cov=src
    --cov-report=html
    --cov-report=term
    --cov-report=xml
    -v
```

#### æµ‹è¯•ç¤ºä¾‹

```python
# test_otlp_sdk.py
import pytest
from unittest.mock import Mock, patch
from opentelemetry import trace

def test_span_creation():
    tracer = trace.get_tracer("test-service")

    with tracer.start_as_current_span("test-operation") as span:
        assert span.is_recording()
        assert span.name == "test-operation"

@pytest.fixture
def mock_exporter():
    return Mock()

def test_exporter_export(mock_exporter):
    spans = [create_test_span()]
    mock_exporter.export.return_value = None

    exporter = OTLPExporter(mock_exporter)
    exporter.export(spans)

    mock_exporter.export.assert_called_once()
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: é›†æˆæµ‹è¯•å·¥å…·

### 3.1 Testcontainersé›†æˆ

#### Go Testcontainers

```go
// integration_test.go
package integration

import (
    "testing"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/jaeger"
)

func TestOTLPIntegration(t *testing.T) {
    ctx := context.Background()

    // å¯åŠ¨Jaegerå®¹å™¨
    jaegerContainer, err := jaeger.RunContainer(ctx,
        testcontainers.WithImage("jaegertracing/all-in-one:latest"),
    )
    if err != nil {
        t.Fatal(err)
    }
    defer func() {
        if err := jaegerContainer.Terminate(ctx); err != nil {
            t.Fatal(err)
        }
    }()

    // è·å–Jaegerç«¯ç‚¹
    endpoint, err := jaegerContainer.Endpoint(ctx, "http")
    if err != nil {
        t.Fatal(err)
    }

    // è¿è¡Œæµ‹è¯•
    // ...
}
```

#### Python Testcontainers

```python
# test_integration.py
from testcontainers.jaeger import JaegerContainer
from testcontainers.otel import OtelCollectorContainer

def test_otlp_integration():
    with JaegerContainer("jaegertracing/all-in-one:latest") as jaeger:
        with OtelCollectorContainer() as collector:
            # é…ç½®Collectorè¿æ¥åˆ°Jaeger
            collector.configure(
                exporters={
                    "jaeger": {
                        "endpoint": jaeger.get_http_endpoint()
                    }
                }
            )

            # è¿è¡Œæµ‹è¯•
            # ...
```

### 3.2 Docker Composeæµ‹è¯•

#### docker-compose.test.yml

```yaml
version: '3.8'
services:
  otel-collector:
    image: otel/opentelemetry-collector:latest
    volumes:
      - ./test-config.yaml:/etc/otelcol/config.yaml
    ports:
      - "4317:4317"
      - "4318:4318"

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14250:14250"

  test-runner:
    build: ./test-runner
    depends_on:
      - otel-collector
      - jaeger
    environment:
      - COLLECTOR_ENDPOINT=http://otel-collector:4317
      - JAEGER_ENDPOINT=http://jaeger:16686
```

---

## ç¬¬å››éƒ¨åˆ†: ç«¯åˆ°ç«¯æµ‹è¯•å·¥å…·

### 4.1 è¿½è¸ªéªŒè¯å·¥å…·

#### TraceéªŒè¯å™¨

```python
# trace_validator.py
class TraceValidator:
    """TraceéªŒè¯å™¨"""

    def validate_trace(self, trace: Trace) -> ValidationResult:
        """éªŒè¯Traceå®Œæ•´æ€§"""

        errors = []

        # 1. éªŒè¯Trace IDä¸€è‡´æ€§
        trace_ids = {span.trace_id for span in trace.spans}
        if len(trace_ids) > 1:
            errors.append("Trace IDä¸ä¸€è‡´")

        # 2. éªŒè¯Spanæ ‘ç»“æ„
        if not self._validate_span_tree(trace.spans):
            errors.append("Spanæ ‘ç»“æ„æ— æ•ˆ")

        # 3. éªŒè¯æ—¶é—´æˆ³
        if not self._validate_timestamps(trace.spans):
            errors.append("æ—¶é—´æˆ³æ— æ•ˆ")

        # 4. éªŒè¯å› æœå…³ç³»
        if not self._validate_causality(trace.spans):
            errors.append("å› æœå…³ç³»æ— æ•ˆ")

        return ValidationResult(errors=errors, valid=len(errors) == 0)

    def _validate_span_tree(self, spans: List[Span]) -> bool:
        """éªŒè¯Spanæ ‘ç»“æ„"""

        # æ£€æŸ¥æ˜¯å¦æœ‰æ ¹Span
        root_spans = [s for s in spans if s.parent_span_id is None]
        if len(root_spans) != 1:
            return False

        # æ£€æŸ¥æ‰€æœ‰Spanæ˜¯å¦å¯è¾¾
        span_ids = {s.span_id for s in spans}
        for span in spans:
            if span.parent_span_id and span.parent_span_id not in span_ids:
                return False

        return True
```

### 4.2 é“¾è·¯å®Œæ•´æ€§å·¥å…·

#### é“¾è·¯éªŒè¯å™¨

```python
# link_validator.py
class LinkValidator:
    """é“¾è·¯å®Œæ•´æ€§éªŒè¯å™¨"""

    def validate_link(self, trace: Trace, expected_services: List[str]) -> bool:
        """éªŒè¯æœåŠ¡é“¾è·¯å®Œæ•´æ€§"""

        # è·å–æ‰€æœ‰æœåŠ¡
        services = {span.resource.attributes.get('service.name')
                   for span in trace.spans}

        # æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰é¢„æœŸæœåŠ¡
        missing_services = set(expected_services) - services
        if missing_services:
            print(f"ç¼ºå°‘æœåŠ¡: {missing_services}")
            return False

        return True
```

---

## ç¬¬äº”éƒ¨åˆ†: æ€§èƒ½æµ‹è¯•å·¥å…·

### 5.1 è´Ÿè½½æµ‹è¯•å·¥å…·

#### K6æµ‹è¯•è„šæœ¬

```javascript
// k6_otlp_test.js
import http from 'k6/http';
import { check } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export const options = {
    stages: [
        { duration: '2m', target: 1000 },  // é€æ­¥å¢åŠ åˆ°1000 req/s
        { duration: '5m', target: 1000 },  // ä¿æŒ1000 req/s
        { duration: '2m', target: 0 },     // é€æ­¥å‡å°‘
    ],
    thresholds: {
        'http_req_duration': ['p(99)<100'],  // P99å»¶è¿Ÿ<100ms
        'errors': ['rate<0.01'],              // é”™è¯¯ç‡<1%
    },
};

export default function () {
    const url = 'http://app:8080/api/test';
    const params = {
        headers: {
            'Content-Type': 'application/json',
        },
    };

    const res = http.get(url, params);

    const result = check(res, {
        'status is 200': (r) => r.status === 200,
        'response time < 100ms': (r) => r.timings.duration < 100,
    });

    errorRate.add(!result);
}
```

### 5.2 åŸºå‡†æµ‹è¯•å·¥å…·

#### åŸºå‡†æµ‹è¯•æ¡†æ¶

```python
# benchmark_tool.py
import time
import statistics
from typing import List, Dict

class OTLPBenchmark:
    """OTLPæ€§èƒ½åŸºå‡†æµ‹è¯•å·¥å…·"""

    def benchmark_export(self, exporter, spans: List[Span], iterations: int = 1000) -> Dict:
        """åŸºå‡†æµ‹è¯•å¯¼å‡ºæ€§èƒ½"""

        times = []

        for _ in range(iterations):
            start = time.perf_counter()
            exporter.export(spans)
            end = time.perf_counter()
            times.append((end - start) * 1000)  # è½¬æ¢ä¸ºæ¯«ç§’

        return {
            'mean': statistics.mean(times),
            'median': statistics.median(times),
            'p99': self._percentile(times, 99),
            'p95': self._percentile(times, 95),
            'min': min(times),
            'max': max(times),
            'stddev': statistics.stdev(times),
        }

    def _percentile(self, data: List[float], percentile: int) -> float:
        """è®¡ç®—ç™¾åˆ†ä½æ•°"""
        sorted_data = sorted(data)
        index = int(len(sorted_data) * percentile / 100)
        return sorted_data[index]
```

---

## ç¬¬å…­éƒ¨åˆ†: åè®®éªŒè¯å·¥å…·

### 6.1 OTLPåè®®éªŒè¯å™¨

#### åè®®éªŒè¯å·¥å…·

```python
# otlp_protocol_validator.py
from opentelemetry.proto.trace.v1.trace_pb2 import TracesData

class OTLPProtocolValidator:
    """OTLPåè®®éªŒè¯å™¨"""

    def validate_protobuf(self, data: bytes) -> ValidationResult:
        """éªŒè¯Protobufæ¶ˆæ¯"""

        try:
            traces_data = TracesData()
            traces_data.ParseFromString(data)

            # éªŒè¯æ¶ˆæ¯ç»“æ„
            errors = []

            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if not traces_data.resource_spans:
                errors.append("ç¼ºå°‘resource_spans")

            # éªŒè¯æ¯ä¸ªResourceSpan
            for resource_span in traces_data.resource_spans:
                if not resource_span.resource:
                    errors.append("ç¼ºå°‘resource")

                if not resource_span.scope_spans:
                    errors.append("ç¼ºå°‘scope_spans")

            return ValidationResult(errors=errors, valid=len(errors) == 0)

        except Exception as e:
            return ValidationResult(errors=[str(e)], valid=False)

    def validate_json(self, data: dict) -> ValidationResult:
        """éªŒè¯JSONæ¶ˆæ¯"""

        # éªŒè¯JSONç»“æ„
        # ...
```

### 6.2 è¯­ä¹‰çº¦å®šéªŒè¯å™¨

#### è¯­ä¹‰éªŒè¯å·¥å…·

```python
# semantic_validator.py
class SemanticValidator:
    """è¯­ä¹‰çº¦å®šéªŒè¯å™¨"""

    def __init__(self):
        self.conventions = self._load_conventions()

    def validate_attributes(self, span: Span) -> List[str]:
        """éªŒè¯Spanå±æ€§æ˜¯å¦ç¬¦åˆè¯­ä¹‰çº¦å®š"""

        errors = []

        # æ£€æŸ¥HTTPå±æ€§
        if span.kind == SpanKind.SERVER:
            if 'http.method' not in span.attributes:
                errors.append("SERVER Spanç¼ºå°‘http.methodå±æ€§")

            if 'http.status_code' not in span.attributes:
                errors.append("SERVER Spanç¼ºå°‘http.status_codeå±æ€§")

        # æ£€æŸ¥æ•°æ®åº“å±æ€§
        if 'db.system' in span.attributes:
            if 'db.operation' not in span.attributes:
                errors.append("æ•°æ®åº“Spanç¼ºå°‘db.operationå±æ€§")

        return errors
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†: é…ç½®éªŒè¯å·¥å…·

### 7.1 Collectoré…ç½®éªŒè¯å™¨

#### é…ç½®éªŒè¯å·¥å…·

```python
# collector_config_validator.py
import yaml
import jsonschema

class CollectorConfigValidator:
    """Collectoré…ç½®éªŒè¯å™¨"""

    def __init__(self):
        self.schema = self._load_schema()

    def validate(self, config_path: str) -> ValidationResult:
        """éªŒè¯Collectoré…ç½®"""

        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)

        errors = []
        warnings = []

        # 1. SchemaéªŒè¯
        try:
            jsonschema.validate(config, self.schema)
        except jsonschema.ValidationError as e:
            errors.append(f"SchemaéªŒè¯å¤±è´¥: {e.message}")

        # 2. é€»è¾‘éªŒè¯
        logic_errors = self._validate_logic(config)
        errors.extend(logic_errors)

        # 3. æœ€ä½³å®è·µæ£€æŸ¥
        practice_warnings = self._check_best_practices(config)
        warnings.extend(practice_warnings)

        return ValidationResult(
            errors=errors,
            warnings=warnings,
            valid=len(errors) == 0
        )

    def _validate_logic(self, config: Dict) -> List[str]:
        """é€»è¾‘éªŒè¯"""

        errors = []

        # æ£€æŸ¥Pipelineé…ç½®
        service = config.get('service', {})
        pipelines = service.get('pipelines', {})

        for pipeline_name, pipeline in pipelines.items():
            # æ£€æŸ¥receivers
            receivers = pipeline.get('receivers', [])
            if not receivers:
                errors.append(f"Pipeline {pipeline_name} ç¼ºå°‘receivers")

            # æ£€æŸ¥exporters
            exporters = pipeline.get('exporters', [])
            if not exporters:
                errors.append(f"Pipeline {pipeline_name} ç¼ºå°‘exporters")

            # æ£€æŸ¥receiversæ˜¯å¦å­˜åœ¨
            defined_receivers = config.get('receivers', {})
            for receiver in receivers:
                if receiver not in defined_receivers:
                    errors.append(f"Pipeline {pipeline_name} å¼•ç”¨äº†ä¸å­˜åœ¨çš„receiver: {receiver}")

            # æ£€æŸ¥exportersæ˜¯å¦å­˜åœ¨
            defined_exporters = config.get('exporters', {})
            for exporter in exporters:
                if exporter not in defined_exporters:
                    errors.append(f"Pipeline {pipeline_name} å¼•ç”¨äº†ä¸å­˜åœ¨çš„exporter: {exporter}")

        return errors
```

---

## ç¬¬å…«éƒ¨åˆ†: æµ‹è¯•æ•°æ®ç”Ÿæˆå·¥å…·

### 8.1 Traceç”Ÿæˆå™¨

#### æµ‹è¯•æ•°æ®ç”Ÿæˆ

```python
# trace_generator.py
from faker import Faker
import random
from datetime import datetime, timedelta

class TraceGenerator:
    """Traceæµ‹è¯•æ•°æ®ç”Ÿæˆå™¨"""

    def __init__(self):
        self.fake = Faker()

    def generate_trace(self,
                      service_count: int = 5,
                      spans_per_service: int = 3) -> Trace:
        """ç”Ÿæˆæµ‹è¯•Trace"""

        trace_id = self._generate_trace_id()
        root_span = self._generate_root_span(trace_id)

        spans = [root_span]
        current_span = root_span

        for service_idx in range(service_count):
            for span_idx in range(spans_per_service):
                child_span = self._generate_child_span(
                    trace_id,
                    current_span.span_id,
                    f"service-{service_idx}",
                    f"operation-{span_idx}"
                )
                spans.append(child_span)
                current_span = child_span

        return Trace(trace_id=trace_id, spans=spans)

    def _generate_trace_id(self) -> str:
        """ç”ŸæˆTrace ID"""
        return ''.join(random.choices('0123456789abcdef', k=32))

    def _generate_root_span(self, trace_id: str) -> Span:
        """ç”Ÿæˆæ ¹Span"""
        return Span(
            trace_id=trace_id,
            span_id=self._generate_span_id(),
            parent_span_id=None,
            name="root-operation",
            start_time=datetime.now(),
            end_time=datetime.now() + timedelta(milliseconds=100),
            attributes={
                'service.name': 'frontend',
                'http.method': 'GET',
                'http.url': '/api/users',
            }
        )
```

---

## æ€»ç»“

### å·¥å…·æ¸…å•

| å·¥å…·ç±»å‹ | å·¥å…·åç§° | ç”¨é€” |
|---------|---------|------|
| **å•å…ƒæµ‹è¯•** | pytest, Go testing, JUnit | å‡½æ•°/æ–¹æ³•æµ‹è¯• |
| **é›†æˆæµ‹è¯•** | Testcontainers | ç»„ä»¶é›†æˆæµ‹è¯• |
| **E2Eæµ‹è¯•** | Playwright, K6 | ç«¯åˆ°ç«¯æµ‹è¯• |
| **æ€§èƒ½æµ‹è¯•** | K6, JMeter, Gatling | è´Ÿè½½å’Œæ€§èƒ½æµ‹è¯• |
| **åè®®éªŒè¯** | OTLP Protocol Validator | åè®®ä¸€è‡´æ€§éªŒè¯ |
| **é…ç½®éªŒè¯** | Collector Config Validator | é…ç½®æ­£ç¡®æ€§éªŒè¯ |
| **æ•°æ®ç”Ÿæˆ** | Trace Generator | æµ‹è¯•æ•°æ®ç”Ÿæˆ |

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ (2,000+ è¡Œ)
**æœ€åæ›´æ–°**: 2025å¹´12æœˆ
**ç»´æŠ¤è€…**: OTLPé¡¹ç›®ç»„
