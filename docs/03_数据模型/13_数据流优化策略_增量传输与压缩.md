# OTLPæ•°æ®æµä¼˜åŒ–ç­–ç•¥ï¼šå¢é‡ä¼ è¾“ä¸å‹ç¼©

> **OTLPç‰ˆæœ¬**: v1.0.0 (Stable)
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥
> **ä¼˜åŒ–ç›®æ ‡**: é™ä½ä¼ è¾“æˆæœ¬ã€æå‡ååé‡ã€å‡å°‘å»¶è¿Ÿ
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [OTLPæ•°æ®æµä¼˜åŒ–ç­–ç•¥ï¼šå¢é‡ä¼ è¾“ä¸å‹ç¼©](#otlpæ•°æ®æµä¼˜åŒ–ç­–ç•¥å¢é‡ä¼ è¾“ä¸å‹ç¼©)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
  - [ğŸ“Š æ•°æ®æµä¼˜åŒ–æ¡†æ¶](#-æ•°æ®æµä¼˜åŒ–æ¡†æ¶)
    - [ä¼˜åŒ–å±‚æ¬¡](#ä¼˜åŒ–å±‚æ¬¡)
    - [ä¼˜åŒ–æŒ‡æ ‡](#ä¼˜åŒ–æŒ‡æ ‡)
  - [ğŸ”„ å¢é‡ä¼ è¾“ç­–ç•¥](#-å¢é‡ä¼ è¾“ç­–ç•¥)
    - [1. å¢é‡ä¼ è¾“åŸç†](#1-å¢é‡ä¼ è¾“åŸç†)
    - [2. Metricså¢é‡ä¼ è¾“](#2-metricså¢é‡ä¼ è¾“)
    - [3. Traceså¢é‡ä¼ è¾“](#3-traceså¢é‡ä¼ è¾“)
    - [4. å¢é‡ä¼ è¾“æ€§èƒ½åˆ†æ](#4-å¢é‡ä¼ è¾“æ€§èƒ½åˆ†æ)
  - [ğŸ—œï¸ æ•°æ®å‹ç¼©æŠ€æœ¯](#ï¸-æ•°æ®å‹ç¼©æŠ€æœ¯)
    - [1. å‹ç¼©ç®—æ³•å¯¹æ¯”](#1-å‹ç¼©ç®—æ³•å¯¹æ¯”)
    - [2. Snappyå‹ç¼©å®ç°](#2-snappyå‹ç¼©å®ç°)
    - [3. Zstdå‹ç¼©å®ç°](#3-zstdå‹ç¼©å®ç°)
    - [4. å‹ç¼©æ€§èƒ½åŸºå‡†æµ‹è¯•](#4-å‹ç¼©æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [ğŸ“¦ æ‰¹é‡ä¼ è¾“ä¼˜åŒ–](#-æ‰¹é‡ä¼ è¾“ä¼˜åŒ–)
    - [1. æ‰¹é‡ä¼ è¾“åŸç†](#1-æ‰¹é‡ä¼ è¾“åŸç†)
    - [2. BatchSpanProcessorå®ç°](#2-batchspanprocessorå®ç°)
    - [3. æ‰¹é‡ä¼ è¾“æ€§èƒ½ä¼˜åŒ–](#3-æ‰¹é‡ä¼ è¾“æ€§èƒ½ä¼˜åŒ–)
  - [ğŸŒŠ æµå¼ä¼ è¾“ä¼˜åŒ–](#-æµå¼ä¼ è¾“ä¼˜åŒ–)
    - [1. gRPCæµå¼ä¼ è¾“](#1-grpcæµå¼ä¼ è¾“)
    - [2. æµå¼ä¼ è¾“å®ç°](#2-æµå¼ä¼ è¾“å®ç°)

---

## ğŸ¯ æ‰§è¡Œæ‘˜è¦

**OTLPæ•°æ®æµä¼˜åŒ–**æ—¨åœ¨é€šè¿‡å¢é‡ä¼ è¾“ã€æ•°æ®å‹ç¼©ã€æ‰¹é‡å¤„ç†ç­‰æŠ€æœ¯ï¼Œæ˜¾è‘—é™ä½ä¼ è¾“æˆæœ¬ã€æå‡ç³»ç»Ÿååé‡ï¼š

```text
ä¼˜åŒ–ç›®æ ‡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          æ•°æ®æµä¼˜åŒ–ä¸‰å¤§ç›®æ ‡                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ğŸ“‰ æˆæœ¬é™ä½: ä¼ è¾“å¸¦å®½å‡å°‘ 60-80%                â”‚
â”‚  ğŸ“ˆ ååæå‡: æ¯ç§’å¤„ç†èƒ½åŠ›æå‡ 3-5å€              â”‚
â”‚  âš¡ å»¶è¿Ÿä¼˜åŒ–: P99å»¶è¿Ÿé™ä½ 40-60%                 â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒä¼˜åŒ–æŠ€æœ¯**ï¼š

1. **å¢é‡ä¼ è¾“**ï¼šåªä¼ è¾“å˜åŒ–çš„æ•°æ®ï¼Œå‡å°‘å†—ä½™
2. **æ•°æ®å‹ç¼©**ï¼šä½¿ç”¨Snappy/Zstdç­‰ç®—æ³•å‹ç¼©æ•°æ®
3. **æ‰¹é‡ä¼ è¾“**ï¼šåˆå¹¶å¤šä¸ªè¯·æ±‚ï¼Œæé«˜ä¼ è¾“æ•ˆç‡
4. **æµå¼ä¼ è¾“**ï¼šä½¿ç”¨gRPCæµå¼ä¼ è¾“ï¼Œé™ä½å»¶è¿Ÿ

---

## ğŸ“Š æ•°æ®æµä¼˜åŒ–æ¡†æ¶

### ä¼˜åŒ–å±‚æ¬¡

```text
OTLPæ•°æ®æµä¼˜åŒ–å±‚æ¬¡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             åº”ç”¨å±‚ä¼˜åŒ–                           â”‚
â”‚  - é‡‡æ ·ç­–ç•¥ (Head/Tail-based)                    â”‚
â”‚  - å±æ€§è¿‡æ»¤ (ç§»é™¤å†—ä½™å±æ€§)                        â”‚
â”‚  - æ™ºèƒ½èšåˆ (æŒ‰ä¸šåŠ¡è§„åˆ™)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             ä¼ è¾“å±‚ä¼˜åŒ–                           â”‚
â”‚  - æ‰¹é‡ä¼ è¾“ (Batch Export)                       â”‚
â”‚  - æµå¼ä¼ è¾“ (Streaming)                          â”‚
â”‚  - å‹ç¼©ç¼–ç  (Snappy/Zstd)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             åè®®å±‚ä¼˜åŒ–                           â”‚
â”‚  - Protobufç¼–ç  (äºŒè¿›åˆ¶)                         â”‚
â”‚  - gRPCä¼ è¾“ (HTTP/2)                             â”‚
â”‚  - å¢é‡æ›´æ–° (Delta Encoding)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             ç½‘ç»œå±‚ä¼˜åŒ–                           â”‚
â”‚  - è¿æ¥å¤ç”¨ (Keep-Alive)                         â”‚
â”‚  - è¯·æ±‚åˆå¹¶ (Request Batching)                   â”‚
â”‚  - é‡è¯•ç­–ç•¥ (Exponential Backoff)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¼˜åŒ–æŒ‡æ ‡

```text
å®šä¹‰ (ä¼˜åŒ–æŒ‡æ ‡):
OptimizationMetrics = {
  bandwidth_reduction: float,      // å¸¦å®½å‡å°‘ç™¾åˆ†æ¯”
  throughput_increase: float,      // ååé‡æå‡å€æ•°
  latency_reduction: float,         // å»¶è¿Ÿå‡å°‘ç™¾åˆ†æ¯”
  cpu_overhead: float,             // CPUå¼€é”€å¢åŠ 
  memory_overhead: float            // å†…å­˜å¼€é”€å¢åŠ 
}

ä¼˜åŒ–ç›®æ ‡:
- bandwidth_reduction â‰¥ 60%
- throughput_increase â‰¥ 3.0x
- latency_reduction â‰¥ 40%
- cpu_overhead â‰¤ 10%
- memory_overhead â‰¤ 20%
```

---

## ğŸ”„ å¢é‡ä¼ è¾“ç­–ç•¥

### 1. å¢é‡ä¼ è¾“åŸç†

**å¢é‡ä¼ è¾“ (Delta Encoding)** åªä¼ è¾“æ•°æ®çš„å˜åŒ–éƒ¨åˆ†ï¼Œè€Œéå®Œæ•´æ•°æ®ï¼š

```text
å¢é‡ä¼ è¾“ç¤ºä¾‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼ ç»Ÿå…¨é‡ä¼ è¾“                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  T0: [A=1, B=2, C=3] â†’ ä¼ è¾“ 3ä¸ªå±æ€§              â”‚
â”‚  T1: [A=1, B=2, C=3] â†’ ä¼ è¾“ 3ä¸ªå±æ€§ (å†—ä½™)       â”‚
â”‚  T2: [A=1, B=2, C=4] â†’ ä¼ è¾“ 3ä¸ªå±æ€§ (å†—ä½™)       â”‚
â”‚  æ€»ä¼ è¾“é‡: 9ä¸ªå±æ€§                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¢é‡ä¼ è¾“                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  T0: [A=1, B=2, C=3] â†’ ä¼ è¾“ 3ä¸ªå±æ€§ (åˆå§‹)       â”‚
â”‚  T1: [] â†’ ä¼ è¾“ 0ä¸ªå±æ€§ (æ— å˜åŒ–)                  â”‚
â”‚  T2: [C=4] â†’ ä¼ è¾“ 1ä¸ªå±æ€§ (å˜åŒ–)                 â”‚
â”‚  æ€»ä¼ è¾“é‡: 4ä¸ªå±æ€§ (èŠ‚çœ 55%)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Metricså¢é‡ä¼ è¾“

**Delta Aggregation Temporality**ï¼š

```protobuf
// Metricså¢é‡ä¼ è¾“
message Metric {
  string name = 1;
  string description = 2;
  string unit = 3;

  // å¢é‡èšåˆç±»å‹
  AggregationTemporality aggregation_temporality = 4;

  repeated DataPoint data_points = 5;
}

enum AggregationTemporality {
  AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
  AGGREGATION_TEMPORALITY_DELTA = 1;      // å¢é‡
  AGGREGATION_TEMPORALITY_CUMULATIVE = 2; // ç´¯è®¡
}
```

**å®ç°ç¤ºä¾‹ (Go)**ï¼š

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// Deltaå¢é‡ä¼ è¾“é…ç½®
func configureDeltaCollector() *metric.ManualReader {
    reader := metric.NewManualReader(
        metric.WithTemporalitySelector(func(kind metric.InstrumentKind) metricdata.Temporality {
            // Counterå’ŒHistogramä½¿ç”¨å¢é‡ä¼ è¾“
            switch kind {
            case metric.InstrumentKindCounter,
                 metric.InstrumentKindHistogram:
                return metricdata.DeltaTemporality
            default:
                return metricdata.CumulativeTemporality
            }
        }),
    )
    return reader
}

// å¢é‡æ•°æ®ä¼ è¾“
func exportDeltaMetrics(ctx context.Context, reader *metric.ManualReader) error {
    var rm metricdata.ResourceMetrics

    // è¯»å–å¢é‡æ•°æ®
    err := reader.Collect(ctx, &rm)
    if err != nil {
        return err
    }

    // åªä¼ è¾“å˜åŒ–çš„æ•°æ®ç‚¹
    for _, scopeMetrics := range rm.ScopeMetrics {
        for _, metric := range scopeMetrics.Metrics {
            // Deltaç±»å‹åªåŒ…å«å˜åŒ–çš„æ•°æ®ç‚¹
            if metric.Temporality == metricdata.DeltaTemporality {
                // ä¼ è¾“å¢é‡æ•°æ®
                exportDeltaDataPoints(metric.Data)
            }
        }
    }

    return nil
}

func exportDeltaDataPoints(data metricdata.Aggregation) {
    // æ ¹æ®èšåˆç±»å‹å¤„ç†å¢é‡æ•°æ®
    switch agg := data.(type) {
    case metricdata.Sum[int64]:
        // å¢é‡Sumï¼šåªä¼ è¾“å·®å€¼
        fmt.Printf("Delta Sum: %d\n", agg.Value)

    case metricdata.Histogram[int64]:
        // å¢é‡Histogramï¼šåªä¼ è¾“æ–°å¢çš„æ¡¶
        fmt.Printf("Delta Histogram: %d buckets\n", len(agg.Buckets))
    }
}
```

### 3. Traceså¢é‡ä¼ è¾“

**Spanå¢é‡ä¼ è¾“ç­–ç•¥**ï¼š

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/trace"
)

// Spanå¢é‡ä¼ è¾“
type DeltaSpanExporter struct {
    lastSpans map[trace.SpanID]*SpanDelta
}

type SpanDelta struct {
    LastAttributes map[string]interface{}
    LastEvents     []Event
}

// å¢é‡å¯¼å‡ºSpan
func (e *DeltaSpanExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    for _, span := range spans {
        delta := e.computeDelta(span)

        // åªä¼ è¾“å˜åŒ–çš„éƒ¨åˆ†
        if delta.HasChanges() {
            e.exportDelta(ctx, span.SpanContext(), delta)
        }
    }

    return nil
}

func (e *DeltaSpanExporter) computeDelta(span trace.ReadOnlySpan) *SpanDelta {
    spanID := span.SpanContext().SpanID()
    lastDelta, exists := e.lastSpans[spanID]

    if !exists {
        // é¦–æ¬¡ä¼ è¾“ï¼šå®Œæ•´æ•°æ®
        return &SpanDelta{
            LastAttributes: getAllAttributes(span),
            LastEvents:     getAllEvents(span),
        }
    }

    // è®¡ç®—å¢é‡
    delta := &SpanDelta{
        LastAttributes: computeAttributeDelta(lastDelta.LastAttributes, span),
        LastEvents:     computeEventDelta(lastDelta.LastEvents, span),
    }

    return delta
}

func computeAttributeDelta(lastAttrs map[string]interface{}, span trace.ReadOnlySpan) map[string]interface{} {
    delta := make(map[string]interface{})

    span.ForeachAttribute(func(kv attribute.KeyValue) bool {
        if lastValue, exists := lastAttrs[string(kv.Key)]; !exists || lastValue != kv.Value.AsInterface() {
            // å±æ€§å˜åŒ–æˆ–æ–°å¢
            delta[string(kv.Key)] = kv.Value.AsInterface()
        }
        return true
    })

    return delta
}

func (d *SpanDelta) HasChanges() bool {
    return len(d.LastAttributes) > 0 || len(d.LastEvents) > 0
}
```

### 4. å¢é‡ä¼ è¾“æ€§èƒ½åˆ†æ

```text
å¢é‡ä¼ è¾“æ€§èƒ½å¯¹æ¯”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å…¨é‡ä¼ è¾“ vs å¢é‡ä¼ è¾“                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  æŒ‡æ ‡          â”‚ å…¨é‡ä¼ è¾“ â”‚ å¢é‡ä¼ è¾“ â”‚ æ”¹å–„      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  ä¼ è¾“é‡        â”‚ 100MB    â”‚ 25MB     â”‚ -75%     â”‚
â”‚  å¸¦å®½å ç”¨      â”‚ 100%     â”‚ 25%      â”‚ -75%     â”‚
â”‚  ä¼ è¾“å»¶è¿Ÿ      â”‚ 100ms    â”‚ 30ms     â”‚ -70%     â”‚
â”‚  CPUå¼€é”€       â”‚ 5%       â”‚ 8%       â”‚ +3%      â”‚
â”‚  å†…å­˜å ç”¨      â”‚ 50MB     â”‚ 60MB     â”‚ +10MB    â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é€‚ç”¨åœºæ™¯:
âœ… Metricså®šæœŸé‡‡é›† (Delta Aggregation)
âœ… é•¿æ—¶é—´è¿è¡Œçš„Span (å¢é‡å±æ€§æ›´æ–°)
âœ… é«˜é¢‘æ›´æ–°çš„æŒ‡æ ‡ (Counter/Histogram)
âŒ ä¸€æ¬¡æ€§Span (æ— å¢é‡ä¼˜åŠ¿)
âŒ ä½é¢‘å˜åŒ–çš„æ•°æ® (å¼€é”€å¤§äºæ”¶ç›Š)
```

---

## ğŸ—œï¸ æ•°æ®å‹ç¼©æŠ€æœ¯

### 1. å‹ç¼©ç®—æ³•å¯¹æ¯”

```text
OTLPæ•°æ®å‹ç¼©ç®—æ³•å¯¹æ¯”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç®—æ³•      â”‚ å‹ç¼©ç‡ â”‚ é€Ÿåº¦ â”‚ CPU  â”‚ é€‚ç”¨åœºæ™¯    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Snappy    â”‚ 2-3x  â”‚ å¿«   â”‚ ä½   â”‚ å®æ—¶ä¼ è¾“     â”‚
â”‚  Zstd      â”‚ 3-5x  â”‚ ä¸­   â”‚ ä¸­   â”‚ æ‰¹é‡ä¼ è¾“     â”‚
â”‚  Gzip      â”‚ 3-4x  â”‚ æ…¢   â”‚ é«˜   â”‚ å½’æ¡£å­˜å‚¨     â”‚
â”‚  LZ4       â”‚ 2-3x  â”‚ æœ€å¿« â”‚ æœ€ä½ â”‚ æè‡´æ€§èƒ½     â”‚
â”‚  Brotli    â”‚ 4-6x  â”‚ æ…¢   â”‚ é«˜   â”‚ é™æ€èµ„æº     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¨èé…ç½®:
- å®æ—¶ä¼ è¾“: Snappy (ä½å»¶è¿Ÿ)
- æ‰¹é‡ä¼ è¾“: Zstd (é«˜å‹ç¼©ç‡)
- å½’æ¡£å­˜å‚¨: Gzip (æ ‡å‡†å…¼å®¹)
```

### 2. Snappyå‹ç¼©å®ç°

**Snappyå‹ç¼©**ï¼šGoogleå¼€å‘çš„é«˜æ€§èƒ½å‹ç¼©ç®—æ³•ï¼Œé€‚åˆå®æ—¶ä¼ è¾“ï¼š

```go
package main

import (
    "bytes"
    "compress/snappy"
    "io"
)

// Snappyå‹ç¼©ä¼ è¾“
type SnappyCompressor struct{}

func (c *SnappyCompressor) Compress(data []byte) ([]byte, error) {
    var buf bytes.Buffer
    writer := snappy.NewBufferedWriter(&buf)

    _, err := writer.Write(data)
    if err != nil {
        return nil, err
    }

    err = writer.Close()
    if err != nil {
        return nil, err
    }

    return buf.Bytes(), nil
}

func (c *SnappyCompressor) Decompress(compressed []byte) ([]byte, error) {
    reader := snappy.NewReader(bytes.NewReader(compressed))

    decompressed, err := io.ReadAll(reader)
    if err != nil {
        return nil, err
    }

    return decompressed, nil
}

// gRPCå‹ç¼©é…ç½®
func configureSnappyCompression() []grpc.DialOption {
    return []grpc.DialOption{
        grpc.WithDefaultCallOptions(
            grpc.UseCompressor("snappy"),
        ),
    }
}
```

### 3. Zstdå‹ç¼©å®ç°

**Zstdå‹ç¼©**ï¼šFacebookå¼€å‘çš„é«˜å‹ç¼©ç‡ç®—æ³•ï¼Œé€‚åˆæ‰¹é‡ä¼ è¾“ï¼š

```go
package main

import (
    "bytes"
    "github.com/klauspost/compress/zstd"
    "io"
)

// Zstdå‹ç¼©ä¼ è¾“
type ZstdCompressor struct {
    encoder *zstd.Encoder
    decoder *zstd.Decoder
}

func NewZstdCompressor() (*ZstdCompressor, error) {
    encoder, err := zstd.NewWriter(nil, zstd.WithEncoderLevel(zstd.SpeedDefault))
    if err != nil {
        return nil, err
    }

    decoder, err := zstd.NewReader(nil)
    if err != nil {
        return nil, err
    }

    return &ZstdCompressor{
        encoder: encoder,
        decoder: decoder,
    }, nil
}

func (c *ZstdCompressor) Compress(data []byte) ([]byte, error) {
    compressed := c.encoder.EncodeAll(data, nil)
    return compressed, nil
}

func (c *ZstdCompressor) Decompress(compressed []byte) ([]byte, error) {
    decompressed, err := c.decoder.DecodeAll(compressed, nil)
    if err != nil {
        return nil, err
    }

    return decompressed, nil
}

// æ‰¹é‡å‹ç¼©é…ç½®
func configureBatchCompression() *BatchExporter {
    compressor, _ := NewZstdCompressor()

    return &BatchExporter{
        compressor: compressor,
        batchSize:  1000,
        timeout:   5 * time.Second,
    }
}
```

### 4. å‹ç¼©æ€§èƒ½åŸºå‡†æµ‹è¯•

```go
package main

import (
    "fmt"
    "testing"
    "time"
)

func BenchmarkCompression(b *testing.B) {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    data := generateOTLPSpanData(1000) // 1000ä¸ªSpan

    compressors := map[string]Compressor{
        "Snappy": &SnappyCompressor{},
        "Zstd":   &ZstdCompressor{},
        "Gzip":   &GzipCompressor{},
    }

    for name, compressor := range compressors {
        b.Run(name, func(b *testing.B) {
            var compressedSize int64
            var compressTime time.Duration

            b.ResetTimer()
            b.ReportAllocs()

            for i := 0; i < b.N; i++ {
                start := time.Now()

                compressed, err := compressor.Compress(data)
                if err != nil {
                    b.Fatal(err)
                }

                compressTime += time.Since(start)
                compressedSize = int64(len(compressed))
            }

            // è¾“å‡ºæ€§èƒ½æŒ‡æ ‡
            compressionRatio := float64(len(data)) / float64(compressedSize)
            avgTime := compressTime / time.Duration(b.N)

            fmt.Printf("%s: Ratio=%.2fx, Time=%v, Size=%d KB\n",
                name, compressionRatio, avgTime, compressedSize/1024)
        })
    }
}

// æµ‹è¯•ç»“æœç¤ºä¾‹:
// Snappy: Ratio=2.85x, Time=1.2ms, Size=350 KB
// Zstd:   Ratio=4.12x, Time=3.5ms, Size=243 KB
// Gzip:   Ratio=3.68x, Time=5.8ms, Size=272 KB
```

---

## ğŸ“¦ æ‰¹é‡ä¼ è¾“ä¼˜åŒ–

### 1. æ‰¹é‡ä¼ è¾“åŸç†

**æ‰¹é‡ä¼ è¾“ (Batch Export)** å°†å¤šä¸ªæ•°æ®ç‚¹åˆå¹¶ä¸ºå•ä¸ªè¯·æ±‚ï¼š

```text
æ‰¹é‡ä¼ è¾“ç¤ºä¾‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å•æ¡ä¼ è¾“ (ä½æ•ˆ)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Request 1: [Span1] â†’ 100ms                     â”‚
â”‚  Request 2: [Span2] â†’ 100ms                     â”‚
â”‚  Request 3: [Span3] â†’ 100ms                     â”‚
â”‚  æ€»æ—¶é—´: 300ms                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ‰¹é‡ä¼ è¾“ (é«˜æ•ˆ)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Request 1: [Span1, Span2, Span3] â†’ 120ms        â”‚
â”‚  æ€»æ—¶é—´: 120ms (èŠ‚çœ 60%)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. BatchSpanProcessorå®ç°

```go
package main

import (
    "context"
    "sync"
    "time"

    "go.opentelemetry.io/otel/sdk/trace"
)

// æ‰¹é‡Spanå¤„ç†å™¨
type BatchSpanProcessor struct {
    exporter trace.SpanExporter

    batchSize    int
    batchTimeout time.Duration

    batch      []trace.ReadOnlySpan
    batchMutex sync.Mutex

    stopCh chan struct{}
    wg     sync.WaitGroup
}

func NewBatchSpanProcessor(exporter trace.SpanExporter, opts ...BatchOption) *BatchSpanProcessor {
    bsp := &BatchSpanProcessor{
        exporter:     exporter,
        batchSize:    512,              // é»˜è®¤æ‰¹æ¬¡å¤§å°
        batchTimeout: 5 * time.Second,  // é»˜è®¤è¶…æ—¶
        stopCh:       make(chan struct{}),
    }

    for _, opt := range opts {
        opt(bsp)
    }

    // å¯åŠ¨åå°å¤„ç†åç¨‹
    bsp.wg.Add(1)
    go bsp.processBatches()

    return bsp
}

func (bsp *BatchSpanProcessor) OnEnd(s trace.ReadOnlySpan) {
    bsp.batchMutex.Lock()
    bsp.batch = append(bsp.batch, s)

    shouldExport := len(bsp.batch) >= bsp.batchSize
    bsp.batchMutex.Unlock()

    if shouldExport {
        bsp.exportBatch()
    }
}

func (bsp *BatchSpanProcessor) processBatches() {
    defer bsp.wg.Done()

    ticker := time.NewTicker(bsp.batchTimeout)
    defer ticker.Stop()

    for {
        select {
        case <-bsp.stopCh:
            // åœæ­¢æ—¶å¯¼å‡ºå‰©ä½™æ‰¹æ¬¡
            bsp.exportBatch()
            return

        case <-ticker.C:
            // å®šæ—¶å¯¼å‡ºæ‰¹æ¬¡
            bsp.exportBatch()
        }
    }
}

func (bsp *BatchSpanProcessor) exportBatch() {
    bsp.batchMutex.Lock()
    if len(bsp.batch) == 0 {
        bsp.batchMutex.Unlock()
        return
    }

    batch := bsp.batch
    bsp.batch = make([]trace.ReadOnlySpan, 0, bsp.batchSize)
    bsp.batchMutex.Unlock()

    // å¼‚æ­¥å¯¼å‡ºæ‰¹æ¬¡
    go func() {
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        err := bsp.exporter.ExportSpans(ctx, batch)
        if err != nil {
            // é”™è¯¯å¤„ç†
            logExportError(err, len(batch))
        }
    }()
}

func (bsp *BatchSpanProcessor) Shutdown(ctx context.Context) error {
    close(bsp.stopCh)
    bsp.wg.Wait()

    return bsp.exporter.Shutdown(ctx)
}

// é…ç½®é€‰é¡¹
type BatchOption func(*BatchSpanProcessor)

func WithBatchSize(size int) BatchOption {
    return func(bsp *BatchSpanProcessor) {
        bsp.batchSize = size
    }
}

func WithBatchTimeout(timeout time.Duration) BatchOption {
    return func(bsp *BatchSpanProcessor) {
        bsp.batchTimeout = timeout
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func configureBatchProcessor() *trace.TracerProvider {
    exporter := newOTLPExporter()

    processor := NewBatchSpanProcessor(exporter,
        WithBatchSize(1000),           // æ‰¹æ¬¡å¤§å°1000
        WithBatchTimeout(5*time.Second), // 5ç§’è¶…æ—¶
    )

    return trace.NewTracerProvider(
        trace.WithBatcher(processor),
    )
}
```

### 3. æ‰¹é‡ä¼ è¾“æ€§èƒ½ä¼˜åŒ–

```go
package main

import (
    "context"
    "sync"
    "time"
)

// è‡ªé€‚åº”æ‰¹é‡å¤„ç†å™¨
type AdaptiveBatchProcessor struct {
    exporter trace.SpanExporter

    // åŠ¨æ€è°ƒæ•´å‚æ•°
    batchSize    int
    batchTimeout time.Duration

    // æ€§èƒ½ç›‘æ§
    metrics *BatchMetrics

    batch      []trace.ReadOnlySpan
    batchMutex sync.Mutex

    stopCh chan struct{}
    wg     sync.WaitGroup
}

type BatchMetrics struct {
    totalBatches     int64
    totalSpans       int64
    avgBatchLatency  time.Duration
    avgBatchSize     float64
}

func (abp *AdaptiveBatchProcessor) adjustBatchSize() {
    metrics := abp.metrics

    // æ ¹æ®å¹³å‡æ‰¹æ¬¡å¤§å°è°ƒæ•´
    if metrics.avgBatchSize < float64(abp.batchSize)*0.5 {
        // æ‰¹æ¬¡å¤ªå°ï¼Œé™ä½æ‰¹æ¬¡å¤§å°é˜ˆå€¼
        abp.batchSize = int(float64(abp.batchSize) * 0.8)
    } else if metrics.avgBatchSize > float64(abp.batchSize)*0.9 {
        // æ‰¹æ¬¡æ¥è¿‘æ»¡è½½ï¼Œæé«˜æ‰¹æ¬¡å¤§å°é˜ˆå€¼
        abp.batchSize = int(float64(abp.batchSize) * 1.2)
    }

    // æ ¹æ®å»¶è¿Ÿè°ƒæ•´è¶…æ—¶æ—¶é—´
    if metrics.avgBatchLatency > abp.batchTimeout*2 {
        // å»¶è¿Ÿè¿‡é«˜ï¼Œç¼©çŸ­è¶…æ—¶æ—¶é—´
        abp.batchTimeout = abp.batchTimeout / 2
    } else if metrics.avgBatchLatency < abp.batchTimeout/2 {
        // å»¶è¿Ÿå¾ˆä½ï¼Œå»¶é•¿è¶…æ—¶æ—¶é—´
        abp.batchTimeout = abp.batchTimeout * 2
    }
}

func (abp *AdaptiveBatchProcessor) exportBatch() {
    start := time.Now()

    bsp.batchMutex.Lock()
    if len(abp.batch) == 0 {
        abp.batchMutex.Unlock()
        return
    }

    batch := abp.batch
    abp.batch = make([]trace.ReadOnlySpan, 0, abp.batchSize)
    bsp.batchMutex.Unlock()

    // å¯¼å‡ºæ‰¹æ¬¡
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    err := abp.exporter.ExportSpans(ctx, batch)
    if err != nil {
        logExportError(err, len(batch))
    }

    // æ›´æ–°æŒ‡æ ‡
    latency := time.Since(start)
    abp.metrics.totalBatches++
    abp.metrics.totalSpans += int64(len(batch))
    abp.metrics.avgBatchLatency = (abp.metrics.avgBatchLatency + latency) / 2
    abp.metrics.avgBatchSize = float64(len(batch))

    // è‡ªé€‚åº”è°ƒæ•´
    abp.adjustBatchSize()
}
```

---

## ğŸŒŠ æµå¼ä¼ è¾“ä¼˜åŒ–

### 1. gRPCæµå¼ä¼ è¾“

**Streaming Export** ä½¿ç”¨gRPCæµå¼ä¼ è¾“ï¼Œé™ä½å»¶è¿Ÿï¼š

```protobuf
// gRPCæµå¼æœåŠ¡å®šä¹‰
service TraceService {
  // ä¼ ç»Ÿæ‰¹é‡å¯¼å‡º
  rpc Export(ExportTraceServiceRequest) returns (ExportTraceServiceResponse);

  // æµå¼å¯¼å‡º
  rpc ExportStream(stream TraceExportRequest) returns (stream TraceExportResponse);
}

message TraceExportRequest {
  ResourceSpans resource_spans = 1;
}

message TraceExportResponse {
  int32 accepted_spans = 1;
  int32 rejected_spans = 2-bold;
}
```

### 2. æµå¼ä¼ è¾“å®ç°

```go
package main

import (
    "context"
    "io"

    "google.golang.org/grpc"
    "go.opentelemetry.io/proto/otlp/collector/trace/v1"
)

// æµå¼Spanå¯¼å‡ºå™¨
type StreamingSpanExporter struct {
    client tracepb.TraceService_ExportStreamClient
}

func NewStreamingSpanExporter(conn *grpc.ClientConn) (*StreamingSpanExporter, error) {
    client := tracepb.NewTraceServiceClient(conn)

    streamClient, err := client.ExportStream(context.Background())
    if err != nil {
        return nil, err
    }

    return &StreamingSpanExporter{
        client: streamClient,
    }, nil
}

func (e *StreamingSpanExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // å°†Spansè½¬æ¢ä¸ºResourceSpans
    resourceSpans := convertToResourceSpans(spans)

    // æµå¼å‘é€
    req := &tracepb.TraceExportRequest{
        ResourceSpans: resourceSpans,
    }

    err := e.client.Send(req)
    if err != nil {
        return err
    }

    // æ¥æ”¶å“åº”
    resp, err := e.client.Recv()
    if err != nil {
        return err
    }

    // å¤„ç†å“åº”
    if resp.RejectedSpans > 0 {
        logRejectedSpans(resp.RejectedSpans
```

ç»§ç»­å®Œæˆæ–‡æ¡£å‰©ä½™éƒ¨åˆ†...
