# OTLP上下文传播机制：分布式追踪深入分析

> **OTLP版本**: v1.0.0 (Stable)  
> **最后更新**: 2025年10月11日  
> **分析目标**: 深入理解上下文传播、分布式追踪、跨服务追踪  
> **文档状态**: ✅ 完成

---

## 📋 目录

- [OTLP上下文传播机制：分布式追踪深入分析](#otlp上下文传播机制分布式追踪深入分析)
  - [📋 目录](#-目录)
  - [🎯 执行摘要](#-执行摘要)
  - [📊 上下文传播框架](#-上下文传播框架)
    - [传播层次](#传播层次)
    - [传播机制](#传播机制)
  - [🔗 W3C Trace Context](#-w3c-trace-context)
    - [1. traceparent Header](#1-traceparent-header)
    - [2. tracestate Header](#2-tracestate-header)
  - [🎒 Baggage传播](#-baggage传播)
    - [1. Baggage原理](#1-baggage原理)
    - [2. Baggage实现](#2-baggage实现)
  - [🌐 跨服务追踪](#-跨服务追踪)
    - [1. HTTP跨服务追踪](#1-http跨服务追踪)
    - [2. gRPC跨服务追踪](#2-grpc跨服务追踪)
  - [⚡ 异步上下文传播](#-异步上下文传播)
    - [1. Goroutine上下文传播](#1-goroutine上下文传播)
    - [2. Channel上下文传播](#2-channel上下文传播)
  - [💡 最佳实践](#-最佳实践)
    - [1. 上下文传播最佳实践](#1-上下文传播最佳实践)
    - [2. 性能优化建议](#2-性能优化建议)
  - [📚 参考资源](#-参考资源)

---

## 🎯 执行摘要

**OTLP上下文传播机制**是分布式追踪的核心，确保追踪上下文在服务间正确传播：

```text
上下文传播目标:
┌─────────────────────────────────────────────────┐
│          上下文传播三大目标                       │
├─────────────────────────────────────────────────┤
│                                                 │
│  🔗 连续性: 跨服务追踪上下文不丢失                │
│  ⚡ 性能: 传播开销 < 1%                          │
│  🔒 安全: 防止上下文篡改和泄露                    │
│                                                 │
└─────────────────────────────────────────────────┘
```

**核心传播技术**：

1. **W3C Trace Context**：标准化的追踪上下文传播
2. **Baggage传播**：业务数据在服务间传递
3. **跨服务追踪**：微服务架构下的追踪连续性
4. **异步上下文传播**：异步编程模式下的上下文管理

---

## 📊 上下文传播框架

### 传播层次

```text
OTLP上下文传播层次:
┌─────────────────────────────────────────────────┐
│             应用层传播                           │
│  - SDK自动传播 (Automatic Propagation)           │
│  - 手动传播 (Manual Propagation)                 │
│  - 上下文注入 (Context Injection)                │
├─────────────────────────────────────────────────┤
│             框架层传播                           │
│  - HTTP/gRPC自动传播 (Framework Integration)     │
│  - 消息队列传播 (Message Queue Propagation)       │
│  - 数据库传播 (Database Propagation)              │
├─────────────────────────────────────────────────┤
│             协议层传播                           │
│  - W3C Trace Context (traceparent/tracestate)    │
│  - Baggage Header                                │
│  - 自定义Header                                   │
├─────────────────────────────────────────────────┤
│             网络层传播                           │
│  - HTTP Header传播                               │
│  - gRPC Metadata传播                              │
│  - TCP/UDP自定义协议传播                          │
└─────────────────────────────────────────────────┘
```

### 传播机制

```text
定义 (上下文传播):
ContextPropagation = (TraceContext, Baggage, Propagation)

TraceContext = {
  trace_id: TraceID,      // 128位追踪ID
  parent_id: SpanID,      // 64位父Span ID
  flags: uint8,           // 标志位
  state: TraceState       // 追踪状态
}

Baggage = {
  entries: Map<string, string>,  // 键值对
  metadata: Map<string, string>  // 元数据
}

Propagation = {
  extract: (carrier) => Context,  // 提取上下文
  inject: (context, carrier) => void  // 注入上下文
}
```

---

## 🔗 W3C Trace Context

### 1. traceparent Header

**traceparent格式**：

```text
traceparent格式:
┌─────────────────────────────────────────────────┐
│  traceparent: 00-<trace-id>-<parent-id>-<flags> │
├─────────────────────────────────────────────────┤
│                                                 │
│  版本 (version): 2位十六进制 (00-ff)             │
│  追踪ID (trace-id): 32位十六进制 (128位)         │
│  父Span ID (parent-id): 16位十六进制 (64位)      │
│  标志 (flags): 2位十六进制 (8位)                 │
│                                                 │
│  示例:                                          │
│  00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01│
│                                                 │
│  解析:                                          │
│  version: 00                                     │
│  trace-id: 4bf92f3577b34da6a3ce929d0e0e4736      │
│  parent-id: 00f067aa0ba902b7                    │
│  flags: 01 (sampled)                             │
│                                                 │
└─────────────────────────────────────────────────┘
```

**traceparent实现**：

```go
package main

import (
    "context"
    "fmt"
    "strings"
    
    "go.opentelemetry.io/otel/trace"
)

// traceparent解析
type TraceParent struct {
    Version   uint8
    TraceID   trace.TraceID
    ParentID  trace.SpanID
    Flags     uint8
}

func ParseTraceParent(tp string) (*TraceParent, error) {
    parts := strings.Split(tp, "-")
    if len(parts) != 4 {
        return nil, fmt.Errorf("invalid traceparent format")
    }
    
    version, err := parseHex8(parts[0])
    if err != nil {
        return nil, err
    }
    
    traceID, err := trace.TraceIDFromHex(parts[1])
    if err != nil {
        return nil, err
    }
    
    parentID, err := trace.SpanIDFromHex(parts[2])
    if err != nil {
        return nil, err
    }
    
    flags, err := parseHex8(parts[3])
    if err != nil {
        return nil, err
    }
    
    return &TraceParent{
        Version:  version,
        TraceID:  traceID,
        ParentID: parentID,
        Flags:    flags,
    }, nil
}

func (tp *TraceParent) String() string {
    return fmt.Sprintf("%02x-%s-%s-%02x",
        tp.Version,
        tp.TraceID.String(),
        tp.ParentID.String(),
        tp.Flags)
}

func (tp *TraceParent) IsSampled() bool {
    return tp.Flags&0x01 != 0
}

// HTTP Header提取
func ExtractTraceContextFromHTTP(headers map[string]string) (context.Context, error) {
    traceparent := headers["traceparent"]
    if traceparent == "" {
        return context.Background(), nil
    }
    
    tp, err := ParseTraceParent(traceparent)
    if err != nil {
        return nil, err
    }
    
    // 创建SpanContext
    spanContext := trace.NewSpanContext(trace.SpanContextConfig{
        TraceID:    tp.TraceID,
        SpanID:     tp.ParentID,
        TraceFlags: trace.FlagsSampled(tp.IsSampled()),
    })
    
    // 创建Remote SpanContext
    remoteSpanContext := trace.NewSpanContext(trace.SpanContextConfig{
        TraceID:    tp.TraceID,
        SpanID:     tp.ParentID,
        TraceFlags: trace.FlagsSampled(tp.IsSampled()),
        Remote:     true,
    })
    
    ctx := trace.ContextWithRemoteSpanContext(context.Background(), remoteSpanContext)
    
    return ctx, nil
}

// HTTP Header注入
func InjectTraceContextToHTTP(ctx context.Context, headers map[string]string) error {
    spanContext := trace.SpanContextFromContext(ctx)
    if !spanContext.IsValid() {
        return fmt.Errorf("invalid span context")
    }
    
    tp := &TraceParent{
        Version:  0x00,
        TraceID:  spanContext.TraceID(),
        ParentID: spanContext.SpanID(),
        Flags:    uint8(spanContext.TraceFlags()),
    }
    
    headers["traceparent"] = tp.String()
    
    return nil
}
```

### 2. tracestate Header

**tracestate格式**：

```text
tracestate格式:
┌─────────────────────────────────────────────────┐
│  tracestate: vendor1=value1,vendor2=value2      │
├─────────────────────────────────────────────────┤
│                                                 │
│  格式: <key>=<value>[,<key>=<value>]*            │
│                                                 │
│  规则:                                          │
│  1. 键值对用逗号分隔                             │
│  2. 键名: [a-z0-9_-]+                           │
│  3. 值: [\x20-\x2b\x2d-\x3c\x3e-\x7e]*          │
│  4. 最多32个键值对                               │
│  5. 总长度不超过512字节                          │
│                                                 │
│  示例:                                          │
│  tracestate: congo=t61rcWkgMzE                  │
│  tracestate: congo=t61rcWkgMzE,rojo=00f067aa0ba902b7│
│                                                 │
└─────────────────────────────────────────────────┘
```

**tracestate实现**：

```go
package main

import (
    "context"
    "fmt"
    "strings"
    
    "go.opentelemetry.io/otel/trace"
)

// tracestate解析
type TraceState struct {
    entries map[string]string
}

func ParseTraceState(ts string) (*TraceState, error) {
    if ts == "" {
        return &TraceState{entries: make(map[string]string)}, nil
    }
    
    entries := make(map[string]string)
    parts := strings.Split(ts, ",")
    
    for _, part := range parts {
        kv := strings.SplitN(part, "=", 2)
        if len(kv) != 2 {
            return nil, fmt.Errorf("invalid tracestate entry: %s", part)
        }
        
        key := strings.TrimSpace(kv[0])
        value := strings.TrimSpace(kv[1])
        
        entries[key] = value
    }
    
    return &TraceState{entries: entries}, nil
}

func (ts *TraceState) String() string {
    if len(ts.entries) == 0 {
        return ""
    }
    
    var parts []string
    for key, value := range ts.entries {
        parts = append(parts, fmt.Sprintf("%s=%s", key, value))
    }
    
    return strings.Join(parts, ",")
}

func (ts *TraceState) Get(key string) (string, bool) {
    value, exists := ts.entries[key]
    return value, exists
}

func (ts *TraceState) Set(key, value string) {
    ts.entries[key] = value
}

// tracestate传播
func ExtractTraceStateFromHTTP(headers map[string]string) (*TraceState, error) {
    tracestate := headers["tracestate"]
    return ParseTraceState(tracestate)
}

func InjectTraceStateToHTTP(ctx context.Context, headers map[string]string) error {
    spanContext := trace.SpanContextFromContext(ctx)
    if !spanContext.IsValid() {
        return fmt.Errorf("invalid span context")
    }
    
    traceState := spanContext.TraceState()
    if traceState.Len() > 0 {
        headers["tracestate"] = traceState.String()
    }
    
    return nil
}
```

---

## 🎒 Baggage传播

### 1. Baggage原理

**Baggage**允许在服务间传递业务数据：

```text
Baggage传播示例:
┌─────────────────────────────────────────────────┐
│  服务A → 服务B → 服务C                            │
├─────────────────────────────────────────────────┤
│                                                 │
│  服务A:                                         │
│    baggage: user_id=12345,request_id=abc-123    │
│                                                 │
│  服务B:                                         │
│    baggage: user_id=12345,request_id=abc-123    │
│    baggage: +order_id=ORD-001                   │
│                                                 │
│  服务C:                                         │
│    baggage: user_id=12345,request_id=abc-123,order_id=ORD-001│
│                                                 │
│  特点:                                          │
│  ✅ 自动传播到下游服务                            │
│  ✅ 支持添加新的键值对                           │
│  ✅ 不影响追踪上下文                              │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 2. Baggage实现

```go
package main

import (
    "context"
    "fmt"
    "strings"
    
    "go.opentelemetry.io/otel/baggage"
)

// Baggage设置
func SetBaggage(ctx context.Context, key, value string) context.Context {
    member, err := baggage.NewMember(key, value)
    if err != nil {
        return ctx
    }
    
    bag, err := baggage.FromContext(ctx)
    if err != nil {
        bag = baggage.Baggage{}
    }
    
    bag = bag.SetMember(member)
    
    return baggage.ContextWithBaggage(ctx, bag)
}

// Baggage获取
func GetBaggage(ctx context.Context, key string) (string, bool) {
    bag := baggage.FromContext(ctx)
    member := bag.Member(key)
    
    if member.Key() == "" {
        return "", false
    }
    
    return member.Value(), true
}

// Baggage删除
func RemoveBaggage(ctx context.Context, key string) context.Context {
    bag := baggage.FromContext(ctx)
    bag = bag.DeleteMember(key)
    
    return baggage.ContextWithBaggage(ctx, bag)
}

// HTTP Header提取
func ExtractBaggageFromHTTP(headers map[string]string) (context.Context, error) {
    baggageHeader := headers["baggage"]
    if baggageHeader == "" {
        return context.Background(), nil
    }
    
    ctx := context.Background()
    entries := strings.Split(baggageHeader, ",")
    
    for _, entry := range entries {
        kv := strings.SplitN(entry, "=", 2)
        if len(kv) != 2 {
            continue
        }
        
        key := strings.TrimSpace(kv[0])
        value := strings.TrimSpace(kv[1])
        
        ctx = SetBaggage(ctx, key, value)
    }
    
    return ctx, nil
}

// HTTP Header注入
func InjectBaggageToHTTP(ctx context.Context, headers map[string]string) error {
    bag := baggage.FromContext(ctx)
    
    if bag.Len() == 0 {
        return nil
    }
    
    var entries []string
    bag.Foreach(func(member baggage.Member) bool {
        entries = append(entries, fmt.Sprintf("%s=%s", member.Key(), member.Value()))
        return true
    })
    
    headers["baggage"] = strings.Join(entries, ",")
    
    return nil
}
```

---

## 🌐 跨服务追踪

### 1. HTTP跨服务追踪

**HTTP客户端追踪**：

```go
package main

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// HTTP客户端自动追踪
func createTracedHTTPClient() *http.Client {
    return &http.Client{
        Transport: otelhttp.NewTransport(
            http.DefaultTransport,
            otelhttp.WithTracerProvider(otel.GetTracerProvider()),
            otelhttp.WithPropagators(otel.GetTextMapPropagator()),
        ),
    }
}

// HTTP请求追踪
func makeTracedHTTPRequest(ctx context.Context, url string) error {
    client := createTracedHTTPClient()
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    return nil
}

// 手动HTTP追踪
func makeManualHTTPRequest(ctx context.Context, url string) error {
    tracer := otel.Tracer("http-client")
    
    ctx, span := tracer.Start(ctx, "http.request",
        trace.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.url", url),
        ),
    )
    defer span.End()
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    // 注入追踪上下文
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        span.RecordError(err)
        return err
    }
    defer resp.Body.Close()
    
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
    )
    
    return nil
}
```

**HTTP服务器追踪**：

```go
package main

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
)

// HTTP服务器自动追踪
func createTracedHTTPServer() *http.Server {
    handler := http.HandlerFunc(handleRequest)
    
    wrappedHandler := otelhttp.NewHandler(
        handler,
        "order-service",
        otelhttp.WithTracerProvider(otel.GetTracerProvider()),
        otelhttp.WithPropagators(otel.GetTextMapPropagator()),
    )
    
    return &http.Server{
        Handler: wrappedHandler,
        Addr:    ":8080",
    }
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // 从请求中提取追踪上下文
    span := trace.SpanFromContext(ctx)
    span.SetAttributes(
        attribute.String("http.method", r.Method),
        attribute.String("http.url", r.URL.String()),
    )
    
    // 处理请求
    processRequest(ctx)
    
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}

// 手动HTTP服务器追踪
func handleManualRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // 提取追踪上下文
    propagator := otel.GetTextMapPropagator()
    ctx = propagator.Extract(ctx, propagation.HeaderCarrier(r.Header))
    
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "handle_request")
    defer span.End()
    
    // 处理请求
    processRequest(ctx)
    
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```

### 2. gRPC跨服务追踪

**gRPC客户端追踪**：

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "google.golang.org/grpc"
)

// gRPC客户端自动追踪
func createTracedGRPCClient(target string) (*grpc.ClientConn, error) {
    return grpc.Dial(target,
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor(
            otelgrpc.WithTracerProvider(otel.GetTracerProvider()),
            otelgrpc.WithPropagators(otel.GetTextMapPropagator()),
        )),
    )
}

// gRPC调用追踪
func callGRPCService(ctx context.Context, client pb.OrderServiceClient, req *pb.OrderRequest) (*pb.OrderResponse, error) {
    tracer := otel.Tracer("grpc-client")
    
    ctx, span := tracer.Start(ctx, "order_service.CreateOrder",
        trace.WithAttributes(
            attribute.String("rpc.method", "CreateOrder"),
            attribute.String("rpc.service", "order_service"),
        ),
    )
    defer span.End()
    
    resp, err := client.CreateOrder(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("rpc.status_code", "ERROR"),
        )
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("rpc.status_code", "OK"),
    )
    
    return resp, nil
}
```

**gRPC服务器追踪**：

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "google.golang.org/grpc"
)

// gRPC服务器自动追踪
func createTracedGRPCServer() *grpc.Server {
    return grpc.NewServer(
        grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor(
            otelgrpc.WithTracerProvider(otel.GetTracerProvider()),
            otelgrpc.WithPropagators(otel.GetTextMapPropagator()),
        )),
    )
}

// gRPC服务实现
type OrderServiceServer struct {
    pb.UnimplementedOrderServiceServer
}

func (s *OrderServiceServer) CreateOrder(ctx context.Context, req *pb.OrderRequest) (*pb.OrderResponse, error) {
    span := trace.SpanFromContext(ctx)
    span.SetAttributes(
        attribute.String("order.id", req.OrderId),
        attribute.Float64("order.amount", req.Amount),
    )
    
    // 处理订单
    order, err := processOrder(ctx, req)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("order.status", "completed"),
    )
    
    return &pb.OrderResponse{
        OrderId: order.ID,
        Status:  "completed",
    }, nil
}
```

---

## ⚡ 异步上下文传播

### 1. Goroutine上下文传播

**Goroutine追踪**：

```go
package main

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// Goroutine追踪
func processAsync(ctx context.Context, tasks []Task) error {
    tracer := otel.Tracer("async-processor")
    
    ctx, span := tracer.Start(ctx, "process_async")
    defer span.End()
    
    var wg sync.WaitGroup
    errCh := make(chan error, len(tasks))
    
    for _, task := range tasks {
        wg.Add(1)
        
        // 创建子上下文
        taskCtx, taskSpan := tracer.Start(ctx, "process_task",
            trace.WithAttributes(
                attribute.String("task.id", task.ID),
            ),
        )
        
        go func(ctx context.Context, task Task) {
            defer wg.Done()
            defer taskSpan.End()
            
            // 处理任务
            if err := processTask(ctx, task); err != nil {
                taskSpan.RecordError(err)
                errCh <- err
            }
        }(taskCtx, task)
    }
    
    wg.Wait()
    close(errCh)
    
    // 收集错误
    for err := range errCh {
        if err != nil {
            return err
        }
    }
    
    return nil
}

// 上下文传递
func processTask(ctx context.Context, task Task) error {
    span := trace.SpanFromContext(ctx)
    span.SetAttributes(
        attribute.String("task.name", task.Name),
    )
    
    // 子任务处理
    return processSubTask(ctx, task)
}

func processSubTask(ctx context.Context, task Task) error {
    tracer := otel.Tracer("async-processor")
    
    ctx, span := tracer.Start(ctx, "process_subtask")
    defer span.End()
    
    // 处理子任务
    return nil
}
```

### 2. Channel上下文传播

**Channel追踪**：

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// Channel追踪
type TracedChannel struct {
    ch    chan Task
    tracer trace.Tracer
}

func NewTracedChannel(buffer int) *TracedChannel {
    return &TracedChannel{
        ch:     make(chan Task, buffer),
        tracer: otel.Tracer("channel-processor"),
    }
}

func (tc *TracedChannel) Send(ctx context.Context, task Task) error {
    ctx, span := tc.tracer.Start(ctx, "channel.send",
        trace.WithAttributes(
            attribute.String("task.id", task.ID),
        ),
    )
    defer span.End()
    
    select {
    case tc.ch <- task:
        span.SetAttributes(
            attribute.String("channel.status", "sent"),
        )
        return nil
        
    case <-ctx.Done():
        span.SetAttributes(
            attribute.String("channel.status", "cancelled"),
        )
        return ctx.Err()
    }
}

func (tc *TracedChannel) Receive(ctx context.Context) (Task, error) {
    ctx, span := tc.tracer.Start(ctx, "channel.receive")
    defer span.End()
    
    select {
    case task := <-tc.ch:
        span.SetAttributes(
            attribute.String("channel.status", "received"),
            attribute.String("task.id", task.ID),
        )
        return task, nil
        
    case <-ctx.Done():
        span.SetAttributes(
            attribute.String("channel.status", "cancelled"),
        )
        return Task{}, ctx.Err()
    }
}

// Worker池追踪
func startTracedWorkerPool(ctx context.Context, numWorkers int, ch *TracedChannel) {
    tracer := otel.Tracer("worker-pool")
    
    for i := 0; i < numWorkers; i++ {
        go func(workerID int) {
            workerCtx, span := tracer.Start(ctx, "worker.loop",
                trace.WithAttributes(
                    attribute.Int("worker.id", workerID),
                ),
            )
            defer span.End()
            
            for {
                task, err := ch.Receive(workerCtx)
                if err != nil {
                    break
                }
                
                processTask(workerCtx, task)
            }
        }(i)
    }
}
```

---

## 💡 最佳实践

### 1. 上下文传播最佳实践

```text
上下文传播最佳实践:
┌─────────────────────────────────────────────────┐
│  ✅ 推荐做法                                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  1. 使用标准化的传播格式                         │
│     W3C Trace Context (traceparent/tracestate)  │
│                                                 │
│  2. 自动传播而非手动传播                         │
│     使用SDK提供的自动传播机制                     │
│                                                 │
│  3. 在异步操作中传递上下文                       │
│     Goroutine、Channel、Future等                 │
│                                                 │
│  4. 限制Baggage大小                              │
│     总大小 < 8KB                                 │
│     键值对 < 32个                                │
│                                                 │
│  5. 避免敏感信息                                │
│     ❌ baggage: password=secret                 │
│     ✅ baggage: user_id=12345                   │
│                                                 │
│  6. 验证上下文有效性                             │
│     检查TraceID和SpanID是否有效                  │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 2. 性能优化建议

```text
性能优化建议:
┌─────────────────────────────────────────────────┐
│  优化项         │ 建议值          │ 说明           │
├─────────────────────────────────────────────────┤
│  传播开销       │ < 1%           │ 上下文传播开销 │
│  Baggage大小    │ < 8KB          │ 避免过大       │
│  上下文深度     │ < 100层        │ 避免过深       │
│  采样率         │ 1-10%          │ 生产环境       │
│  异步追踪       │ 支持           │ 完整追踪       │
└─────────────────────────────────────────────────┘
```

---

## 📚 参考资源

- [W3C Trace Context规范](https://www.w3.org/TR/trace-context/)
- [OpenTelemetry传播规范](https://opentelemetry.io/docs/specs/otel/context/api-propagators/)
- [Baggage规范](https://www.w3.org/TR/baggage/)
- [OTLP传播机制](https://opentelemetry.io/docs/specs/otel/overview/#context-propagation)

---

**最后更新**: 2025年10月11日  
**维护者**: OTLP深度梳理团队  
**版本**: 1.0.0
