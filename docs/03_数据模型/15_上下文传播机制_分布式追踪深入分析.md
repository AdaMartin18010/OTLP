# OTLPä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶ï¼šåˆ†å¸ƒå¼è¿½è¸ªæ·±å…¥åˆ†æ

> **OTLPç‰ˆæœ¬**: v1.0.0 (Stable)
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥
> **åˆ†æç›®æ ‡**: æ·±å…¥ç†è§£ä¸Šä¸‹æ–‡ä¼ æ’­ã€åˆ†å¸ƒå¼è¿½è¸ªã€è·¨æœåŠ¡è¿½è¸ª
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [OTLPä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶ï¼šåˆ†å¸ƒå¼è¿½è¸ªæ·±å…¥åˆ†æ](#otlpä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶åˆ†å¸ƒå¼è¿½è¸ªæ·±å…¥åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
  - [ğŸ“Š ä¸Šä¸‹æ–‡ä¼ æ’­æ¡†æ¶](#-ä¸Šä¸‹æ–‡ä¼ æ’­æ¡†æ¶)
    - [ä¼ æ’­å±‚æ¬¡](#ä¼ æ’­å±‚æ¬¡)
    - [ä¼ æ’­æœºåˆ¶](#ä¼ æ’­æœºåˆ¶)
  - [ğŸ”— W3C Trace Context](#-w3c-trace-context)
    - [1. traceparent Header](#1-traceparent-header)
    - [2. tracestate Header](#2-tracestate-header)
  - [ğŸ’ Baggageä¼ æ’­](#-baggageä¼ æ’­)
    - [1. BaggageåŸç†](#1-baggageåŸç†)
    - [2. Baggageå®ç°](#2-baggageå®ç°)
  - [ğŸŒ è·¨æœåŠ¡è¿½è¸ª](#-è·¨æœåŠ¡è¿½è¸ª)
    - [1. HTTPè·¨æœåŠ¡è¿½è¸ª](#1-httpè·¨æœåŠ¡è¿½è¸ª)
    - [2. gRPCè·¨æœåŠ¡è¿½è¸ª](#2-grpcè·¨æœåŠ¡è¿½è¸ª)
  - [âš¡ å¼‚æ­¥ä¸Šä¸‹æ–‡ä¼ æ’­](#-å¼‚æ­¥ä¸Šä¸‹æ–‡ä¼ æ’­)
    - [1. Goroutineä¸Šä¸‹æ–‡ä¼ æ’­](#1-goroutineä¸Šä¸‹æ–‡ä¼ æ’­)
    - [2. Channelä¸Šä¸‹æ–‡ä¼ æ’­](#2-channelä¸Šä¸‹æ–‡ä¼ æ’­)
  - [ğŸ’¡ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. ä¸Šä¸‹æ–‡ä¼ æ’­æœ€ä½³å®è·µ](#1-ä¸Šä¸‹æ–‡ä¼ æ’­æœ€ä½³å®è·µ)
    - [2. æ€§èƒ½ä¼˜åŒ–å»ºè®®](#2-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ‰§è¡Œæ‘˜è¦

**OTLPä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶**æ˜¯åˆ†å¸ƒå¼è¿½è¸ªçš„æ ¸å¿ƒï¼Œç¡®ä¿è¿½è¸ªä¸Šä¸‹æ–‡åœ¨æœåŠ¡é—´æ­£ç¡®ä¼ æ’­ï¼š

```text
ä¸Šä¸‹æ–‡ä¼ æ’­ç›®æ ‡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ä¸Šä¸‹æ–‡ä¼ æ’­ä¸‰å¤§ç›®æ ‡                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ğŸ”— è¿ç»­æ€§: è·¨æœåŠ¡è¿½è¸ªä¸Šä¸‹æ–‡ä¸ä¸¢å¤±                â”‚
â”‚  âš¡ æ€§èƒ½: ä¼ æ’­å¼€é”€ < 1%                          â”‚
â”‚  ğŸ”’ å®‰å…¨: é˜²æ­¢ä¸Šä¸‹æ–‡ç¯¡æ”¹å’Œæ³„éœ²                    â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒä¼ æ’­æŠ€æœ¯**ï¼š

1. **W3C Trace Context**ï¼šæ ‡å‡†åŒ–çš„è¿½è¸ªä¸Šä¸‹æ–‡ä¼ æ’­
2. **Baggageä¼ æ’­**ï¼šä¸šåŠ¡æ•°æ®åœ¨æœåŠ¡é—´ä¼ é€’
3. **è·¨æœåŠ¡è¿½è¸ª**ï¼šå¾®æœåŠ¡æ¶æ„ä¸‹çš„è¿½è¸ªè¿ç»­æ€§
4. **å¼‚æ­¥ä¸Šä¸‹æ–‡ä¼ æ’­**ï¼šå¼‚æ­¥ç¼–ç¨‹æ¨¡å¼ä¸‹çš„ä¸Šä¸‹æ–‡ç®¡ç†

---

## ğŸ“Š ä¸Šä¸‹æ–‡ä¼ æ’­æ¡†æ¶

### ä¼ æ’­å±‚æ¬¡

```text
OTLPä¸Šä¸‹æ–‡ä¼ æ’­å±‚æ¬¡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             åº”ç”¨å±‚ä¼ æ’­                           â”‚
â”‚  - SDKè‡ªåŠ¨ä¼ æ’­ (Automatic Propagation)           â”‚
â”‚  - æ‰‹åŠ¨ä¼ æ’­ (Manual Propagation)                 â”‚
â”‚  - ä¸Šä¸‹æ–‡æ³¨å…¥ (Context Injection)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             æ¡†æ¶å±‚ä¼ æ’­                           â”‚
â”‚  - HTTP/gRPCè‡ªåŠ¨ä¼ æ’­ (Framework Integration)     â”‚
â”‚  - æ¶ˆæ¯é˜Ÿåˆ—ä¼ æ’­ (Message Queue Propagation)       â”‚
â”‚  - æ•°æ®åº“ä¼ æ’­ (Database Propagation)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             åè®®å±‚ä¼ æ’­                           â”‚
â”‚  - W3C Trace Context (traceparent/tracestate)    â”‚
â”‚  - Baggage Header                                â”‚
â”‚  - è‡ªå®šä¹‰Header                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             ç½‘ç»œå±‚ä¼ æ’­                           â”‚
â”‚  - HTTP Headerä¼ æ’­                               â”‚
â”‚  - gRPC Metadataä¼ æ’­                              â”‚
â”‚  - TCP/UDPè‡ªå®šä¹‰åè®®ä¼ æ’­                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¼ æ’­æœºåˆ¶

```text
å®šä¹‰ (ä¸Šä¸‹æ–‡ä¼ æ’­):
ContextPropagation = (TraceContext, Baggage, Propagation)

TraceContext = {
  trace_id: TraceID,      // 128ä½è¿½è¸ªID
  parent_id: SpanID,      // 64ä½çˆ¶Span ID
  flags: uint8,           // æ ‡å¿—ä½
  state: TraceState       // è¿½è¸ªçŠ¶æ€
}

Baggage = {
  entries: Map<string, string>,  // é”®å€¼å¯¹
  metadata: Map<string, string>  // å…ƒæ•°æ®
}

Propagation = {
  extract: (carrier) => Context,  // æå–ä¸Šä¸‹æ–‡
  inject: (context, carrier) => void  // æ³¨å…¥ä¸Šä¸‹æ–‡
}
```

---

## ğŸ”— W3C Trace Context

### 1. traceparent Header

**traceparentæ ¼å¼**ï¼š

```text
traceparentæ ¼å¼:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  traceparent: 00-<trace-id>-<parent-id>-<flags> â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ç‰ˆæœ¬ (version): 2ä½åå…­è¿›åˆ¶ (00-ff)             â”‚
â”‚  è¿½è¸ªID (trace-id): 32ä½åå…­è¿›åˆ¶ (128ä½)         â”‚
â”‚  çˆ¶Span ID (parent-id): 16ä½åå…­è¿›åˆ¶ (64ä½)      â”‚
â”‚  æ ‡å¿— (flags): 2ä½åå…­è¿›åˆ¶ (8ä½)                 â”‚
â”‚                                                 â”‚
â”‚  ç¤ºä¾‹:                                          â”‚
â”‚  00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01â”‚
â”‚                                                 â”‚
â”‚  è§£æ:                                          â”‚
â”‚  version: 00                                     â”‚
â”‚  trace-id: 4bf92f3577b34da6a3ce929d0e0e4736      â”‚
â”‚  parent-id: 00f067aa0ba902b7                    â”‚
â”‚  flags: 01 (sampled)                             â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**traceparentå®ç°**ï¼š

```go
package main

import (
    "context"
    "fmt"
    "strings"

    "go.opentelemetry.io/otel/trace"
)

// traceparentè§£æ
type TraceParent struct {
    Version   uint8
    TraceID   trace.TraceID
    ParentID  trace.SpanID
    Flags     uint8
}

func ParseTraceParent(tp string) (*TraceParent, error) {
    parts := strings.Split(tp, "-")
    if len(parts) != 4 {
        return nil, fmt.Errorf("invalid traceparent format")
    }

    version, err := parseHex8(parts[0])
    if err != nil {
        return nil, err
    }

    traceID, err := trace.TraceIDFromHex(parts[1])
    if err != nil {
        return nil, err
    }

    parentID, err := trace.SpanIDFromHex(parts[2])
    if err != nil {
        return nil, err
    }

    flags, err := parseHex8(parts[3])
    if err != nil {
        return nil, err
    }

    return &TraceParent{
        Version:  version,
        TraceID:  traceID,
        ParentID: parentID,
        Flags:    flags,
    }, nil
}

func (tp *TraceParent) String() string {
    return fmt.Sprintf("%02x-%s-%s-%02x",
        tp.Version,
        tp.TraceID.String(),
        tp.ParentID.String(),
        tp.Flags)
}

func (tp *TraceParent) IsSampled() bool {
    return tp.Flags&0x01 != 0
}

// HTTP Headeræå–
func ExtractTraceContextFromHTTP(headers map[string]string) (context.Context, error) {
    traceparent := headers["traceparent"]
    if traceparent == "" {
        return context.Background(), nil
    }

    tp, err := ParseTraceParent(traceparent)
    if err != nil {
        return nil, err
    }

    // åˆ›å»ºSpanContext
    spanContext := trace.NewSpanContext(trace.SpanContextConfig{
        TraceID:    tp.TraceID,
        SpanID:     tp.ParentID,
        TraceFlags: trace.FlagsSampled(tp.IsSampled()),
    })

    // åˆ›å»ºRemote SpanContext
    remoteSpanContext := trace.NewSpanContext(trace.SpanContextConfig{
        TraceID:    tp.TraceID,
        SpanID:     tp.ParentID,
        TraceFlags: trace.FlagsSampled(tp.IsSampled()),
        Remote:     true,
    })

    ctx := trace.ContextWithRemoteSpanContext(context.Background(), remoteSpanContext)

    return ctx, nil
}

// HTTP Headeræ³¨å…¥
func InjectTraceContextToHTTP(ctx context.Context, headers map[string]string) error {
    spanContext := trace.SpanContextFromContext(ctx)
    if !spanContext.IsValid() {
        return fmt.Errorf("invalid span context")
    }

    tp := &TraceParent{
        Version:  0x00,
        TraceID:  spanContext.TraceID(),
        ParentID: spanContext.SpanID(),
        Flags:    uint8(spanContext.TraceFlags()),
    }

    headers["traceparent"] = tp.String()

    return nil
}
```

### 2. tracestate Header

**tracestateæ ¼å¼**ï¼š

```text
tracestateæ ¼å¼:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  tracestate: vendor1=value1,vendor2=value2      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  æ ¼å¼: <key>=<value>[,<key>=<value>]*            â”‚
â”‚                                                 â”‚
â”‚  è§„åˆ™:                                          â”‚
â”‚  1. é”®å€¼å¯¹ç”¨é€—å·åˆ†éš”                             â”‚
â”‚  2. é”®å: [a-z0-9_-]+                           â”‚
â”‚  3. å€¼: [\x20-\x2b\x2d-\x3c\x3e-\x7e]*          â”‚
â”‚  4. æœ€å¤š32ä¸ªé”®å€¼å¯¹                               â”‚
â”‚  5. æ€»é•¿åº¦ä¸è¶…è¿‡512å­—èŠ‚                          â”‚
â”‚                                                 â”‚
â”‚  ç¤ºä¾‹:                                          â”‚
â”‚  tracestate: congo=t61rcWkgMzE                  â”‚
â”‚  tracestate: congo=t61rcWkgMzE,rojo=00f067aa0ba902b7â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**tracestateå®ç°**ï¼š

```go
package main

import (
    "context"
    "fmt"
    "strings"

    "go.opentelemetry.io/otel/trace"
)

// tracestateè§£æ
type TraceState struct {
    entries map[string]string
}

func ParseTraceState(ts string) (*TraceState, error) {
    if ts == "" {
        return &TraceState{entries: make(map[string]string)}, nil
    }

    entries := make(map[string]string)
    parts := strings.Split(ts, ",")

    for _, part := range parts {
        kv := strings.SplitN(part, "=", 2)
        if len(kv) != 2 {
            return nil, fmt.Errorf("invalid tracestate entry: %s", part)
        }

        key := strings.TrimSpace(kv[0])
        value := strings.TrimSpace(kv[1])

        entries[key] = value
    }

    return &TraceState{entries: entries}, nil
}

func (ts *TraceState) String() string {
    if len(ts.entries) == 0 {
        return ""
    }

    var parts []string
    for key, value := range ts.entries {
        parts = append(parts, fmt.Sprintf("%s=%s", key, value))
    }

    return strings.Join(parts, ",")
}

func (ts *TraceState) Get(key string) (string, bool) {
    value, exists := ts.entries[key]
    return value, exists
}

func (ts *TraceState) Set(key, value string) {
    ts.entries[key] = value
}

// tracestateä¼ æ’­
func ExtractTraceStateFromHTTP(headers map[string]string) (*TraceState, error) {
    tracestate := headers["tracestate"]
    return ParseTraceState(tracestate)
}

func InjectTraceStateToHTTP(ctx context.Context, headers map[string]string) error {
    spanContext := trace.SpanContextFromContext(ctx)
    if !spanContext.IsValid() {
        return fmt.Errorf("invalid span context")
    }

    traceState := spanContext.TraceState()
    if traceState.Len() > 0 {
        headers["tracestate"] = traceState.String()
    }

    return nil
}
```

---

## ğŸ’ Baggageä¼ æ’­

### 1. BaggageåŸç†

**Baggage**å…è®¸åœ¨æœåŠ¡é—´ä¼ é€’ä¸šåŠ¡æ•°æ®ï¼š

```text
Baggageä¼ æ’­ç¤ºä¾‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æœåŠ¡A â†’ æœåŠ¡B â†’ æœåŠ¡C                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  æœåŠ¡A:                                         â”‚
â”‚    baggage: user_id=12345,request_id=abc-123    â”‚
â”‚                                                 â”‚
â”‚  æœåŠ¡B:                                         â”‚
â”‚    baggage: user_id=12345,request_id=abc-123    â”‚
â”‚    baggage: +order_id=ORD-001                   â”‚
â”‚                                                 â”‚
â”‚  æœåŠ¡C:                                         â”‚
â”‚    baggage: user_id=12345,request_id=abc-123,order_id=ORD-001â”‚
â”‚                                                 â”‚
â”‚  ç‰¹ç‚¹:                                          â”‚
â”‚  âœ… è‡ªåŠ¨ä¼ æ’­åˆ°ä¸‹æ¸¸æœåŠ¡                            â”‚
â”‚  âœ… æ”¯æŒæ·»åŠ æ–°çš„é”®å€¼å¯¹                           â”‚
â”‚  âœ… ä¸å½±å“è¿½è¸ªä¸Šä¸‹æ–‡                              â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Baggageå®ç°

```go
package main

import (
    "context"
    "fmt"
    "strings"

    "go.opentelemetry.io/otel/baggage"
)

// Baggageè®¾ç½®
func SetBaggage(ctx context.Context, key, value string) context.Context {
    member, err := baggage.NewMember(key, value)
    if err != nil {
        return ctx
    }

    bag, err := baggage.FromContext(ctx)
    if err != nil {
        bag = baggage.Baggage{}
    }

    bag = bag.SetMember(member)

    return baggage.ContextWithBaggage(ctx, bag)
}

// Baggageè·å–
func GetBaggage(ctx context.Context, key string) (string, bool) {
    bag := baggage.FromContext(ctx)
    member := bag.Member(key)

    if member.Key() == "" {
        return "", false
    }

    return member.Value(), true
}

// Baggageåˆ é™¤
func RemoveBaggage(ctx context.Context, key string) context.Context {
    bag := baggage.FromContext(ctx)
    bag = bag.DeleteMember(key)

    return baggage.ContextWithBaggage(ctx, bag)
}

// HTTP Headeræå–
func ExtractBaggageFromHTTP(headers map[string]string) (context.Context, error) {
    baggageHeader := headers["baggage"]
    if baggageHeader == "" {
        return context.Background(), nil
    }

    ctx := context.Background()
    entries := strings.Split(baggageHeader, ",")

    for _, entry := range entries {
        kv := strings.SplitN(entry, "=", 2)
        if len(kv) != 2 {
            continue
        }

        key := strings.TrimSpace(kv[0])
        value := strings.TrimSpace(kv[1])

        ctx = SetBaggage(ctx, key, value)
    }

    return ctx, nil
}

// HTTP Headeræ³¨å…¥
func InjectBaggageToHTTP(ctx context.Context, headers map[string]string) error {
    bag := baggage.FromContext(ctx)

    if bag.Len() == 0 {
        return nil
    }

    var entries []string
    bag.Foreach(func(member baggage.Member) bool {
        entries = append(entries, fmt.Sprintf("%s=%s", member.Key(), member.Value()))
        return true
    })

    headers["baggage"] = strings.Join(entries, ",")

    return nil
}
```

---

## ğŸŒ è·¨æœåŠ¡è¿½è¸ª

### 1. HTTPè·¨æœåŠ¡è¿½è¸ª

**HTTPå®¢æˆ·ç«¯è¿½è¸ª**ï¼š

```go
package main

import (
    "context"
    "net/http"

    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// HTTPå®¢æˆ·ç«¯è‡ªåŠ¨è¿½è¸ª
func createTracedHTTPClient() *http.Client {
    return &http.Client{
        Transport: otelhttp.NewTransport(
            http.DefaultTransport,
            otelhttp.WithTracerProvider(otel.GetTracerProvider()),
            otelhttp.WithPropagators(otel.GetTextMapPropagator()),
        ),
    }
}

// HTTPè¯·æ±‚è¿½è¸ª
func makeTracedHTTPRequest(ctx context.Context, url string) error {
    client := createTracedHTTPClient()

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return err
    }

    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}

// æ‰‹åŠ¨HTTPè¿½è¸ª
func makeManualHTTPRequest(ctx context.Context, url string) error {
    tracer := otel.Tracer("http-client")

    ctx, span := tracer.Start(ctx, "http.request",
        trace.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.url", url),
        ),
    )
    defer span.End()

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        span.RecordError(err)
        return err
    }

    // æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        span.RecordError(err)
        return err
    }
    defer resp.Body.Close()

    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
    )

    return nil
}
```

**HTTPæœåŠ¡å™¨è¿½è¸ª**ï¼š

```go
package main

import (
    "context"
    "net/http"

    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
)

// HTTPæœåŠ¡å™¨è‡ªåŠ¨è¿½è¸ª
func createTracedHTTPServer() *http.Server {
    handler := http.HandlerFunc(handleRequest)

    wrappedHandler := otelhttp.NewHandler(
        handler,
        "order-service",
        otelhttp.WithTracerProvider(otel.GetTracerProvider()),
        otelhttp.WithPropagators(otel.GetTextMapPropagator()),
    )

    return &http.Server{
        Handler: wrappedHandler,
        Addr:    ":8080",
    }
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    // ä»è¯·æ±‚ä¸­æå–è¿½è¸ªä¸Šä¸‹æ–‡
    span := trace.SpanFromContext(ctx)
    span.SetAttributes(
        attribute.String("http.method", r.Method),
        attribute.String("http.url", r.URL.String()),
    )

    // å¤„ç†è¯·æ±‚
    processRequest(ctx)

    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}

// æ‰‹åŠ¨HTTPæœåŠ¡å™¨è¿½è¸ª
func handleManualRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    // æå–è¿½è¸ªä¸Šä¸‹æ–‡
    propagator := otel.GetTextMapPropagator()
    ctx = propagator.Extract(ctx, propagation.HeaderCarrier(r.Header))

    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "handle_request")
    defer span.End()

    // å¤„ç†è¯·æ±‚
    processRequest(ctx)

    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```

### 2. gRPCè·¨æœåŠ¡è¿½è¸ª

**gRPCå®¢æˆ·ç«¯è¿½è¸ª**ï¼š

```go
package main

import (
    "context"

    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "google.golang.org/grpc"
)

// gRPCå®¢æˆ·ç«¯è‡ªåŠ¨è¿½è¸ª
func createTracedGRPCClient(target string) (*grpc.ClientConn, error) {
    return grpc.Dial(target,
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor(
            otelgrpc.WithTracerProvider(otel.GetTracerProvider()),
            otelgrpc.WithPropagators(otel.GetTextMapPropagator()),
        )),
    )
}

// gRPCè°ƒç”¨è¿½è¸ª
func callGRPCService(ctx context.Context, client pb.OrderServiceClient, req *pb.OrderRequest) (*pb.OrderResponse, error) {
    tracer := otel.Tracer("grpc-client")

    ctx, span := tracer.Start(ctx, "order_service.CreateOrder",
        trace.WithAttributes(
            attribute.String("rpc.method", "CreateOrder"),
            attribute.String("rpc.service", "order_service"),
        ),
    )
    defer span.End()

    resp, err := client.CreateOrder(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("rpc.status_code", "ERROR"),
        )
        return nil, err
    }

    span.SetAttributes(
        attribute.String("rpc.status_code", "OK"),
    )

    return resp, nil
}
```

**gRPCæœåŠ¡å™¨è¿½è¸ª**ï¼š

```go
package main

import (
    "context"

    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "google.golang.org/grpc"
)

// gRPCæœåŠ¡å™¨è‡ªåŠ¨è¿½è¸ª
func createTracedGRPCServer() *grpc.Server {
    return grpc.NewServer(
        grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor(
            otelgrpc.WithTracerProvider(otel.GetTracerProvider()),
            otelgrpc.WithPropagators(otel.GetTextMapPropagator()),
        )),
    )
}

// gRPCæœåŠ¡å®ç°
type OrderServiceServer struct {
    pb.UnimplementedOrderServiceServer
}

func (s *OrderServiceServer) CreateOrder(ctx context.Context, req *pb.OrderRequest) (*pb.OrderResponse, error) {
    span := trace.SpanFromContext(ctx)
    span.SetAttributes(
        attribute.String("order.id", req.OrderId),
        attribute.Float64("order.amount", req.Amount),
    )

    // å¤„ç†è®¢å•
    order, err := processOrder(ctx, req)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    span.SetAttributes(
        attribute.String("order.status", "completed"),
    )

    return &pb.OrderResponse{
        OrderId: order.ID,
        Status:  "completed",
    }, nil
}
```

---

## âš¡ å¼‚æ­¥ä¸Šä¸‹æ–‡ä¼ æ’­

### 1. Goroutineä¸Šä¸‹æ–‡ä¼ æ’­

**Goroutineè¿½è¸ª**ï¼š

```go
package main

import (
    "context"
    "sync"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// Goroutineè¿½è¸ª
func processAsync(ctx context.Context, tasks []Task) error {
    tracer := otel.Tracer("async-processor")

    ctx, span := tracer.Start(ctx, "process_async")
    defer span.End()

    var wg sync.WaitGroup
    errCh := make(chan error, len(tasks))

    for _, task := range tasks {
        wg.Add(1)

        // åˆ›å»ºå­ä¸Šä¸‹æ–‡
        taskCtx, taskSpan := tracer.Start(ctx, "process_task",
            trace.WithAttributes(
                attribute.String("task.id", task.ID),
            ),
        )

        go func(ctx context.Context, task Task) {
            defer wg.Done()
            defer taskSpan.End()

            // å¤„ç†ä»»åŠ¡
            if err := processTask(ctx, task); err != nil {
                taskSpan.RecordError(err)
                errCh <- err
            }
        }(taskCtx, task)
    }

    wg.Wait()
    close(errCh)

    // æ”¶é›†é”™è¯¯
    for err := range errCh {
        if err != nil {
            return err
        }
    }

    return nil
}

// ä¸Šä¸‹æ–‡ä¼ é€’
func processTask(ctx context.Context, task Task) error {
    span := trace.SpanFromContext(ctx)
    span.SetAttributes(
        attribute.String("task.name", task.Name),
    )

    // å­ä»»åŠ¡å¤„ç†
    return processSubTask(ctx, task)
}

func processSubTask(ctx context.Context, task Task) error {
    tracer := otel.Tracer("async-processor")

    ctx, span := tracer.Start(ctx, "process_subtask")
    defer span.End()

    // å¤„ç†å­ä»»åŠ¡
    return nil
}
```

### 2. Channelä¸Šä¸‹æ–‡ä¼ æ’­

**Channelè¿½è¸ª**ï¼š

```go
package main

import (
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// Channelè¿½è¸ª
type TracedChannel struct {
    ch    chan Task
    tracer trace.Tracer
}

func NewTracedChannel(buffer int) *TracedChannel {
    return &TracedChannel{
        ch:     make(chan Task, buffer),
        tracer: otel.Tracer("channel-processor"),
    }
}

func (tc *TracedChannel) Send(ctx context.Context, task Task) error {
    ctx, span := tc.tracer.Start(ctx, "channel.send",
        trace.WithAttributes(
            attribute.String("task.id", task.ID),
        ),
    )
    defer span.End()

    select {
    case tc.ch <- task:
        span.SetAttributes(
            attribute.String("channel.status", "sent"),
        )
        return nil

    case <-ctx.Done():
        span.SetAttributes(
            attribute.String("channel.status", "cancelled"),
        )
        return ctx.Err()
    }
}

func (tc *TracedChannel) Receive(ctx context.Context) (Task, error) {
    ctx, span := tc.tracer.Start(ctx, "channel.receive")
    defer span.End()

    select {
    case task := <-tc.ch:
        span.SetAttributes(
            attribute.String("channel.status", "received"),
            attribute.String("task.id", task.ID),
        )
        return task, nil

    case <-ctx.Done():
        span.SetAttributes(
            attribute.String("channel.status", "cancelled"),
        )
        return Task{}, ctx.Err()
    }
}

// Workeræ± è¿½è¸ª
func startTracedWorkerPool(ctx context.Context, numWorkers int, ch *TracedChannel) {
    tracer := otel.Tracer("worker-pool")

    for i := 0; i < numWorkers; i++ {
        go func(workerID int) {
            workerCtx, span := tracer.Start(ctx, "worker.loop",
                trace.WithAttributes(
                    attribute.Int("worker.id", workerID),
                ),
            )
            defer span.End()

            for {
                task, err := ch.Receive(workerCtx)
                if err != nil {
                    break
                }

                processTask(workerCtx, task)
            }
        }(i)
    }
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä¸Šä¸‹æ–‡ä¼ æ’­æœ€ä½³å®è·µ

```text
ä¸Šä¸‹æ–‡ä¼ æ’­æœ€ä½³å®è·µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… æ¨èåšæ³•                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  1. ä½¿ç”¨æ ‡å‡†åŒ–çš„ä¼ æ’­æ ¼å¼                         â”‚
â”‚     W3C Trace Context (traceparent/tracestate)  â”‚
â”‚                                                 â”‚
â”‚  2. è‡ªåŠ¨ä¼ æ’­è€Œéæ‰‹åŠ¨ä¼ æ’­                         â”‚
â”‚     ä½¿ç”¨SDKæä¾›çš„è‡ªåŠ¨ä¼ æ’­æœºåˆ¶                     â”‚
â”‚                                                 â”‚
â”‚  3. åœ¨å¼‚æ­¥æ“ä½œä¸­ä¼ é€’ä¸Šä¸‹æ–‡                       â”‚
â”‚     Goroutineã€Channelã€Futureç­‰                 â”‚
â”‚                                                 â”‚
â”‚  4. é™åˆ¶Baggageå¤§å°                              â”‚
â”‚     æ€»å¤§å° < 8KB                                 â”‚
â”‚     é”®å€¼å¯¹ < 32ä¸ª                                â”‚
â”‚                                                 â”‚
â”‚  5. é¿å…æ•æ„Ÿä¿¡æ¯                                â”‚
â”‚     âŒ baggage: password=secret                 â”‚
â”‚     âœ… baggage: user_id=12345                   â”‚
â”‚                                                 â”‚
â”‚  6. éªŒè¯ä¸Šä¸‹æ–‡æœ‰æ•ˆæ€§                             â”‚
â”‚     æ£€æŸ¥TraceIDå’ŒSpanIDæ˜¯å¦æœ‰æ•ˆ                  â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®

```text
æ€§èƒ½ä¼˜åŒ–å»ºè®®:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–é¡¹         â”‚ å»ºè®®å€¼          â”‚ è¯´æ˜           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¼ æ’­å¼€é”€       â”‚ < 1%           â”‚ ä¸Šä¸‹æ–‡ä¼ æ’­å¼€é”€ â”‚
â”‚  Baggageå¤§å°    â”‚ < 8KB          â”‚ é¿å…è¿‡å¤§       â”‚
â”‚  ä¸Šä¸‹æ–‡æ·±åº¦     â”‚ < 100å±‚        â”‚ é¿å…è¿‡æ·±       â”‚
â”‚  é‡‡æ ·ç‡         â”‚ 1-10%          â”‚ ç”Ÿäº§ç¯å¢ƒ       â”‚
â”‚  å¼‚æ­¥è¿½è¸ª       â”‚ æ”¯æŒ           â”‚ å®Œæ•´è¿½è¸ª       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š å‚è€ƒèµ„æº

- [W3C Trace Contextè§„èŒƒ](https://www.w3.org/TR/trace-context/)
- [OpenTelemetryä¼ æ’­è§„èŒƒ](https://opentelemetry.io/docs/specs/otel/context/api-propagators/)
- [Baggageè§„èŒƒ](https://www.w3.org/TR/baggage/)
- [OTLPä¼ æ’­æœºåˆ¶](https://opentelemetry.io/docs/specs/otel/overview/#context-propagation)

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ
**ç‰ˆæœ¬**: 1.0.0
