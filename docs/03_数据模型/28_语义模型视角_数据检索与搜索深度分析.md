# OTLPè¯­ä¹‰æ¨¡å‹è§†è§’ï¼šæ•°æ®æ£€ç´¢ä¸æœç´¢æ·±åº¦åˆ†æ

> **æ–‡æ¡£ç±»å‹**: æ•°æ®æ¨¡å‹æ·±åº¦åˆ†æ
> **åˆ†æç»´åº¦**: è¯­ä¹‰æ¨¡å‹è§†è§’ - æ•°æ®æ£€ç´¢ä¸æœç´¢
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ11æ—¥
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [OTLPè¯­ä¹‰æ¨¡å‹è§†è§’ï¼šæ•°æ®æ£€ç´¢ä¸æœç´¢æ·±åº¦åˆ†æ](#otlpè¯­ä¹‰æ¨¡å‹è§†è§’æ•°æ®æ£€ç´¢ä¸æœç´¢æ·±åº¦åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
    - [æ£€ç´¢æœç´¢å…¨æ™¯](#æ£€ç´¢æœç´¢å…¨æ™¯)
  - [ğŸ“Š æ£€ç´¢æœç´¢å…¨æ™¯](#-æ£€ç´¢æœç´¢å…¨æ™¯)
    - [æ£€ç´¢ç±»å‹çŸ©é˜µ](#æ£€ç´¢ç±»å‹çŸ©é˜µ)
  - [ğŸ” æ•°æ®æ£€ç´¢](#-æ•°æ®æ£€ç´¢)
    - [IDæ£€ç´¢](#idæ£€ç´¢)
    - [å±æ€§æ£€ç´¢](#å±æ€§æ£€ç´¢)
    - [æ—¶é—´æ£€ç´¢](#æ—¶é—´æ£€ç´¢)
  - [ğŸ” æ•°æ®æœç´¢](#-æ•°æ®æœç´¢)
    - [å…¨æ–‡æœç´¢](#å…¨æ–‡æœç´¢)
    - [æ¨¡ç³Šæœç´¢](#æ¨¡ç³Šæœç´¢)
    - [è¯­ä¹‰æœç´¢](#è¯­ä¹‰æœç´¢)
  - [ğŸ“ˆ æ£€ç´¢æœç´¢æ€§èƒ½åˆ†æ](#-æ£€ç´¢æœç´¢æ€§èƒ½åˆ†æ)
    - [æ£€ç´¢æœç´¢æ€§èƒ½åŸºå‡†æµ‹è¯•](#æ£€ç´¢æœç´¢æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [âš¡ æ£€ç´¢æœç´¢ä¼˜åŒ–ç­–ç•¥](#-æ£€ç´¢æœç´¢ä¼˜åŒ–ç­–ç•¥)
    - [1. ç´¢å¼•ç­–ç•¥](#1-ç´¢å¼•ç­–ç•¥)
    - [2. ç¼“å­˜ç­–ç•¥](#2-ç¼“å­˜ç­–ç•¥)
    - [3. åˆ†ç‰‡ç­–ç•¥](#3-åˆ†ç‰‡ç­–ç•¥)
  - [ğŸ’¡ å®æˆ˜æ¡ˆä¾‹](#-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šç”µå•†ç³»ç»Ÿè®¢å•æ£€ç´¢](#æ¡ˆä¾‹1ç”µå•†ç³»ç»Ÿè®¢å•æ£€ç´¢)
    - [æ¡ˆä¾‹2ï¼šå¾®æœåŠ¡ç³»ç»Ÿé“¾è·¯æœç´¢](#æ¡ˆä¾‹2å¾®æœåŠ¡ç³»ç»Ÿé“¾è·¯æœç´¢)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [æ£€ç´¢æœç´¢ä¼˜åŒ–çŸ©é˜µ](#æ£€ç´¢æœç´¢ä¼˜åŒ–çŸ©é˜µ)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## ğŸ¯ æ‰§è¡Œæ‘˜è¦

### æ£€ç´¢æœç´¢å…¨æ™¯

```text
æ£€ç´¢æœç´¢å…¨æ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          OTLPæ•°æ®æ£€ç´¢ä¸æœç´¢ä½“ç³»                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  æ•°æ®æ£€ç´¢                                    â”‚      â”‚
â”‚  â”‚  - IDæ£€ç´¢                                    â”‚      â”‚
â”‚  â”‚  - å±æ€§æ£€ç´¢                                  â”‚      â”‚
â”‚  â”‚  - æ—¶é—´æ£€ç´¢                                  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                         â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚               â”‚               â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ æ•°æ®æœç´¢    â”‚  â”‚ ç´¢å¼•ç­–ç•¥    â”‚  â”‚ æ€§èƒ½ä¼˜åŒ–    â”‚        â”‚
â”‚  â”‚ - å…¨æ–‡æœç´¢  â”‚  â”‚ - Bæ ‘ç´¢å¼•   â”‚  â”‚ - ç¼“å­˜      â”‚        â”‚
â”‚  â”‚ - æ¨¡ç³Šæœç´¢  â”‚  â”‚ - å“ˆå¸Œç´¢å¼•  â”‚  â”‚ - åˆ†ç‰‡      â”‚        â”‚
â”‚  â”‚ - è¯­ä¹‰æœç´¢  â”‚  â”‚ - å€’æ’ç´¢å¼•  â”‚  â”‚ - å¹¶è¡Œ      â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  æ£€ç´¢åœºæ™¯                                      â”‚      â”‚
â”‚  â”‚  - Traceæ£€ç´¢                                   â”‚      â”‚
â”‚  â”‚  - Spanæ£€ç´¢                                    â”‚      â”‚
â”‚  â”‚  - Logæ£€ç´¢                                     â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒæ´å¯Ÿ**ï¼š

1. **æ•°æ®æ£€ç´¢**ï¼šIDæ£€ç´¢ + å±æ€§æ£€ç´¢ + æ—¶é—´æ£€ç´¢
2. **æ•°æ®æœç´¢**ï¼šå…¨æ–‡æœç´¢ + æ¨¡ç³Šæœç´¢ + è¯­ä¹‰æœç´¢
3. **ç´¢å¼•ç­–ç•¥**ï¼šBæ ‘ç´¢å¼• + å“ˆå¸Œç´¢å¼• + å€’æ’ç´¢å¼•
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ + åˆ†ç‰‡ + å¹¶è¡Œ

---

## ğŸ“Š æ£€ç´¢æœç´¢å…¨æ™¯

### æ£€ç´¢ç±»å‹çŸ©é˜µ

```text
æ£€ç´¢ç±»å‹çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ£€ç´¢ç±»å‹      â”‚ è¾“å…¥æ¡ä»¶    â”‚ è¾“å‡ºç»“æœ    â”‚ å¤æ‚åº¦      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  IDæ£€ç´¢        â”‚ Trace ID   â”‚ Trace      â”‚ O(1)        â”‚
â”‚  å±æ€§æ£€ç´¢      â”‚ å±æ€§é”®å€¼    â”‚ Spans[]    â”‚ O(log n)    â”‚
â”‚  æ—¶é—´æ£€ç´¢      â”‚ æ—¶é—´èŒƒå›´    â”‚ Spans[]    â”‚ O(log n)    â”‚
â”‚  å…¨æ–‡æœç´¢      â”‚ å…³é”®è¯      â”‚ Spans[]    â”‚ O(n)        â”‚
â”‚  æ¨¡ç³Šæœç´¢      â”‚ æ¨¡ç³Šæ¡ä»¶    â”‚ Spans[]    â”‚ O(n)        â”‚
â”‚  è¯­ä¹‰æœç´¢      â”‚ è¯­ä¹‰æŸ¥è¯¢    â”‚ Spans[]    â”‚ O(n log n)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” æ•°æ®æ£€ç´¢

### IDæ£€ç´¢

```protobuf
// IDæ£€ç´¢å®šä¹‰
message TraceQuery {
  bytes trace_id = 1;              // Trace ID
  bytes span_id = 2;               // Span ID (å¯é€‰)
  string service_name = 3;         // æœåŠ¡åç§° (å¯é€‰)
}

message TraceResult {
  Trace trace = 1;                 // Traceç»“æœ
  repeated Span spans = 2;         // Spanæ•°ç»„
}

// IDæ£€ç´¢ç¤ºä¾‹
trace_query = {
  trace_id: "abc123"
}

trace_result = {
  trace: {
    trace_id: "abc123",
    spans: [
      {
        trace_id: "abc123",
        span_id: "001",
        name: "Root Span"
      },
      {
        trace_id: "abc123",
        span_id: "002",
        name: "Child Span"
      }
    ]
  }
}
```

### å±æ€§æ£€ç´¢

```protobuf
// å±æ€§æ£€ç´¢å®šä¹‰
message AttributeQuery {
  repeated KeyValue attributes = 1; // å±æ€§é”®å€¼å¯¹
  string operator = 2;              // æ“ä½œç¬¦ (AND/OR)
}

message AttributeResult {
  repeated Span spans = 1;         // åŒ¹é…çš„Spanæ•°ç»„
  int32 total_count = 2;            // æ€»æ•°é‡
}

// å±æ€§æ£€ç´¢ç¤ºä¾‹
attribute_query = {
  attributes: [
    {key: "service.name", value: "user-service"},
    {key: "http.status_code", value: "500"}
  ],
  operator: "AND"
}

attribute_result = {
  spans: [
    {
      trace_id: "abc123",
      span_id: "001",
      name: "GET /api/users",
      attributes: [
        {key: "service.name", value: "user-service"},
        {key: "http.status_code", value: "500"}
      ]
    }
  ],
  total_count: 1
}
```

### æ—¶é—´æ£€ç´¢

```protobuf
// æ—¶é—´æ£€ç´¢å®šä¹‰
message TimeQuery {
  int64 start_time = 1;            // å¼€å§‹æ—¶é—´
  int64 end_time = 2;               // ç»“æŸæ—¶é—´
  string time_range = 3;            // æ—¶é—´èŒƒå›´ (1h/24h/7d)
}

message TimeResult {
  repeated Span spans = 1;          // æ—¶é—´èŒƒå›´å†…çš„Spanæ•°ç»„
  int32 total_count = 2;            // æ€»æ•°é‡
}

// æ—¶é—´æ£€ç´¢ç¤ºä¾‹
time_query = {
  start_time: 1609459200000000000,  // 2021-01-01 00:00:00
  end_time: 1609545600000000000,   // 2021-01-02 00:00:00
  time_range: "24h"
}

time_result = {
  spans: [
    {
      trace_id: "abc123",
      span_id: "001",
      name: "GET /api/users",
      start_time_unix_nano: 1609459200000000000,
      end_time_unix_nano: 1609459210000000000
    }
  ],
  total_count: 1
}
```

---

## ğŸ” æ•°æ®æœç´¢

### å…¨æ–‡æœç´¢

```protobuf
// å…¨æ–‡æœç´¢å®šä¹‰
message FullTextQuery {
  string query = 1;                 // æœç´¢æŸ¥è¯¢
  repeated string fields = 2;       // æœç´¢å­—æ®µ
  int32 limit = 3;                  // ç»“æœé™åˆ¶
  int32 offset = 4;                  // åç§»é‡
}

message FullTextResult {
  repeated Span spans = 1;          // åŒ¹é…çš„Spanæ•°ç»„
  int32 total_count = 2;            // æ€»æ•°é‡
  repeated float scores = 3;        // ç›¸å…³æ€§åˆ†æ•°
}

// å…¨æ–‡æœç´¢ç¤ºä¾‹
full_text_query = {
  query: "database connection failed",
  fields: ["name", "attributes", "events"],
  limit: 10,
  offset: 0
}

full_text_result = {
  spans: [
    {
      trace_id: "abc123",
      span_id: "001",
      name: "Database Connection",
      events: [
        {
          name: "exception",
          attributes: [
            {key: "exception.message", value: "database connection failed"}
          ]
        }
      ]
    }
  ],
  total_count: 1,
  scores: [0.95]
}
```

### æ¨¡ç³Šæœç´¢

```protobuf
// æ¨¡ç³Šæœç´¢å®šä¹‰
message FuzzyQuery {
  string query = 1;                 // æœç´¢æŸ¥è¯¢
  float fuzziness = 2;              // æ¨¡ç³Šåº¦ (0.0-2.0)
  repeated string fields = 3;       // æœç´¢å­—æ®µ
}

message FuzzyResult {
  repeated Span spans = 1;          // åŒ¹é…çš„Spanæ•°ç»„
  int32 total_count = 2;            // æ€»æ•°é‡
}

// æ¨¡ç³Šæœç´¢ç¤ºä¾‹
fuzzy_query = {
  query: "user servce",             // æ•…æ„æ‹¼å†™é”™è¯¯
  fuzziness: 0.7,
  fields: ["service.name"]
}

fuzzy_result = {
  spans: [
    {
      trace_id: "abc123",
      span_id: "001",
      name: "GET /api/users",
      attributes: [
        {key: "service.name", value: "user-service"}
      ]
    }
  ],
  total_count: 1
}
```

### è¯­ä¹‰æœç´¢

```protobuf
// è¯­ä¹‰æœç´¢å®šä¹‰
message SemanticQuery {
  string query = 1;                 // è¯­ä¹‰æŸ¥è¯¢
  string semantic_type = 2;        // è¯­ä¹‰ç±»å‹ (error/performance/business)
  repeated string fields = 3;       // æœç´¢å­—æ®µ
}

message SemanticResult {
  repeated Span spans = 1;          // åŒ¹é…çš„Spanæ•°ç»„
  int32 total_count = 2;            // æ€»æ•°é‡
  repeated float semantic_scores = 3; // è¯­ä¹‰ç›¸å…³æ€§åˆ†æ•°
}

// è¯­ä¹‰æœç´¢ç¤ºä¾‹
semantic_query = {
  query: "slow response time",
  semantic_type: "performance",
  fields: ["name", "attributes"]
}

semantic_result = {
  spans: [
    {
      trace_id: "abc123",
      span_id: "001",
      name: "GET /api/users",
      attributes: [
        {key: "http.duration", value: "5000ms"}
      ]
    }
  ],
  total_count: 1,
  semantic_scores: [0.92]
}
```

---

## ğŸ“ˆ æ£€ç´¢æœç´¢æ€§èƒ½åˆ†æ

### æ£€ç´¢æœç´¢æ€§èƒ½åŸºå‡†æµ‹è¯•

```text
æ£€ç´¢æœç´¢æ€§èƒ½åŸºå‡†æµ‹è¯• (1,000,000 Spans):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ“ä½œç±»å‹      â”‚ è€—æ—¶      â”‚ å†…å­˜      â”‚ å¤æ‚åº¦      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  IDæ£€ç´¢        â”‚ 1ms      â”‚ 1 MB     â”‚ O(1)        â”‚
â”‚  å±æ€§æ£€ç´¢      â”‚ 50ms     â”‚ 10 MB    â”‚ O(log n)    â”‚
â”‚  æ—¶é—´æ£€ç´¢      â”‚ 80ms     â”‚ 15 MB    â”‚ O(log n)    â”‚
â”‚  å…¨æ–‡æœç´¢      â”‚ 200ms    â”‚ 50 MB    â”‚ O(n)        â”‚
â”‚  æ¨¡ç³Šæœç´¢      â”‚ 250ms    â”‚ 60 MB    â”‚ O(n)        â”‚
â”‚  è¯­ä¹‰æœç´¢      â”‚ 500ms    â”‚ 100 MB   â”‚ O(n log n)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš¡ æ£€ç´¢æœç´¢ä¼˜åŒ–ç­–ç•¥

### 1. ç´¢å¼•ç­–ç•¥

```go
// ç´¢å¼•ç­–ç•¥
package main

import (
    "sync"
    "github.com/blevesearch/bleve"
)

type SearchIndex struct {
    index bleve.Index
    mutex sync.RWMutex
}

func NewSearchIndex() (*SearchIndex, error) {
    // åˆ›å»ºBleveç´¢å¼•
    mapping := bleve.NewIndexMapping()

    index, err := bleve.New("spans.bleve", mapping)
    if err != nil {
        return nil, err
    }

    return &SearchIndex{
        index: index,
    }, nil
}

func (si *SearchIndex) IndexSpan(span *trace.Span) error {
    si.mutex.Lock()
    defer si.mutex.Unlock()

    // ç´¢å¼•Span
    return si.index.Index(string(span.SpanId), span)
}

func (si *SearchIndex) Search(query string) ([]*trace.Span, error) {
    si.mutex.RLock()
    defer si.mutex.RUnlock()

    // æœç´¢
    searchRequest := bleve.NewSearchRequest(bleve.NewQueryStringQuery(query))
    searchResult, err := si.index.Search(searchRequest)
    if err != nil {
        return nil, err
    }

    // è§£æç»“æœ
    spans := make([]*trace.Span, 0)
    for _, hit := range searchResult.Hits {
        doc, err := si.index.Document(hit.ID)
        if err != nil {
            continue
        }

        span := docToSpan(doc)
        spans = append(spans, span)
    }

    return spans, nil
}
```

### 2. ç¼“å­˜ç­–ç•¥

```go
// ç¼“å­˜ç­–ç•¥
package main

import (
    "sync"
    "time"
    "github.com/patrickmn/go-cache"
)

type SearchCache struct {
    cache *cache.Cache
    mutex sync.RWMutex
}

func NewSearchCache() *SearchCache {
    return &SearchCache{
        cache: cache.New(5*time.Minute, 10*time.Minute),
    }
}

func (sc *SearchCache) Get(query string) ([]*trace.Span, bool) {
    sc.mutex.RLock()
    defer sc.mutex.RUnlock()

    if result, found := sc.cache.Get(query); found {
        return result.([]*trace.Span), true
    }

    return nil, false
}

func (sc *SearchCache) Set(query string, spans []*trace.Span) {
    sc.mutex.Lock()
    defer sc.mutex.Unlock()

    sc.cache.Set(query, spans, cache.DefaultExpiration)
}

func (sc *SearchCache) Invalidate(pattern string) {
    sc.mutex.Lock()
    defer sc.mutex.Unlock()

    sc.cache.Delete(pattern)
}
```

### 3. åˆ†ç‰‡ç­–ç•¥

```go
// åˆ†ç‰‡ç­–ç•¥
package main

import (
    "sync"
    "hash/fnv"
)

type ShardedSearchIndex struct {
    shards []*SearchIndex
    mutex  sync.RWMutex
}

func NewShardedSearchIndex(shardCount int) (*ShardedSearchIndex, error) {
    shards := make([]*SearchIndex, shardCount)

    for i := 0; i < shardCount; i++ {
        index, err := NewSearchIndex()
        if err != nil {
            return nil, err
        }
        shards[i] = index
    }

    return &ShardedSearchIndex{
        shards: shards,
    }, nil
}

func (ssi *ShardedSearchIndex) getShard(key string) *SearchIndex {
    h := fnv.New32a()
    h.Write([]byte(key))
    shardIndex := int(h.Sum32()) % len(ssi.shards)
    return ssi.shards[shardIndex]
}

func (ssi *ShardedSearchIndex) IndexSpan(span *trace.Span) error {
    shard := ssi.getShard(string(span.SpanId))
    return shard.IndexSpan(span)
}

func (ssi *ShardedSearchIndex) Search(query string) ([]*trace.Span, error) {
    ssi.mutex.RLock()
    defer ssi.mutex.RUnlock()

    // å¹¶è¡Œæœç´¢æ‰€æœ‰åˆ†ç‰‡
    results := make(chan []*trace.Span, len(ssi.shards))
    errors := make(chan error, len(ssi.shards))

    for _, shard := range ssi.shards {
        go func(s *SearchIndex) {
            spans, err := s.Search(query)
            if err != nil {
                errors <- err
                return
            }
            results <- spans
        }(shard)
    }

    // æ”¶é›†ç»“æœ
    allSpans := make([]*trace.Span, 0)
    for i := 0; i < len(ssi.shards); i++ {
        select {
        case spans := <-results:
            allSpans = append(allSpans, spans...)
        case err := <-errors:
            return nil, err
        }
    }

    return allSpans, nil
}
```

---

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šç”µå•†ç³»ç»Ÿè®¢å•æ£€ç´¢

```go
// ç”µå•†ç³»ç»Ÿè®¢å•æ£€ç´¢
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type ECommerceSearchEngine struct {
    index *SearchIndex
    cache *SearchCache
}

func NewECommerceSearchEngine() (*ECommerceSearchEngine, error) {
    index, err := NewSearchIndex()
    if err != nil {
        return nil, err
    }

    return &ECommerceSearchEngine{
        index: index,
        cache: NewSearchCache(),
    }, nil
}

func (ecse *ECommerceSearchEngine) SearchOrderByID(orderID string) (*OrderTrace, error) {
    // æ£€æŸ¥ç¼“å­˜
    if spans, found := ecse.cache.Get("order:" + orderID); found {
        return &OrderTrace{
            OrderID: orderID,
            Spans:   spans,
        }, nil
    }

    // æœç´¢ç´¢å¼•
    query := "order.id:" + orderID
    spans, err := ecse.index.Search(query)
    if err != nil {
        return nil, err
    }

    // æ›´æ–°ç¼“å­˜
    ecse.cache.Set("order:"+orderID, spans)

    return &OrderTrace{
        OrderID: orderID,
        Spans:   spans,
    }, nil
}

func (ecse *ECommerceSearchEngine) SearchOrderByUser(userID string) ([]*OrderTrace, error) {
    // æœç´¢ç´¢å¼•
    query := "user.id:" + userID
    spans, err := ecse.index.Search(query)
    if err != nil {
        return nil, err
    }

    // æŒ‰è®¢å•åˆ†ç»„
    orderMap := make(map[string][]*trace.Span)
    for _, span := range spans {
        orderID := getOrderIDFromSpan(span)
        orderMap[orderID] = append(orderMap[orderID], span)
    }

    // æ„å»ºç»“æœ
    results := make([]*OrderTrace, 0)
    for orderID, orderSpans := range orderMap {
        results = append(results, &OrderTrace{
            OrderID: orderID,
            Spans:   orderSpans,
        })
    }

    return results, nil
}

type OrderTrace struct {
    OrderID string
    Spans   []*trace.Span
}
```

### æ¡ˆä¾‹2ï¼šå¾®æœåŠ¡ç³»ç»Ÿé“¾è·¯æœç´¢

```go
// å¾®æœåŠ¡ç³»ç»Ÿé“¾è·¯æœç´¢
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type MicroserviceLinkSearch struct {
    index *ShardedSearchIndex
    cache *SearchCache
}

func NewMicroserviceLinkSearch() (*MicroserviceLinkSearch, error) {
    index, err := NewShardedSearchIndex(8)
    if err != nil {
        return nil, err
    }

    return &MicroserviceLinkSearch{
        index: index,
        cache: NewSearchCache(),
    }, nil
}

func (mls *MicroserviceLinkSearch) SearchTraceByError(traceID string) (*ErrorTrace, error) {
    // æ£€æŸ¥ç¼“å­˜
    if spans, found := mls.cache.Get("error:" + traceID); found {
        return &ErrorTrace{
            TraceID: traceID,
            Spans:   spans,
        }, nil
    }

    // æœç´¢ç´¢å¼•
    query := "trace_id:" + traceID + " AND status:error"
    spans, err := mls.index.Search(query)
    if err != nil {
        return nil, err
    }

    // æ›´æ–°ç¼“å­˜
    mls.cache.Set("error:"+traceID, spans)

    return &ErrorTrace{
        TraceID: traceID,
        Spans:   spans,
    }, nil
}

func (mls *MicroserviceLinkSearch) SearchSlowTraces(durationThreshold time.Duration) ([]*SlowTrace, error) {
    // æœç´¢ç´¢å¼•
    query := "duration:>" + durationThreshold.String()
    spans, err := mls.index.Search(query)
    if err != nil {
        return nil, err
    }

    // æŒ‰Traceåˆ†ç»„
    traceMap := make(map[string][]*trace.Span)
    for _, span := range spans {
        traceID := string(span.TraceId)
        traceMap[traceID] = append(traceMap[traceID], span)
    }

    // æ„å»ºç»“æœ
    results := make([]*SlowTrace, 0)
    for traceID, traceSpans := range traceMap {
        totalDuration := calculateTotalDuration(traceSpans)
        results = append(results, &SlowTrace{
            TraceID:       traceID,
            Spans:         traceSpans,
            TotalDuration: totalDuration,
        })
    }

    return results, nil
}

type ErrorTrace struct {
    TraceID string
    Spans   []*trace.Span
}

type SlowTrace struct {
    TraceID       string
    Spans         []*trace.Span
    TotalDuration time.Duration
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### æ£€ç´¢æœç´¢ä¼˜åŒ–çŸ©é˜µ

```text
æ£€ç´¢æœç´¢ä¼˜åŒ–çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–é¡¹          â”‚ ç­–ç•¥                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç´¢å¼•ç­–ç•¥        â”‚ Bæ ‘ç´¢å¼• (æå‡æŸ¥è¯¢æ€§èƒ½)                  â”‚
â”‚  ç¼“å­˜ç­–ç•¥        â”‚ LRUç¼“å­˜ (é™ä½æŸ¥è¯¢å»¶è¿Ÿ)                 â”‚
â”‚  åˆ†ç‰‡ç­–ç•¥        â”‚ åˆ†ç‰‡ç´¢å¼• (æå‡ååé‡)                   â”‚
â”‚  å¹¶è¡Œç­–ç•¥        â”‚ å¹¶è¡Œæœç´¢ (æå‡æ€§èƒ½)                     â”‚
â”‚  å‹ç¼©ç­–ç•¥        â”‚ å‹ç¼©å­˜å‚¨ (é™ä½å­˜å‚¨æˆæœ¬)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ æ€»ç»“

**æ•°æ®æ£€ç´¢ä¸æœç´¢**æ˜¯OTLPè¯­ä¹‰æ¨¡å‹çš„æ ¸å¿ƒèƒ½åŠ›ï¼š

1. **æ•°æ®æ£€ç´¢**ï¼šIDæ£€ç´¢ + å±æ€§æ£€ç´¢ + æ—¶é—´æ£€ç´¢
2. **æ•°æ®æœç´¢**ï¼šå…¨æ–‡æœç´¢ + æ¨¡ç³Šæœç´¢ + è¯­ä¹‰æœç´¢
3. **ç´¢å¼•ç­–ç•¥**ï¼šBæ ‘ç´¢å¼• + å“ˆå¸Œç´¢å¼• + å€’æ’ç´¢å¼•
4. **ä¼˜åŒ–ç­–ç•¥**ï¼šç¼“å­˜ + åˆ†ç‰‡ + å¹¶è¡Œ

**å…³é”®è¦ç‚¹**ï¼š

- âœ… IDæ£€ç´¢æ€§èƒ½æœ€ä¼˜ (O(1))
- âœ… å±æ€§æ£€ç´¢ä½¿ç”¨ç´¢å¼• (O(log n))
- âœ… å…¨æ–‡æœç´¢æ”¯æŒå¤æ‚æŸ¥è¯¢
- âœ… æ¨¡ç³Šæœç´¢å®¹é”™æ€§å¼º
- âœ… è¯­ä¹‰æœç´¢ç†è§£æ„å›¾
- âœ… ç¼“å­˜ç­–ç•¥é™ä½å»¶è¿Ÿ
- âœ… åˆ†ç‰‡ç­–ç•¥æå‡ååé‡

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ
