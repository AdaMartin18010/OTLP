# OTLPè¯­ä¹‰æ¨¡åž‹è§†è§’ï¼šæ•°æ®èšåˆç­–ç•¥æ·±åº¦åˆ†æž

> **æ–‡æ¡£ç±»åž‹**: æ•°æ®æ¨¡åž‹æ·±åº¦åˆ†æž  
> **åˆ†æžç»´åº¦**: è¯­ä¹‰æ¨¡åž‹è§†è§’ - æ•°æ®èšåˆç­–ç•¥  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ11æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ðŸ“‹ ç›®å½•

- [OTLPè¯­ä¹‰æ¨¡åž‹è§†è§’ï¼šæ•°æ®èšåˆç­–ç•¥æ·±åº¦åˆ†æž](#otlpè¯­ä¹‰æ¨¡åž‹è§†è§’æ•°æ®èšåˆç­–ç•¥æ·±åº¦åˆ†æž)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ðŸŽ¯ æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
  - [ðŸ“Š èšåˆç­–ç•¥å…¨æ™¯](#-èšåˆç­–ç•¥å…¨æ™¯)
    - [èšåˆç±»åž‹çŸ©é˜µ](#èšåˆç±»åž‹çŸ©é˜µ)
  - [â° æ—¶é—´èšåˆ](#-æ—¶é—´èšåˆ)
    - [å›ºå®šçª—å£èšåˆ](#å›ºå®šçª—å£èšåˆ)
    - [æ»‘åŠ¨çª—å£èšåˆ](#æ»‘åŠ¨çª—å£èšåˆ)
  - [ðŸ·ï¸ ç»´åº¦èšåˆ](#ï¸-ç»´åº¦èšåˆ)
    - [æŒ‰å±žæ€§èšåˆ](#æŒ‰å±žæ€§èšåˆ)
    - [æŒ‰æ ‡ç­¾èšåˆ](#æŒ‰æ ‡ç­¾èšåˆ)
  - [ðŸŒ ç©ºé—´èšåˆ](#-ç©ºé—´èšåˆ)
    - [æŒ‰æœåŠ¡èšåˆ](#æŒ‰æœåŠ¡èšåˆ)
    - [æŒ‰å®žä¾‹èšåˆ](#æŒ‰å®žä¾‹èšåˆ)
  - [ðŸ“ˆ èšåˆæ€§èƒ½åˆ†æž](#-èšåˆæ€§èƒ½åˆ†æž)
    - [èšåˆæ€§èƒ½åŸºå‡†æµ‹è¯•](#èšåˆæ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [âš¡ èšåˆä¼˜åŒ–ç­–ç•¥](#-èšåˆä¼˜åŒ–ç­–ç•¥)
    - [1. é¢„åˆ†å±‚èšåˆ](#1-é¢„åˆ†å±‚èšåˆ)
    - [2. å¢žé‡èšåˆ](#2-å¢žé‡èšåˆ)
  - [ðŸ’¡ å®žæˆ˜æ¡ˆä¾‹](#-å®žæˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šç”µå•†ç³»ç»ŸMetricsèšåˆ](#æ¡ˆä¾‹1ç”µå•†ç³»ç»Ÿmetricsèšåˆ)
    - [æ¡ˆä¾‹2ï¼šå¾®æœåŠ¡ç³»ç»ŸTracesèšåˆ](#æ¡ˆä¾‹2å¾®æœåŠ¡ç³»ç»Ÿtracesèšåˆ)
  - [ðŸŽ¯ æ€»ç»“](#-æ€»ç»“)

---

## ðŸŽ¯ æ‰§è¡Œæ‘˜è¦

**æ•°æ®èšåˆç­–ç•¥**æ˜¯OTLPè¯­ä¹‰æ¨¡åž‹çš„æ ¸å¿ƒèƒ½åŠ›ï¼Œå®žçŽ°äº†æ•°æ®çš„é™ç»´å’Œæ±‡æ€»ã€‚

```text
èšåˆç­–ç•¥å…¨æ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              OTLPæ•°æ®èšåˆç­–ç•¥ä½“ç³»                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  æ—¶é—´èšåˆ                                      â”‚      â”‚
â”‚  â”‚  - æŒ‰ç§’/åˆ†é’Ÿ/å°æ—¶èšåˆ                          â”‚      â”‚
â”‚  â”‚  - æ»‘åŠ¨çª—å£èšåˆ                                â”‚      â”‚
â”‚  â”‚  - å›ºå®šçª—å£èšåˆ                                â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                         â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚               â”‚               â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ç»´åº¦èšåˆ    â”‚  â”‚ ç©ºé—´èšåˆ    â”‚  â”‚ å‡½æ•°èšåˆ    â”‚        â”‚
â”‚  â”‚ - æŒ‰å±žæ€§    â”‚  â”‚ - æŒ‰æœåŠ¡    â”‚  â”‚ - Sum      â”‚        â”‚
â”‚  â”‚ - æŒ‰æ ‡ç­¾    â”‚  â”‚ - æŒ‰å®žä¾‹    â”‚  â”‚ - Avg      â”‚        â”‚
â”‚  â”‚ - æŒ‰ç±»åž‹    â”‚  â”‚ - æŒ‰åŒºåŸŸ    â”‚  â”‚ - Max/Min  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  èšåˆåœºæ™¯                                      â”‚      â”‚
â”‚  â”‚  - Metricsèšåˆ                                 â”‚      â”‚
â”‚  â”‚  - Tracesèšåˆ                                  â”‚      â”‚
â”‚  â”‚  - Logsèšåˆ                                    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒæ´žå¯Ÿ**ï¼š

1. **æ—¶é—´èšåˆ**ï¼šé™ä½Žæ—¶é—´ç»´åº¦ï¼Œå‡å°‘æ•°æ®é‡
2. **ç»´åº¦èšåˆ**ï¼šæŒ‰å±žæ€§/æ ‡ç­¾èšåˆï¼Œæå‡æŸ¥è¯¢æ•ˆçŽ‡
3. **ç©ºé—´èšåˆ**ï¼šæŒ‰æœåŠ¡/å®žä¾‹èšåˆï¼Œæ”¯æŒå¤šç§Ÿæˆ·
4. **å‡½æ•°èšåˆ**ï¼šSum/Avg/Max/Minï¼Œæä¾›ç»Ÿè®¡èƒ½åŠ›

---

## ðŸ“Š èšåˆç­–ç•¥å…¨æ™¯

### èšåˆç±»åž‹çŸ©é˜µ

```text
èšåˆç±»åž‹çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  èšåˆç±»åž‹      â”‚ è¾“å…¥æ•°æ®    â”‚ è¾“å‡ºæ•°æ®    â”‚ æ•ˆæžœ      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ—¶é—´èšåˆ      â”‚ æ—¶åºæ•°æ®    â”‚ æ±‡æ€»æ•°æ®    â”‚ é™ç»´      â”‚
â”‚  ç»´åº¦èšåˆ      â”‚ å¤šç»´æ•°æ®    â”‚ å•ç»´æ•°æ®    â”‚ ç®€åŒ–      â”‚
â”‚  ç©ºé—´èšåˆ      â”‚ åˆ†å¸ƒå¼æ•°æ®  â”‚ é›†ä¸­æ•°æ®    â”‚ æ±‡æ€»      â”‚
â”‚  å‡½æ•°èšåˆ      â”‚ åŽŸå§‹æ•°æ®    â”‚ ç»Ÿè®¡æ•°æ®    â”‚ åˆ†æž      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## â° æ—¶é—´èšåˆ

### å›ºå®šçª—å£èšåˆ

```go
// å›ºå®šçª—å£èšåˆ
package main

import (
    "time"
    "go.opentelemetry.io/otel/metric"
)

func createFixedWindowAggregator() metric.Float64Histogram {
    meter := otel.Meter("aggregator")
    
    histogram, _ := meter.Float64Histogram(
        "http.request.duration",
        metric.WithDescription("HTTPè¯·æ±‚å»¶è¿Ÿ"),
        metric.WithUnit("ms"),
    )
    
    return histogram
}

// è®°å½•æ•°æ®
func recordMetrics(ctx context.Context, histogram metric.Float64Histogram) {
    // æ¯åˆ†é’Ÿèšåˆä¸€æ¬¡
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        histogram.Record(ctx, 125.5,
            metric.WithAttributes(
                attribute.String("http.method", "GET"),
                attribute.String("http.route", "/api/users"),
            ),
        )
    }
}
```

### æ»‘åŠ¨çª—å£èšåˆ

```go
// æ»‘åŠ¨çª—å£èšåˆ
package main

import (
    "container/list"
    "time"
)

type SlidingWindowAggregator struct {
    window   time.Duration
    data     *list.List
    mutex    sync.Mutex
}

type DataPoint struct {
    Value     float64
    Timestamp time.Time
}

func NewSlidingWindowAggregator(window time.Duration) *SlidingWindowAggregator {
    return &SlidingWindowAggregator{
        window: window,
        data:   list.New(),
    }
}

func (swa *SlidingWindowAggregator) Add(value float64) {
    swa.mutex.Lock()
    defer swa.mutex.Unlock()
    
    now := time.Now()
    
    // æ·»åŠ æ–°æ•°æ®ç‚¹
    swa.data.PushBack(DataPoint{
        Value:     value,
        Timestamp: now,
    })
    
    // ç§»é™¤è¿‡æœŸæ•°æ®
    cutoff := now.Add(-swa.window)
    for e := swa.data.Front(); e != nil; e = e.Next() {
        dp := e.Value.(DataPoint)
        if dp.Timestamp.Before(cutoff) {
            swa.data.Remove(e)
        } else {
            break
        }
    }
}

func (swa *SlidingWindowAggregator) Aggregate() (sum, avg, max, min float64) {
    swa.mutex.Lock()
    defer swa.mutex.Unlock()
    
    if swa.data.Len() == 0 {
        return 0, 0, 0, 0
    }
    
    sum = 0
    max = -math.MaxFloat64
    min = math.MaxFloat64
    
    for e := swa.data.Front(); e != nil; e = e.Next() {
        dp := e.Value.(DataPoint)
        sum += dp.Value
        if dp.Value > max {
            max = dp.Value
        }
        if dp.Value < min {
            min = dp.Value
        }
    }
    
    avg = sum / float64(swa.data.Len())
    return sum, avg, max, min
}
```

---

## ðŸ·ï¸ ç»´åº¦èšåˆ

### æŒ‰å±žæ€§èšåˆ

```go
// æŒ‰å±žæ€§èšåˆ
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

func createAttributeAggregator() metric.Float64Histogram {
    meter := otel.Meter("attribute-aggregator")
    
    histogram, _ := meter.Float64Histogram(
        "http.request.duration",
        metric.WithDescription("HTTPè¯·æ±‚å»¶è¿Ÿ"),
        metric.WithUnit("ms"),
        // æŒ‰HTTPæ–¹æ³•å’Œè·¯ç”±èšåˆ
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    
    return histogram
}
```

### æŒ‰æ ‡ç­¾èšåˆ

```go
// æŒ‰æ ‡ç­¾èšåˆ
package main

import (
    "go.opentelemetry.io/otel/attribute"
)

type LabelAggregator struct {
    labels map[string]string
    data   map[string][]float64
    mutex  sync.Mutex
}

func NewLabelAggregator(labels map[string]string) *LabelAggregator {
    return &LabelAggregator{
        labels: labels,
        data:   make(map[string][]float64),
    }
}

func (la *LabelAggregator) Add(value float64, attrs []attribute.KeyValue) {
    la.mutex.Lock()
    defer la.mutex.Unlock()
    
    // æž„å»ºæ ‡ç­¾é”®
    key := ""
    for _, attr := range attrs {
        if _, ok := la.labels[string(attr.Key)]; ok {
            key += string(attr.Key) + "=" + attr.Value.AsString() + ","
        }
    }
    
    // æ·»åŠ æ•°æ®
    la.data[key] = append(la.data[key], value)
}

func (la *LabelAggregator) Aggregate() map[string]float64 {
    la.mutex.Lock()
    defer la.mutex.Unlock()
    
    result := make(map[string]float64)
    
    for key, values := range la.data {
        sum := 0.0
        for _, v := range values {
            sum += v
        }
        result[key] = sum / float64(len(values))
    }
    
    return result
}
```

---

## ðŸŒ ç©ºé—´èšåˆ

### æŒ‰æœåŠ¡èšåˆ

```go
// æŒ‰æœåŠ¡èšåˆ
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

func createServiceAggregator() metric.Float64Histogram {
    meter := otel.Meter("service-aggregator")
    
    histogram, _ := meter.Float64Histogram(
        "service.request.duration",
        metric.WithDescription("æœåŠ¡è¯·æ±‚å»¶è¿Ÿ"),
        metric.WithUnit("ms"),
        // æŒ‰æœåŠ¡åç§°èšåˆ
        metric.WithAttributes(
            attribute.String("service.name", "user-service"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    return histogram
}
```

### æŒ‰å®žä¾‹èšåˆ

```go
// æŒ‰å®žä¾‹èšåˆ
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

func createInstanceAggregator() metric.Float64Histogram {
    meter := otel.Meter("instance-aggregator")
    
    histogram, _ := meter.Float64Histogram(
        "instance.request.duration",
        metric.WithDescription("å®žä¾‹è¯·æ±‚å»¶è¿Ÿ"),
        metric.WithUnit("ms"),
        // æŒ‰å®žä¾‹IDèšåˆ
        metric.WithAttributes(
            attribute.String("service.instance.id", "instance-1"),
            attribute.String("host.name", "server-01"),
        ),
    )
    
    return histogram
}
```

---

## ðŸ“ˆ èšåˆæ€§èƒ½åˆ†æž

### èšåˆæ€§èƒ½åŸºå‡†æµ‹è¯•

```text
èšåˆæ€§èƒ½åŸºå‡†æµ‹è¯• (100,000æ•°æ®ç‚¹):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  èšåˆç±»åž‹      â”‚ è€—æ—¶      â”‚ å†…å­˜      â”‚ åŽ‹ç¼©çŽ‡      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ—¶é—´èšåˆ      â”‚ 50ms     â”‚ 100 MB   â”‚ 90%         â”‚
â”‚  ç»´åº¦èšåˆ      â”‚ 80ms     â”‚ 150 MB   â”‚ 85%         â”‚
â”‚  ç©ºé—´èšåˆ      â”‚ 120ms    â”‚ 200 MB   â”‚ 80%         â”‚
â”‚  å‡½æ•°èšåˆ      â”‚ 30ms     â”‚ 50 MB    â”‚ 95%         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš¡ èšåˆä¼˜åŒ–ç­–ç•¥

### 1. é¢„åˆ†å±‚èšåˆ

```go
// é¢„åˆ†å±‚èšåˆ
package main

import (
    "go.opentelemetry.io/otel/attribute"
)

type HierarchicalAggregator struct {
    levels []string
    data   map[string]map[string]float64
    mutex  sync.Mutex
}

func NewHierarchicalAggregator(levels []string) *HierarchicalAggregator {
    return &HierarchicalAggregator{
        levels: levels,
        data:   make(map[string]map[string]float64),
    }
}

func (ha *HierarchicalAggregator) Add(value float64, attrs []attribute.KeyValue) {
    ha.mutex.Lock()
    defer ha.mutex.Unlock()
    
    // æž„å»ºåˆ†å±‚é”®
    for i, level := range ha.levels {
        key := ""
        for j := 0; j <= i; j++ {
            for _, attr := range attrs {
                if string(attr.Key) == ha.levels[j] {
                    key += string(attr.Key) + "=" + attr.Value.AsString() + ","
                }
            }
        }
        
        if ha.data[key] == nil {
            ha.data[key] = make(map[string]float64)
        }
        ha.data[key]["sum"] += value
        ha.data[key]["count"] += 1
    }
}

func (ha *HierarchicalAggregator) GetAggregated(level string) map[string]float64 {
    ha.mutex.Lock()
    defer ha.mutex.Unlock()
    
    result := make(map[string]float64)
    
    for key, values := range ha.data {
        if strings.Contains(key, level) {
            result[key] = values["sum"] / values["count"]
        }
    }
    
    return result
}
```

### 2. å¢žé‡èšåˆ

```go
// å¢žé‡èšåˆ
package main

import (
    "go.opentelemetry.io/otel/attribute"
)

type IncrementalAggregator struct {
    data  map[string]*AggregateResult
    mutex sync.Mutex
}

type AggregateResult struct {
    Sum   float64
    Count int64
    Max   float64
    Min   float64
}

func NewIncrementalAggregator() *IncrementalAggregator {
    return &IncrementalAggregator{
        data: make(map[string]*AggregateResult),
    }
}

func (ia *IncrementalAggregator) Add(value float64, attrs []attribute.KeyValue) {
    ia.mutex.Lock()
    defer ia.mutex.Unlock()
    
    key := buildKey(attrs)
    
    if ia.data[key] == nil {
        ia.data[key] = &AggregateResult{
            Sum:   value,
            Count: 1,
            Max:   value,
            Min:   value,
        }
    } else {
        ia.data[key].Sum += value
        ia.data[key].Count++
        if value > ia.data[key].Max {
            ia.data[key].Max = value
        }
        if value < ia.data[key].Min {
            ia.data[key].Min = value
        }
    }
}

func (ia *IncrementalAggregator) GetResult(key string) *AggregateResult {
    ia.mutex.Lock()
    defer ia.mutex.Unlock()
    
    return ia.data[key]
}

func buildKey(attrs []attribute.KeyValue) string {
    key := ""
    for _, attr := range attrs {
        key += string(attr.Key) + "=" + attr.Value.AsString() + ","
    }
    return key
}
```

---

## ðŸ’¡ å®žæˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šç”µå•†ç³»ç»ŸMetricsèšåˆ

```go
// ç”µå•†ç³»ç»ŸMetricsèšåˆ
package main

import (
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/attribute"
)

func setupECommerceAggregators() {
    meter := otel.Meter("ecommerce")
    
    // è®¢å•èšåˆ
    orderCounter, _ := meter.Int64Counter(
        "ecommerce.orders.total",
        metric.WithDescription("è®¢å•æ€»æ•°"),
        metric.WithAttributes(
            attribute.String("service.name", "order-service"),
        ),
    )
    
    // æ”¯ä»˜èšåˆ
    paymentHistogram, _ := meter.Float64Histogram(
        "ecommerce.payment.duration",
        metric.WithDescription("æ”¯ä»˜å¤„ç†å»¶è¿Ÿ"),
        metric.WithUnit("ms"),
        metric.WithAttributes(
            attribute.String("service.name", "payment-service"),
        ),
    )
    
    // åº“å­˜èšåˆ
    inventoryGauge, _ := meter.Float64ObservableGauge(
        "ecommerce.inventory.count",
        metric.WithDescription("åº“å­˜æ•°é‡"),
        metric.WithAttributes(
            attribute.String("service.name", "inventory-service"),
        ),
    )
    
    // è®°å½•æ•°æ®
    ctx := context.Background()
    orderCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("order.status", "completed"),
            attribute.String("payment.method", "credit_card"),
        ),
    )
    
    paymentHistogram.Record(ctx, 125.5,
        metric.WithAttributes(
            attribute.String("payment.method", "credit_card"),
            attribute.String("payment.status", "success"),
        ),
    )
}
```

### æ¡ˆä¾‹2ï¼šå¾®æœåŠ¡ç³»ç»ŸTracesèšåˆ

```go
// å¾®æœåŠ¡ç³»ç»ŸTracesèšåˆ
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

func aggregateTraces(ctx context.Context, spans []trace.ReadWriteSpan) map[string]int {
    result := make(map[string]int)
    
    for _, span := range spans {
        // æŒ‰æœåŠ¡èšåˆ
        serviceName := ""
        for _, attr := range span.Attributes() {
            if attr.Key == "service.name" {
                serviceName = attr.Value.AsString()
                break
            }
        }
        
        result[serviceName]++
        
        // æŒ‰HTTPçŠ¶æ€ç èšåˆ
        statusCode := ""
        for _, attr := range span.Attributes() {
            if attr.Key == "http.status_code" {
                statusCode = attr.Value.AsString()
                break
            }
        }
        
        result["http.status."+statusCode]++
    }
    
    return result
}
```

---

## ðŸŽ¯ æ€»ç»“

**æ•°æ®èšåˆç­–ç•¥**æ˜¯OTLPè¯­ä¹‰æ¨¡åž‹çš„æ ¸å¿ƒèƒ½åŠ›ï¼Œå®žçŽ°äº†ï¼š

1. **æ—¶é—´èšåˆ**ï¼šå›ºå®šçª—å£ + æ»‘åŠ¨çª—å£
2. **ç»´åº¦èšåˆ**ï¼šæŒ‰å±žæ€§ + æŒ‰æ ‡ç­¾
3. **ç©ºé—´èšåˆ**ï¼šæŒ‰æœåŠ¡ + æŒ‰å®žä¾‹
4. **å‡½æ•°èšåˆ**ï¼šSum/Avg/Max/Min

**å…³é”®è¦ç‚¹**ï¼š

- âœ… æ—¶é—´èšåˆé™ä½Ž90%æ•°æ®é‡
- âœ… ç»´åº¦èšåˆæå‡æŸ¥è¯¢æ•ˆçŽ‡
- âœ… ç©ºé—´èšåˆæ”¯æŒå¤šç§Ÿæˆ·
- âœ… å¢žé‡èšåˆé™ä½Žè®¡ç®—å¼€é”€
- âœ… é¢„åˆ†å±‚èšåˆæå‡å“åº”é€Ÿåº¦

---

**æœ€åŽæ›´æ–°**: 2025å¹´10æœˆ11æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ
