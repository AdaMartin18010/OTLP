# OTLPä¸šåŠ¡é›†æˆå®æˆ˜ï¼šOTLPä¸ä¸šåŠ¡ç³»ç»Ÿèåˆæ¡ˆä¾‹

> **OTLPç‰ˆæœ¬**: v1.0.0 (Stable)
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥
> **é›†æˆç›®æ ‡**: ç”µå•†ã€é‡‘èã€ç‰©æµã€åˆ¶é€ å››å¤§è¡Œä¸šå®Œæ•´é›†æˆæ–¹æ¡ˆ
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [OTLPä¸šåŠ¡é›†æˆå®æˆ˜ï¼šOTLPä¸ä¸šåŠ¡ç³»ç»Ÿèåˆæ¡ˆä¾‹](#otlpä¸šåŠ¡é›†æˆå®æˆ˜otlpä¸ä¸šåŠ¡ç³»ç»Ÿèåˆæ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
  - [ğŸ“Š ä¸šåŠ¡é›†æˆæ¡†æ¶](#-ä¸šåŠ¡é›†æˆæ¡†æ¶)
    - [é›†æˆå±‚æ¬¡](#é›†æˆå±‚æ¬¡)
    - [é›†æˆæ¨¡å¼](#é›†æˆæ¨¡å¼)
  - [ğŸ›’ ç”µå•†ç³»ç»Ÿé›†æˆ](#-ç”µå•†ç³»ç»Ÿé›†æˆ)
    - [1. è®¢å•å¤„ç†è¿½è¸ª](#1-è®¢å•å¤„ç†è¿½è¸ª)
    - [2. ç”µå•†ä¸šåŠ¡æŒ‡æ ‡](#2-ç”µå•†ä¸šåŠ¡æŒ‡æ ‡)
  - [ğŸ’° é‡‘èç³»ç»Ÿé›†æˆ](#-é‡‘èç³»ç»Ÿé›†æˆ)
    - [1. äº¤æ˜“å¤„ç†è¿½è¸ª](#1-äº¤æ˜“å¤„ç†è¿½è¸ª)
  - [ğŸ“¦ ç‰©æµç³»ç»Ÿé›†æˆ](#-ç‰©æµç³»ç»Ÿé›†æˆ)
    - [1. è®¢å•é…é€è¿½è¸ª](#1-è®¢å•é…é€è¿½è¸ª)
  - [ğŸ’¡ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. ä¸šåŠ¡é›†æˆæœ€ä½³å®è·µ](#1-ä¸šåŠ¡é›†æˆæœ€ä½³å®è·µ)
    - [2. æ€§èƒ½ä¼˜åŒ–å»ºè®®](#2-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## ğŸ¯ æ‰§è¡Œæ‘˜è¦

**OTLPä¸šåŠ¡é›†æˆå®æˆ˜**æä¾›äº†å››å¤§è¡Œä¸šçš„å®Œæ•´é›†æˆæ–¹æ¡ˆï¼Œå±•ç¤ºå¦‚ä½•å°†OTLPä¸ä¸šåŠ¡ç³»ç»Ÿæ·±åº¦èåˆï¼š

```text
é›†æˆç›®æ ‡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ä¸šåŠ¡é›†æˆå››å¤§ç›®æ ‡                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ğŸ“Š ä¸šåŠ¡è¿½è¸ª: ç«¯åˆ°ç«¯ä¸šåŠ¡è¿½è¸ª                      â”‚
â”‚  ğŸ” é—®é¢˜å®šä½: å¿«é€Ÿå®šä½ä¸šåŠ¡é—®é¢˜                    â”‚
â”‚  ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–: è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ                        â”‚
â”‚  ğŸ’° æˆæœ¬æ§åˆ¶: ä¼˜åŒ–å¯è§‚æµ‹æ€§æˆæœ¬                    â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**é›†æˆè¡Œä¸š**ï¼š

1. **ç”µå•†ç³»ç»Ÿ**ï¼šè®¢å•å¤„ç†ã€æ”¯ä»˜ã€åº“å­˜ç®¡ç†
2. **é‡‘èç³»ç»Ÿ**ï¼šäº¤æ˜“å¤„ç†ã€é£æ§ã€åˆè§„æ£€æŸ¥
3. **ç‰©æµç³»ç»Ÿ**ï¼šè®¢å•é…é€ã€ä»“å‚¨ç®¡ç†ã€è¿è¾“è¿½è¸ª
4. **åˆ¶é€ ç³»ç»Ÿ**ï¼šç”Ÿäº§è®¡åˆ’ã€è´¨é‡æ§åˆ¶ã€è®¾å¤‡ç›‘æ§

---

## ğŸ“Š ä¸šåŠ¡é›†æˆæ¡†æ¶

### é›†æˆå±‚æ¬¡

```text
OTLPä¸šåŠ¡é›†æˆå±‚æ¬¡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             ä¸šåŠ¡å±‚é›†æˆ                           â”‚
â”‚  - ä¸šåŠ¡äº‹ä»¶è¿½è¸ª (Business Event Tracing)         â”‚
â”‚  - ä¸šåŠ¡æµç¨‹ç›‘æ§ (Business Process Monitoring)    â”‚
â”‚  - ä¸šåŠ¡æŒ‡æ ‡ç»Ÿè®¡ (Business Metrics)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             åº”ç”¨å±‚é›†æˆ                           â”‚
â”‚  - ä¸šåŠ¡å±æ€§æ³¨å…¥ (Business Attributes)            â”‚
â”‚  - ä¸šåŠ¡è¯­ä¹‰çº¦å®š (Business Semantics)             â”‚
â”‚  - ä¸šåŠ¡æ¨¡å‹æ˜ å°„ (Business Model Mapping)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             æ•°æ®å±‚é›†æˆ                           â”‚
â”‚  - OTLPæ•°æ®æ¨¡å‹ (OTLP Data Model)                â”‚
â”‚  - ä¸šåŠ¡æ•°æ®æ¨¡å‹ (Business Data Model)            â”‚
â”‚  - æ•°æ®è½¬æ¢å±‚ (Data Transformation Layer)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             å­˜å‚¨å±‚é›†æˆ                           â”‚
â”‚  - OTLPå­˜å‚¨ (OTLP Storage)                       â”‚
â”‚  - ä¸šåŠ¡æ•°æ®å­˜å‚¨ (Business Data Storage)          â”‚
â”‚  - æ•°æ®å…³è” (Data Correlation)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é›†æˆæ¨¡å¼

```text
å®šä¹‰ (ä¸šåŠ¡é›†æˆæ¨¡å¼):
BusinessIntegrationPattern = {
  event_tracing: bool,      // äº‹ä»¶è¿½è¸ª
  process_monitoring: bool, // æµç¨‹ç›‘æ§
  metrics_collection: bool, // æŒ‡æ ‡æ”¶é›†
  log_correlation: bool     // æ—¥å¿—å…³è”
}

é›†æˆæ¨¡å¼:
âœ… äº‹ä»¶è¿½è¸ª: è¿½è¸ªå…³é”®ä¸šåŠ¡äº‹ä»¶
âœ… æµç¨‹ç›‘æ§: ç›‘æ§ä¸šåŠ¡æµç¨‹çŠ¶æ€
âœ… æŒ‡æ ‡æ”¶é›†: æ”¶é›†ä¸šåŠ¡æŒ‡æ ‡
âœ… æ—¥å¿—å…³è”: å…³è”ä¸šåŠ¡æ—¥å¿—
```

---

## ğŸ›’ ç”µå•†ç³»ç»Ÿé›†æˆ

### 1. è®¢å•å¤„ç†è¿½è¸ª

**è®¢å•å¤„ç†æµç¨‹**ï¼š

```text
è®¢å•å¤„ç†æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·ä¸‹å• â†’ åº“å­˜æ£€æŸ¥ â†’ æ”¯ä»˜å¤„ç† â†’ è®¢å•ç¡®è®¤ â†’ å‘è´§â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  1. ç”¨æˆ·ä¸‹å• (order-service)                    â”‚
â”‚     â”œâ”€ åˆ›å»ºè®¢å•                                 â”‚
â”‚     â”œâ”€ éªŒè¯å•†å“                                 â”‚
â”‚     â””â”€ è®¡ç®—é‡‘é¢                                 â”‚
â”‚                                                 â”‚
â”‚  2. åº“å­˜æ£€æŸ¥ (inventory-service)                â”‚
â”‚     â”œâ”€ æ£€æŸ¥åº“å­˜                                 â”‚
â”‚     â”œâ”€ é”å®šåº“å­˜                                 â”‚
â”‚     â””â”€ æ›´æ–°åº“å­˜                                 â”‚
â”‚                                                 â”‚
â”‚  3. æ”¯ä»˜å¤„ç† (payment-service)                  â”‚
â”‚     â”œâ”€ åˆ›å»ºæ”¯ä»˜è®¢å•                             â”‚
â”‚     â”œâ”€ è°ƒç”¨æ”¯ä»˜ç½‘å…³                             â”‚
â”‚     â””â”€ ç¡®è®¤æ”¯ä»˜                                 â”‚
â”‚                                                 â”‚
â”‚  4. è®¢å•ç¡®è®¤ (order-service)                    â”‚
â”‚     â”œâ”€ æ›´æ–°è®¢å•çŠ¶æ€                             â”‚
â”‚     â”œâ”€ å‘é€é€šçŸ¥                                 â”‚
â”‚     â””â”€ è§¦å‘å‘è´§                                 â”‚
â”‚                                                 â”‚
â”‚  5. å‘è´§å¤„ç† (shipping-service)                 â”‚
â”‚     â”œâ”€ ç”Ÿæˆè¿å•                                 â”‚
â”‚     â”œâ”€ å®‰æ’é…é€                                 â”‚
â”‚     â””â”€ æ›´æ–°ç‰©æµçŠ¶æ€                             â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è®¢å•å¤„ç†è¿½è¸ªå®ç°**ï¼š

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// è®¢å•æœåŠ¡
type OrderService struct {
    tracer trace.Tracer
}

func NewOrderService() *OrderService {
    return &OrderService{
        tracer: otel.Tracer("order-service"),
    }
}

// åˆ›å»ºè®¢å•
func (s *OrderService) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "order.create",
        trace.WithAttributes(
            attribute.String("business.order.user_id", req.UserID),
            attribute.Int("business.order.item_count", len(req.Items)),
            attribute.Float64("business.order.total_amount", req.TotalAmount),
            attribute.String("business.order.currency", "CNY"),
        ),
    )
    defer span.End()

    // 1. éªŒè¯è®¢å•
    if err := s.validateOrder(ctx, req); err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("business.order.status", "validation_failed"),
        )
        return nil, err
    }

    // 2. æ£€æŸ¥åº“å­˜
    inventoryService := NewInventoryService()
    if err := inventoryService.CheckStock(ctx, req.Items); err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("business.order.status", "stock_unavailable"),
        )
        return nil, err
    }

    // 3. åˆ›å»ºè®¢å•
    order := &Order{
        ID:          generateOrderID(),
        UserID:      req.UserID,
        Items:       req.Items,
        TotalAmount: req.TotalAmount,
        Status:      OrderStatusPending,
        CreatedAt:   time.Now(),
    }

    span.SetAttributes(
        attribute.String("business.order.id", order.ID),
        attribute.String("business.order.status", string(order.Status)),
    )

    // 4. å¤„ç†æ”¯ä»˜
    paymentService := NewPaymentService()
    if err := paymentService.ProcessPayment(ctx, order); err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("business.order.status", "payment_failed"),
        )
        return nil, err
    }

    // 5. ç¡®è®¤è®¢å•
    order.Status = OrderStatusConfirmed
    span.SetAttributes(
        attribute.String("business.order.status", string(order.Status)),
    )

    return order, nil
}

// åº“å­˜æœåŠ¡
type InventoryService struct {
    tracer trace.Tracer
}

func NewInventoryService() *InventoryService {
    return &InventoryService{
        tracer: otel.Tracer("inventory-service"),
    }
}

// æ£€æŸ¥åº“å­˜
func (s *InventoryService) CheckStock(ctx context.Context, items []OrderItem) error {
    ctx, span := s.tracer.Start(ctx, "inventory.check_stock")
    defer span.End()

    for _, item := range items {
        itemSpan := s.tracer.Start(ctx, "inventory.check_item",
            trace.WithAttributes(
                attribute.String("business.product.id", item.ProductID),
                attribute.Int("business.product.quantity", item.Quantity),
            ),
        )

        // æ£€æŸ¥åº“å­˜
        stock, err := s.getStock(ctx, item.ProductID)
        if err != nil {
            itemSpan.RecordError(err)
            itemSpan.End()
            return err
        }

        if stock < item.Quantity {
            itemSpan.SetAttributes(
                attribute.String("business.product.stock_status", "insufficient"),
            )
            itemSpan.End()
            return fmt.Errorf("insufficient stock for product %s", item.ProductID)
        }

        itemSpan.SetAttributes(
            attribute.Int("business.product.stock", stock),
            attribute.String("business.product.stock_status", "sufficient"),
        )
        itemSpan.End()
    }

    return nil
}

// æ”¯ä»˜æœåŠ¡
type PaymentService struct {
    tracer trace.Tracer
}

func NewPaymentService() *PaymentService {
    return &PaymentService{
        tracer: otel.Tracer("payment-service"),
    }
}

// å¤„ç†æ”¯ä»˜
func (s *PaymentService) ProcessPayment(ctx context.Context, order *Order) error {
    ctx, span := s.tracer.Start(ctx, "payment.process",
        trace.WithAttributes(
            attribute.String("business.order.id", order.ID),
            attribute.Float64("business.payment.amount", order.TotalAmount),
            attribute.String("business.payment.method", "credit_card"),
        ),
    )
    defer span.End()

    // 1. åˆ›å»ºæ”¯ä»˜è®¢å•
    paymentOrder := &PaymentOrder{
        OrderID: order.ID,
        Amount:  order.TotalAmount,
        Method:  "credit_card",
    }

    // 2. è°ƒç”¨æ”¯ä»˜ç½‘å…³
    gatewaySpan := s.tracer.Start(ctx, "payment.gateway.call")

    transactionID, err := s.callPaymentGateway(ctx, paymentOrder)
    if err != nil {
        gatewaySpan.RecordError(err)
        gatewaySpan.End()

        span.SetAttributes(
            attribute.String("business.payment.status", "failed"),
        )
        return err
    }

    gatewaySpan.SetAttributes(
        attribute.String("business.payment.transaction_id", transactionID),
    )
    gatewaySpan.End()

    // 3. ç¡®è®¤æ”¯ä»˜
    span.SetAttributes(
        attribute.String("business.payment.transaction_id", transactionID),
        attribute.String("business.payment.status", "success"),
    )

    return nil
}
```

### 2. ç”µå•†ä¸šåŠ¡æŒ‡æ ‡

**ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†**ï¼š

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/metric"
)

// ç”µå•†ä¸šåŠ¡æŒ‡æ ‡
type ECommerceMetrics struct {
    orderCounter        metric.Int64Counter
    orderAmount         metric.Float64Histogram
    orderDuration       metric.Float64Histogram
    paymentCounter      metric.Int64Counter
    paymentAmount       metric.Float64Histogram
    inventoryStock      metric.Int64Gauge
}

func NewECommerceMetrics(meter metric.Meter) (*ECommerceMetrics, error) {
    orderCounter, err := meter.Int64Counter(
        "business.order.count",
        metric.WithDescription("Total number of orders"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, err
    }

    orderAmount, err := meter.Float64Histogram(
        "business.order.amount",
        metric.WithDescription("Order amount distribution"),
        metric.WithUnit("CNY"),
    )
    if err != nil {
        return nil, err
    }

    orderDuration, err := meter.Float64Histogram(
        "business.order.duration",
        metric.WithDescription("Order processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }

    paymentCounter, err := meter.Int64Counter(
        "business.payment.count",
        metric.WithDescription("Total number of payments"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, err
    }

    paymentAmount, err := meter.Float64Histogram(
        "business.payment.amount",
        metric.WithDescription("Payment amount distribution"),
        metric.WithUnit("CNY"),
    )
    if err != nil {
        return nil, err
    }

    inventoryStock, err := meter.Int64Gauge(
        "business.inventory.stock",
        metric.WithDescription("Product stock level"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, err
    }

    return &ECommerceMetrics{
        orderCounter:   orderCounter,
        orderAmount:    orderAmount,
        orderDuration:  orderDuration,
        paymentCounter: paymentCounter,
        paymentAmount:  paymentAmount,
        inventoryStock: inventoryStock,
    }, nil
}

// è®°å½•è®¢å•æŒ‡æ ‡
func (m *ECommerceMetrics) RecordOrder(ctx context.Context, order *Order, duration time.Duration) {
    attrs := []attribute.KeyValue{
        attribute.String("business.order.status", string(order.Status)),
        attribute.String("business.order.currency", order.Currency),
    }

    m.orderCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    m.orderAmount.Record(ctx, order.TotalAmount, metric.WithAttributes(attrs...))
    m.orderDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
}

// è®°å½•æ”¯ä»˜æŒ‡æ ‡
func (m *ECommerceMetrics) RecordPayment(ctx context.Context, payment *Payment) {
    attrs := []attribute.KeyValue{
        attribute.String("business.payment.method", payment.Method),
        attribute.String("business.payment.status", string(payment.Status)),
    }

    m.paymentCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    m.paymentAmount.Record(ctx, payment.Amount, metric.WithAttributes(attrs...))
}

// æ›´æ–°åº“å­˜æŒ‡æ ‡
func (m *ECommerceMetrics) UpdateStock(ctx context.Context, productID string, stock int64) {
    attrs := []attribute.KeyValue{
        attribute.String("business.product.id", productID),
    }

    m.inventoryStock.Record(ctx, stock, metric.WithAttributes(attrs...))
}
```

---

## ğŸ’° é‡‘èç³»ç»Ÿé›†æˆ

### 1. äº¤æ˜“å¤„ç†è¿½è¸ª

**äº¤æ˜“å¤„ç†æµç¨‹**ï¼š

```text
äº¤æ˜“å¤„ç†æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  äº¤æ˜“è¯·æ±‚ â†’ é£æ§æ£€æŸ¥ â†’ åˆè§„æ£€æŸ¥ â†’ æ‰§è¡Œäº¤æ˜“ â†’ ç¡®è®¤â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  1. äº¤æ˜“è¯·æ±‚ (transaction-service)              â”‚
â”‚     â”œâ”€ éªŒè¯äº¤æ˜“å‚æ•°                             â”‚
â”‚     â”œâ”€ æ£€æŸ¥è´¦æˆ·çŠ¶æ€                             â”‚
â”‚     â””â”€ è®¡ç®—äº¤æ˜“é‡‘é¢                             â”‚
â”‚                                                 â”‚
â”‚  2. é£æ§æ£€æŸ¥ (risk-service)                     â”‚
â”‚     â”œâ”€ è®¡ç®—é£é™©åˆ†æ•°                             â”‚
â”‚     â”œâ”€ æ£€æŸ¥é£é™©è§„åˆ™                             â”‚
â”‚     â””â”€ ç”Ÿæˆé£æ§æŠ¥å‘Š                             â”‚
â”‚                                                 â”‚
â”‚  3. åˆè§„æ£€æŸ¥ (compliance-service)               â”‚
â”‚     â”œâ”€ åæ´—é’±æ£€æŸ¥                               â”‚
â”‚     â”œâ”€ åˆ¶è£åå•æ£€æŸ¥                             â”‚
â”‚     â””â”€ å¤§é¢äº¤æ˜“æŠ¥å‘Š                             â”‚
â”‚                                                 â”‚
â”‚  4. æ‰§è¡Œäº¤æ˜“ (transaction-service)               â”‚
â”‚     â”œâ”€ æ‰£å‡è½¬å‡ºè´¦æˆ·                             â”‚
â”‚     â”œâ”€ å¢åŠ è½¬å…¥è´¦æˆ·                             â”‚
â”‚     â””â”€ è®°å½•äº¤æ˜“æ—¥å¿—                             â”‚
â”‚                                                 â”‚
â”‚  5. äº¤æ˜“ç¡®è®¤ (transaction-service)               â”‚
â”‚     â”œâ”€ å‘é€é€šçŸ¥                                 â”‚
â”‚     â”œâ”€ æ›´æ–°è´¦æˆ·ä½™é¢                             â”‚
â”‚     â””â”€ ç”Ÿæˆäº¤æ˜“å‡­è¯                             â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**äº¤æ˜“å¤„ç†è¿½è¸ªå®ç°**ï¼š

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// äº¤æ˜“æœåŠ¡
type TransactionService struct {
    tracer trace.Tracer
}

func NewTransactionService() *TransactionService {
    return &TransactionService{
        tracer: otel.Tracer("transaction-service"),
    }
}

// å¤„ç†äº¤æ˜“
func (s *TransactionService) ProcessTransaction(ctx context.Context, req *TransactionRequest) (*Transaction, error) {
    ctx, span := s.tracer.Start(ctx, "transaction.process",
        trace.WithAttributes(
            attribute.String("finance.transaction.type", string(req.Type)),
            attribute.String("finance.account.from", req.FromAccount),
            attribute.String("finance.account.to", req.ToAccount),
            attribute.Float64("finance.transaction.amount", req.Amount),
            attribute.String("finance.transaction.currency", req.Currency),
        ),
    )
    defer span.End()

    // 1. é£æ§æ£€æŸ¥
    riskService := NewRiskService()
    riskScore, err := riskService.CheckRisk(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("finance.transaction.status", "risk_check_failed"),
        )
        return nil, err
    }

    span.SetAttributes(
        attribute.Int("finance.risk.score", riskScore),
    )

    if riskScore > 80 {
        span.SetAttributes(
            attribute.String("finance.risk.level", "high"),
            attribute.String("finance.transaction.status", "blocked"),
        )
        return nil, fmt.Errorf("high risk transaction")
    }

    // 2. åˆè§„æ£€æŸ¥
    complianceService := NewComplianceService()
    complianceStatus, err := complianceService.CheckCompliance(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("finance.transaction.status", "compliance_check_failed"),
        )
        return nil, err
    }

    span.SetAttributes(
        attribute.String("finance.compliance.status", complianceStatus),
    )

    // 3. æ‰§è¡Œäº¤æ˜“
    transaction := &Transaction{
        ID:          generateTransactionID(),
        Type:        req.Type,
        FromAccount: req.FromAccount,
        ToAccount:   req.ToAccount,
        Amount:      req.Amount,
        Currency:    req.Currency,
        Status:      TransactionStatusPending,
        CreatedAt:   time.Now(),
    }

    span.SetAttributes(
        attribute.String("finance.transaction.id", transaction.ID),
    )

    // 4. æ›´æ–°è´¦æˆ·
    accountService := NewAccountService()
    if err := accountService.UpdateAccounts(ctx, transaction); err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("finance.transaction.status", "execution_failed"),
        )
        return nil, err
    }

    // 5. ç¡®è®¤äº¤æ˜“
    transaction.Status = TransactionStatusCompleted
    span.SetAttributes(
        attribute.String("finance.transaction.status", string(transaction.Status)),
    )

    return transaction, nil
}

// é£æ§æœåŠ¡
type RiskService struct {
    tracer trace.Tracer
}

func NewRiskService() *RiskService {
    return &RiskService{
        tracer: otel.Tracer("risk-service"),
    }
}

// æ£€æŸ¥é£é™©
func (s *RiskService) CheckRisk(ctx context.Context, req *TransactionRequest) (int, error) {
    ctx, span := s.tracer.Start(ctx, "risk.check",
        trace.WithAttributes(
            attribute.String("finance.transaction.type", string(req.Type)),
            attribute.Float64("finance.transaction.amount", req.Amount),
        ),
    )
    defer span.End()

    // è®¡ç®—é£é™©åˆ†æ•°
    riskScore := s.calculateRiskScore(ctx, req)

    span.SetAttributes(
        attribute.Int("finance.risk.score", riskScore),
    )

    if riskScore > 80 {
        span.SetAttributes(
            attribute.String("finance.risk.level", "high"),
        )
    } else if riskScore > 50 {
        span.SetAttributes(
            attribute.String("finance.risk.level", "medium"),
        )
    } else {
        span.SetAttributes(
            attribute.String("finance.risk.level", "low"),
        )
    }

    return riskScore, nil
}

// åˆè§„æœåŠ¡
type ComplianceService struct {
    tracer trace.Tracer
}

func NewComplianceService() *ComplianceService {
    return &ComplianceService{
        tracer: otel.Tracer("compliance-service"),
    }
}

// æ£€æŸ¥åˆè§„
func (s *ComplianceService) CheckCompliance(ctx context.Context, req *TransactionRequest) (string, error) {
    ctx, span := s.tracer.Start(ctx, "compliance.check",
        trace.WithAttributes(
            attribute.String("finance.transaction.type", string(req.Type)),
            attribute.Float64("finance.transaction.amount", req.Amount),
        ),
    )
    defer span.End()

    // 1. åæ´—é’±æ£€æŸ¥
    amlSpan := s.tracer.Start(ctx, "compliance.aml_check")
    if err := s.checkAML(ctx, req); err != nil {
        amlSpan.RecordError(err)
        amlSpan.End()

        span.SetAttributes(
            attribute.String("finance.compliance.status", "aml_failed"),
        )
        return "failed", err
    }
    amlSpan.End()

    // 2. åˆ¶è£åå•æ£€æŸ¥
    sanctionsSpan := s.tracer.Start(ctx, "compliance.sanctions_check")
    if err := s.checkSanctions(ctx, req); err != nil {
        sanctionsSpan.RecordError(err)
        sanctionsSpan.End()

        span.SetAttributes(
            attribute.String("finance.compliance.status", "sanctions_failed"),
        )
        return "failed", err
    }
    sanctionsSpan.End()

    // 3. å¤§é¢äº¤æ˜“æŠ¥å‘Š
    if req.Amount > 50000 {
        reportSpan := s.tracer.Start(ctx, "compliance.large_transaction_report")
        s.reportLargeTransaction(ctx, req)
        reportSpan.End()
    }

    span.SetAttributes(
        attribute.String("finance.compliance.status", "passed"),
    )

    return "passed", nil
}
```

---

## ğŸ“¦ ç‰©æµç³»ç»Ÿé›†æˆ

### 1. è®¢å•é…é€è¿½è¸ª

**è®¢å•é…é€æµç¨‹**ï¼š

```text
è®¢å•é…é€æµç¨‹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è®¢å•æ¥æ”¶ â†’ ä»“åº“æ‹£è´§ â†’ æ‰“åŒ… â†’ å‘è´§ â†’ é…é€ â†’ ç­¾æ”¶â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  1. è®¢å•æ¥æ”¶ (order-service)                    â”‚
â”‚     â”œâ”€ æ¥æ”¶è®¢å•                                 â”‚
â”‚     â”œâ”€ åˆ†é…ä»“åº“                                 â”‚
â”‚     â””â”€ ç”Ÿæˆæ‹£è´§å•                               â”‚
â”‚                                                 â”‚
â”‚  2. ä»“åº“æ‹£è´§ (warehouse-service)                â”‚
â”‚     â”œâ”€ æ‹£è´§ä»»åŠ¡åˆ†é…                             â”‚
â”‚     â”œâ”€ å•†å“æ‹£è´§                                 â”‚
â”‚     â””â”€ æ‹£è´§å®Œæˆç¡®è®¤                             â”‚
â”‚                                                 â”‚
â”‚  3. æ‰“åŒ… (packaging-service)                    â”‚
â”‚     â”œâ”€ å•†å“æ‰“åŒ…                                 â”‚
â”‚     â”œâ”€ ç”Ÿæˆè¿å•                                 â”‚
â”‚     â””â”€ æ‰“å°æ ‡ç­¾                                 â”‚
â”‚                                                 â”‚
â”‚  4. å‘è´§ (shipping-service)                     â”‚
â”‚     â”œâ”€ å®‰æ’ç‰©æµ                                 â”‚
â”‚     â”œâ”€ ç”Ÿæˆè¿å•                                 â”‚
â”‚     â””â”€ æ›´æ–°ç‰©æµçŠ¶æ€                             â”‚
â”‚                                                 â”‚
â”‚  5. é…é€ (delivery-service)                     â”‚
â”‚     â”œâ”€ é…é€å‘˜åˆ†é…                               â”‚
â”‚     â”œâ”€ é…é€è·¯çº¿è§„åˆ’                             â”‚
â”‚     â””â”€ å®æ—¶ä½ç½®è¿½è¸ª                             â”‚
â”‚                                                 â”‚
â”‚  6. ç­¾æ”¶ (delivery-service)                     â”‚
â”‚     â”œâ”€ ç¡®è®¤æ”¶è´§                                 â”‚
â”‚     â”œâ”€ æ›´æ–°è®¢å•çŠ¶æ€                             â”‚
â”‚     â””â”€ å‘é€é€šçŸ¥                                 â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è®¢å•é…é€è¿½è¸ªå®ç°**ï¼š

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// é…é€æœåŠ¡
type DeliveryService struct {
    tracer trace.Tracer
}

func NewDeliveryService() *DeliveryService {
    return &DeliveryService{
        tracer: otel.Tracer("delivery-service"),
    }
}

// å¤„ç†è®¢å•é…é€
func (s *DeliveryService) ProcessDelivery(ctx context.Context, order *Order) error {
    ctx, span := s.tracer.Start(ctx, "delivery.process",
        trace.WithAttributes(
            attribute.String("business.order.id", order.ID),
            attribute.String("business.order.status", string(order.Status)),
            attribute.String("logistics.delivery.type", "standard"),
        ),
    )
    defer span.End()

    // 1. åˆ†é…ä»“åº“
    warehouseService := NewWarehouseService()
    warehouse, err := warehouseService.AssignWarehouse(ctx, order)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("logistics.delivery.status", "warehouse_assignment_failed"),
        )
        return err
    }

    span.SetAttributes(
        attribute.String("logistics.warehouse.id", warehouse.ID),
        attribute.String("logistics.warehouse.location", warehouse.Location),
    )

    // 2. æ‹£è´§
    pickingTask, err := warehouseService.CreatePickingTask(ctx, order, warehouse)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("logistics.delivery.status", "picking_failed"),
        )
        return err
    }

    span.SetAttributes(
        attribute.String("logistics.picking.task_id", pickingTask.ID),
    )

    // 3. æ‰“åŒ…
    packagingService := NewPackagingService()
    packageInfo, err := packagingService.PackageOrder(ctx, order, pickingTask)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("logistics.delivery.status", "packaging_failed"),
        )
        return err
    }

    span.SetAttributes(
        attribute.String("logistics.package.id", packageInfo.ID),
        attribute.Float64("logistics.package.weight", packageInfo.Weight),
        attribute.Float64("logistics.package.volume", packageInfo.Volume),
    )

    // 4. å‘è´§
    shippingService := NewShippingService()
    waybill, err := shippingService.CreateWaybill(ctx, order, packageInfo)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("logistics.delivery.status", "shipping_failed"),
        )
        return err
    }

    span.SetAttributes(
        attribute.String("logistics.waybill.id", waybill.ID),
        attribute.String("logistics.carrier.name", waybill.CarrierName),
    )

    // 5. é…é€
    deliveryTask, err := shippingService.AssignDelivery(ctx, waybill)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String("logistics.delivery.status", "delivery_assignment_failed"),
        )
        return err
    }

    span.SetAttributes(
        attribute.String("logistics.delivery.task_id", deliveryTask.ID),
        attribute.String("logistics.delivery.driver_id", deliveryTask.DriverID),
    )

    // 6. è¿½è¸ªé…é€
    go s.trackDelivery(ctx, deliveryTask)

    span.SetAttributes(
        attribute.String("logistics.delivery.status", "in_transit"),
    )

    return nil
}

// è¿½è¸ªé…é€
func (s *DeliveryService) trackDelivery(ctx context.Context, task *DeliveryTask) {
    tracer := otel.Tracer("delivery-tracker")

    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return

        case <-ticker.C:
            ctx, span := tracer.Start(ctx, "delivery.track",
                trace.WithAttributes(
                    attribute.String("logistics.delivery.task_id", task.ID),
                ),
            )

            // è·å–å½“å‰ä½ç½®
            location, err := s.getCurrentLocation(ctx, task)
            if err != nil {
                span.RecordError(err)
                span.End()
                continue
            }

            span.SetAttributes(
                attribute.Float64("logistics.location.latitude", location.Latitude),
                attribute.Float64("logistics.location.longitude", location.Longitude),
            )

            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾
            if s.isArrived(ctx, task, location) {
                span.SetAttributes(
                    attribute.String("logistics.delivery.status", "arrived"),
                )
                span.End()
                return
            }

            span.End()
        }
    }
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä¸šåŠ¡é›†æˆæœ€ä½³å®è·µ

```text
ä¸šåŠ¡é›†æˆæœ€ä½³å®è·µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… æ¨èåšæ³•                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  1. å®šä¹‰æ¸…æ™°çš„ä¸šåŠ¡è¯­ä¹‰çº¦å®š                                    â”‚
â”‚     business.order.*                           â”‚
â”‚     finance.transaction.*                      â”‚
â”‚                                                 â”‚
â”‚  2. è¿½è¸ªå…³é”®ä¸šåŠ¡äº‹ä»¶                           â”‚
â”‚     è®¢å•åˆ›å»ºã€æ”¯ä»˜ã€å‘è´§ç­‰                      â”‚
â”‚                                                 â”‚
â”‚  3. æ”¶é›†ä¸šåŠ¡æŒ‡æ ‡                               â”‚
â”‚     è®¢å•é‡ã€äº¤æ˜“é¢ã€åº“å­˜ç­‰                      â”‚
â”‚                                                 â”‚
â”‚  4. å…³è”ä¸šåŠ¡æ—¥å¿—                               â”‚
â”‚     ä½¿ç”¨TraceIDå…³è”æ—¥å¿—                        â”‚
â”‚                                                 â”‚
â”‚  5. é¿å…æ•æ„Ÿä¿¡æ¯                                â”‚
â”‚     âŒ business.user.password                   â”‚
â”‚     âœ… business.user.id                         â”‚
â”‚                                                 â”‚
â”‚  6. ä¼˜åŒ–è¿½è¸ªå¼€é”€                               â”‚
â”‚     é‡‡æ ·ç‡ 1-10%                               â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®

```text
æ€§èƒ½ä¼˜åŒ–å»ºè®®:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–é¡¹         â”‚ å»ºè®®å€¼          â”‚ è¯´æ˜           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è¿½è¸ªæ·±åº¦       â”‚ â‰¤ 10å±‚         â”‚ é¿å…è¿‡æ·±       â”‚
â”‚  å±æ€§æ•°é‡       â”‚ â‰¤ 20ä¸ª/Span    â”‚ é¿å…è¿‡å¤š       â”‚
â”‚  é‡‡æ ·ç‡         â”‚ 1-10%          â”‚ ç”Ÿäº§ç¯å¢ƒ       â”‚
â”‚  æ‰¹é‡å¤§å°       â”‚ 100-1000æ¡     â”‚ æ‰¹é‡ä¼ è¾“       â”‚
â”‚  è¿½è¸ªå¼€é”€       â”‚ < 5%           â”‚ CPUå¼€é”€        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š å‚è€ƒèµ„æº

- [OpenTelemetryä¸šåŠ¡è¿½è¸ª](https://opentelemetry.io/docs/instrumentation/go/getting-started/)
- [ä¸šåŠ¡è¯­ä¹‰çº¦å®š](https://opentelemetry.io/docs/specs/semconv/general/attributes/)
- [OTLPä¸šåŠ¡é›†æˆ](https://opentelemetry.io/docs/specs/otel/overview/)

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ
**ç‰ˆæœ¬**: 1.0.0
