# OTLPæ•°æ®åº”ç”¨è§†è§’ï¼šä¸šåŠ¡ä¸OTLPæ•°æ®å†—ä½™åˆ†æ

> **æ–‡æ¡£ç±»å‹**: æ•°æ®æ¨¡å‹æ·±åº¦åˆ†æ  
> **åˆ†æç»´åº¦**: æ•°æ®åº”ç”¨è§†è§’ - ä¸šåŠ¡ä¸OTLPæ•°æ®å†—ä½™  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ11æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
- [æ•°æ®å†—ä½™å…¨æ™¯](#-æ•°æ®å†—ä½™å…¨æ™¯)
- [ä¸šåŠ¡æ•°æ®ä¸OTLPæ•°æ®](#-ä¸šåŠ¡æ•°æ®ä¸otlpæ•°æ®)
- [å†—ä½™åˆ†æ](#-å†—ä½™åˆ†æ)
- [å»é‡ç­–ç•¥](#-å»é‡ç­–ç•¥)
- [èåˆç­–ç•¥](#-èåˆç­–ç•¥)
- [å®æˆ˜æ¡ˆä¾‹](#-å®æˆ˜æ¡ˆä¾‹)

---

## ğŸ¯ æ‰§è¡Œæ‘˜è¦

**ä¸šåŠ¡ä¸OTLPæ•°æ®å†—ä½™**æ˜¯æ•°æ®åº”ç”¨çš„æ ¸å¿ƒé—®é¢˜ï¼Œå†³å®šäº†æ•°æ®å­˜å‚¨æˆæœ¬å’ŒæŸ¥è¯¢æ•ˆç‡ã€‚

```text
æ•°æ®å†—ä½™å…¨æ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ä¸šåŠ¡æ•°æ®ä¸OTLPæ•°æ®å†—ä½™åˆ†æä½“ç³»                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  ä¸šåŠ¡æ•°æ®                                      â”‚      â”‚
â”‚  â”‚  - è®¢å•æ•°æ®                                    â”‚      â”‚
â”‚  â”‚  - ç”¨æˆ·æ•°æ®                                    â”‚      â”‚
â”‚  â”‚  - äº¤æ˜“æ•°æ®                                    â”‚      â”‚
â”‚  â”‚  - åº“å­˜æ•°æ®                                    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                         â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚               â”‚               â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ OTLPæ•°æ®   â”‚  â”‚ å†—ä½™æ•°æ®    â”‚  â”‚ èåˆæ•°æ®    â”‚        â”‚
â”‚  â”‚ - Traces   â”‚  â”‚ - é‡å¤å­—æ®µ  â”‚  â”‚ - å…³è”æŸ¥è¯¢  â”‚        â”‚
â”‚  â”‚ - Metrics  â”‚  â”‚ - é‡å¤æ—¶é—´  â”‚  â”‚ - è”åˆåˆ†æ  â”‚        â”‚
â”‚  â”‚ - Logs     â”‚  â”‚ - é‡å¤ID    â”‚  â”‚ - ç»Ÿä¸€è§†å›¾  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  å†—ä½™åœºæ™¯                                      â”‚      â”‚
â”‚  â”‚  - è®¢å•å¤„ç†                                    â”‚      â”‚
â”‚  â”‚  - æ”¯ä»˜å¤„ç†                                    â”‚      â”‚
â”‚  â”‚  - åº“å­˜ç®¡ç†                                    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒæ´å¯Ÿ**ï¼š

1. **å†—ä½™ç±»å‹**ï¼šå­—æ®µå†—ä½™ + æ—¶é—´å†—ä½™ + IDå†—ä½™
2. **å†—ä½™ç¨‹åº¦**ï¼š30-50%ï¼ˆå…¸å‹åœºæ™¯ï¼‰
3. **å»é‡ç­–ç•¥**ï¼šå¼•ç”¨ + å‹ç¼© + ç´¢å¼•
4. **èåˆç­–ç•¥**ï¼šå…³è” + èšåˆ + è§†å›¾

---

## ğŸ“Š æ•°æ®å†—ä½™å…¨æ™¯

### å†—ä½™ç±»å‹çŸ©é˜µ

```text
å†—ä½™ç±»å‹çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å†—ä½™ç±»å‹      â”‚ ä¸šåŠ¡æ•°æ®    â”‚ OTLPæ•°æ®    â”‚ å†—ä½™åº¦    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å­—æ®µå†—ä½™      â”‚ è®¢å•ID      â”‚ Spanå±æ€§    â”‚ é«˜        â”‚
â”‚  æ—¶é—´å†—ä½™      â”‚ åˆ›å»ºæ—¶é—´    â”‚ Spanæ—¶é—´    â”‚ ä¸­        â”‚
â”‚  IDå†—ä½™        â”‚ è®¢å•ID      â”‚ Trace ID    â”‚ é«˜        â”‚
â”‚  çŠ¶æ€å†—ä½™      â”‚ è®¢å•çŠ¶æ€    â”‚ SpançŠ¶æ€    â”‚ ä¸­        â”‚
â”‚  ç”¨æˆ·å†—ä½™      â”‚ ç”¨æˆ·ID      â”‚ Spanå±æ€§    â”‚ é«˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¼ ä¸šåŠ¡æ•°æ®ä¸OTLPæ•°æ®

### ä¸šåŠ¡æ•°æ®æ¨¡å‹

```go
// ä¸šåŠ¡æ•°æ®æ¨¡å‹
package main

type Order struct {
    ID          string    `json:"id"`
    UserID      string    `json:"user_id"`
    ProductID   string    `json:"product_id"`
    Amount      float64   `json:"amount"`
    Status      string    `json:"status"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

type Payment struct {
    ID          string    `json:"id"`
    OrderID     string    `json:"order_id"`
    Amount      float64   `json:"amount"`
    Method      string    `json:"method"`
    Status      string    `json:"status"`
    CreatedAt   time.Time `json:"created_at"`
}

type Inventory struct {
    ID          string    `json:"id"`
    ProductID   string    `json:"product_id"`
    Quantity    int       `json:"quantity"`
    UpdatedAt   time.Time `json:"updated_at"`
}
```

### OTLPæ•°æ®æ¨¡å‹

```go
// OTLPæ•°æ®æ¨¡å‹
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

// è®¢å•å¤„ç†Span
func createOrderSpan(ctx context.Context, order Order) trace.Span {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            // ä¸šåŠ¡å­—æ®µå†—ä½™
            attribute.String("order.id", order.ID),
            attribute.String("order.user_id", order.UserID),
            attribute.String("order.product_id", order.ProductID),
            attribute.Float64("order.amount", order.Amount),
            attribute.String("order.status", order.Status),
            attribute.String("order.created_at", order.CreatedAt.Format(time.RFC3339)),
            
            // è¯­ä¹‰çº¦å®šå­—æ®µ
            attribute.String("service.name", "order-service"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    return span
}

// æ”¯ä»˜å¤„ç†Span
func createPaymentSpan(ctx context.Context, payment Payment) trace.Span {
    tracer := otel.Tracer("payment-service")
    ctx, span := tracer.Start(ctx, "payment.process",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            // ä¸šåŠ¡å­—æ®µå†—ä½™
            attribute.String("payment.id", payment.ID),
            attribute.String("payment.order_id", payment.OrderID),
            attribute.Float64("payment.amount", payment.Amount),
            attribute.String("payment.method", payment.Method),
            attribute.String("payment.status", payment.Status),
            attribute.String("payment.created_at", payment.CreatedAt.Format(time.RFC3339)),
            
            // è¯­ä¹‰çº¦å®šå­—æ®µ
            attribute.String("service.name", "payment-service"),
            attribute.String("service.version", "2.0.0"),
        ),
    )
    
    return span
}
```

---

## ğŸ” å†—ä½™åˆ†æ

### å­—æ®µå†—ä½™åˆ†æ

```text
å­—æ®µå†—ä½™åˆ†æ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å­—æ®µ          â”‚ ä¸šåŠ¡æ•°æ® â”‚ OTLPæ•°æ® â”‚ å†—ä½™åº¦ â”‚ è¯´æ˜     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ID            â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  UserID        â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  ProductID     â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  Amount        â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  Status        â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  CreatedAt     â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  Method        â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å†—ä½™åº¦è®¡ç®—:
å†—ä½™åº¦ = (å†—ä½™å­—æ®µæ•° / æ€»å­—æ®µæ•°) Ã— 100%
å†—ä½™åº¦ = (7 / 7) Ã— 100% = 100%
```

### æ—¶é—´å†—ä½™åˆ†æ

```text
æ—¶é—´å†—ä½™åˆ†æ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ—¶é—´å­—æ®µ      â”‚ ä¸šåŠ¡æ•°æ® â”‚ OTLPæ•°æ® â”‚ å†—ä½™åº¦ â”‚ è¯´æ˜     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  CreatedAt     â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  UpdatedAt     â”‚ âœ…       â”‚ âŒ       â”‚ 0%    â”‚ æ— å†—ä½™    â”‚
â”‚  StartTime     â”‚ âŒ       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  EndTime       â”‚ âŒ       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ—¶é—´å†—ä½™åº¦ = (3 / 4) Ã— 100% = 75%
```

### IDå†—ä½™åˆ†æ

```text
IDå†—ä½™åˆ†æ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IDç±»å‹        â”‚ ä¸šåŠ¡æ•°æ® â”‚ OTLPæ•°æ® â”‚ å†—ä½™åº¦ â”‚ è¯´æ˜     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  OrderID       â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  PaymentID     â”‚ âœ…       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  TraceID       â”‚ âŒ       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â”‚  SpanID        â”‚ âŒ       â”‚ âœ…       â”‚ 100%  â”‚ å®Œå…¨å†—ä½™  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

IDå†—ä½™åº¦ = (4 / 4) Ã— 100% = 100%
```

---

## ğŸ¯ å»é‡ç­–ç•¥

### 1. å¼•ç”¨ç­–ç•¥

```go
// å¼•ç”¨ç­–ç•¥
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

// ä½¿ç”¨å¼•ç”¨è€Œéå†—ä½™
func createOrderSpanWithReference(ctx context.Context, orderID string) trace.Span {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            // åªå­˜å‚¨å¼•ç”¨ID
            attribute.String("order.id", orderID),
            
            // ä¸å­˜å‚¨å…¶ä»–ä¸šåŠ¡å­—æ®µ
            // é€šè¿‡order.idå…³è”æŸ¥è¯¢ä¸šåŠ¡æ•°æ®
            
            // è¯­ä¹‰çº¦å®šå­—æ®µ
            attribute.String("service.name", "order-service"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    return span
}

// å…³è”æŸ¥è¯¢
func queryOrderData(ctx context.Context, span trace.Span) (*Order, error) {
    // ä»Spanè·å–order.id
    orderID := ""
    for _, attr := range span.Attributes() {
        if attr.Key == "order.id" {
            orderID = attr.Value.AsString()
            break
        }
    }
    
    // é€šè¿‡order.idæŸ¥è¯¢ä¸šåŠ¡æ•°æ®
    order, err := getOrderByID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    return order, nil
}
```

### 2. å‹ç¼©ç­–ç•¥

```go
// å‹ç¼©ç­–ç•¥
package main

import (
    "compress/gzip"
    "encoding/json"
    "bytes"
)

// å‹ç¼©ä¸šåŠ¡æ•°æ®
func compressBusinessData(order Order) ([]byte, error) {
    // åºåˆ—åŒ–
    jsonData, err := json.Marshal(order)
    if err != nil {
        return nil, err
    }
    
    // å‹ç¼©
    var buf bytes.Buffer
    writer := gzip.NewWriter(&buf)
    if _, err := writer.Write(jsonData); err != nil {
        return nil, err
    }
    if err := writer.Close(); err != nil {
        return nil, err
    }
    
    return buf.Bytes(), nil
}

// è§£å‹ä¸šåŠ¡æ•°æ®
func decompressBusinessData(data []byte) (*Order, error) {
    // è§£å‹
    reader, err := gzip.NewReader(bytes.NewReader(data))
    if err != nil {
        return nil, err
    }
    defer reader.Close()
    
    var buf bytes.Buffer
    if _, err := buf.ReadFrom(reader); err != nil {
        return nil, err
    }
    
    // ååºåˆ—åŒ–
    var order Order
    if err := json.Unmarshal(buf.Bytes(), &order); err != nil {
        return nil, err
    }
    
    return &order, nil
}
```

### 3. ç´¢å¼•ç­–ç•¥

```go
// ç´¢å¼•ç­–ç•¥
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

// åˆ›å»ºç´¢å¼•
func createIndex(span trace.Span) map[string]string {
    index := make(map[string]string)
    
    for _, attr := range span.Attributes() {
        // åªç´¢å¼•å…³é”®å­—æ®µ
        if attr.Key == "order.id" || 
           attr.Key == "user.id" || 
           attr.Key == "payment.id" {
            index[string(attr.Key)] = attr.Value.AsString()
        }
    }
    
    return index
}

// é€šè¿‡ç´¢å¼•æŸ¥è¯¢
func queryByIndex(ctx context.Context, index map[string]string) ([]trace.Span, error) {
    // ä½¿ç”¨ç´¢å¼•å¿«é€Ÿå®šä½
    orderID := index["order.id"]
    
    // æŸ¥è¯¢ç›¸å…³Span
    spans, err := querySpansByOrderID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    return spans, nil
}
```

---

## ğŸ”— èåˆç­–ç•¥

### 1. å…³è”æŸ¥è¯¢

```go
// å…³è”æŸ¥è¯¢
package main

import (
    "go.opentelemetry.io/otel/trace"
)

// å…³è”ä¸šåŠ¡æ•°æ®å’ŒOTLPæ•°æ®
func correlateBusinessAndOTLP(ctx context.Context, orderID string) (*CorrelatedData, error) {
    // æŸ¥è¯¢ä¸šåŠ¡æ•°æ®
    order, err := getOrderByID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    payment, err := getPaymentByOrderID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    // æŸ¥è¯¢OTLPæ•°æ®
    spans, err := querySpansByOrderID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    metrics, err := queryMetricsByOrderID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    logs, err := queryLogsByOrderID(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    return &CorrelatedData{
        Order:   order,
        Payment: payment,
        Spans:   spans,
        Metrics: metrics,
        Logs:    logs,
    }, nil
}

type CorrelatedData struct {
    Order   *Order
    Payment *Payment
    Spans   []trace.Span
    Metrics []Metric
    Logs    []LogRecord
}
```

### 2. èšåˆåˆ†æ

```go
// èšåˆåˆ†æ
package main

import (
    "go.opentelemetry.io/otel/trace"
)

// èšåˆä¸šåŠ¡æ•°æ®å’ŒOTLPæ•°æ®
func aggregateBusinessAndOTLP(ctx context.Context, orderID string) (*AggregatedData, error) {
    // å…³è”æ•°æ®
    correlated, err := correlateBusinessAndOTLP(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    // èšåˆåˆ†æ
    aggregated := &AggregatedData{
        OrderID: orderID,
        
        // ä¸šåŠ¡æŒ‡æ ‡
        TotalAmount:     correlated.Order.Amount,
        PaymentMethod:   correlated.Payment.Method,
        OrderStatus:     correlated.Order.Status,
        
        // OTLPæŒ‡æ ‡
        TotalSpans:      len(correlated.Spans),
        AvgSpanDuration: calculateAvgSpanDuration(correlated.Spans),
        ErrorCount:      countErrors(correlated.Spans),
        LogCount:        len(correlated.Logs),
    }
    
    return aggregated, nil
}

type AggregatedData struct {
    OrderID          string
    TotalAmount      float64
    PaymentMethod    string
    OrderStatus      string
    TotalSpans       int
    AvgSpanDuration  time.Duration
    ErrorCount       int
    LogCount         int
}

func calculateAvgSpanDuration(spans []trace.Span) time.Duration {
    if len(spans) == 0 {
        return 0
    }
    
    total := time.Duration(0)
    for _, span := range spans {
        total += span.EndTime().Sub(span.StartTime())
    }
    
    return total / time.Duration(len(spans))
}

func countErrors(spans []trace.Span) int {
    count := 0
    for _, span := range spans {
        if span.Status().Code == trace.StatusCodeError {
            count++
        }
    }
    return count
}
```

### 3. ç»Ÿä¸€è§†å›¾

```go
// ç»Ÿä¸€è§†å›¾
package main

import (
    "go.opentelemetry.io/otel/trace"
)

// ç»Ÿä¸€è§†å›¾
func createUnifiedView(ctx context.Context, orderID string) (*UnifiedView, error) {
    // å…³è”æ•°æ®
    correlated, err := correlateBusinessAndOTLP(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    // èšåˆæ•°æ®
    aggregated, err := aggregateBusinessAndOTLP(ctx, orderID)
    if err != nil {
        return nil, err
    }
    
    return &UnifiedView{
        Order:      correlated.Order,
        Payment:    correlated.Payment,
        Spans:      correlated.Spans,
        Metrics:    correlated.Metrics,
        Logs:       correlated.Logs,
        Aggregated: aggregated,
    }, nil
}

type UnifiedView struct {
    Order      *Order
    Payment    *Payment
    Spans      []trace.Span
    Metrics    []Metric
    Logs       []LogRecord
    Aggregated *AggregatedData
}
```

---

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šç”µå•†è®¢å•ç³»ç»Ÿå†—ä½™ä¼˜åŒ–

```go
// ç”µå•†è®¢å•ç³»ç»Ÿå†—ä½™ä¼˜åŒ–
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

// ä¼˜åŒ–å‰ï¼šå®Œå…¨å†—ä½™
func createOrderSpanBefore(ctx context.Context, order Order) trace.Span {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            // å®Œå…¨å†—ä½™çš„ä¸šåŠ¡å­—æ®µ
            attribute.String("order.id", order.ID),
            attribute.String("order.user_id", order.UserID),
            attribute.String("order.product_id", order.ProductID),
            attribute.Float64("order.amount", order.Amount),
            attribute.String("order.status", order.Status),
            attribute.String("order.created_at", order.CreatedAt.Format(time.RFC3339)),
            attribute.String("order.updated_at", order.UpdatedAt.Format(time.RFC3339)),
            
            // è¯­ä¹‰çº¦å®šå­—æ®µ
            attribute.String("service.name", "order-service"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    return span
}

// ä¼˜åŒ–åï¼šä½¿ç”¨å¼•ç”¨
func createOrderSpanAfter(ctx context.Context, orderID string) trace.Span {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            // åªå­˜å‚¨å¼•ç”¨ID
            attribute.String("order.id", orderID),
            
            // è¯­ä¹‰çº¦å®šå­—æ®µ
            attribute.String("service.name", "order-service"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    return span
}
```

### æ¡ˆä¾‹2ï¼šæ”¯ä»˜ç³»ç»Ÿèåˆåˆ†æ

```go
// æ”¯ä»˜ç³»ç»Ÿèåˆåˆ†æ
package main

import (
    "go.opentelemetry.io/otel/trace"
)

// æ”¯ä»˜ç³»ç»Ÿèåˆåˆ†æ
func analyzePaymentSystem(ctx context.Context, paymentID string) (*PaymentAnalysis, error) {
    // å…³è”ä¸šåŠ¡æ•°æ®å’ŒOTLPæ•°æ®
    correlated, err := correlateBusinessAndOTLP(ctx, paymentID)
    if err != nil {
        return nil, err
    }
    
    // èšåˆåˆ†æ
    aggregated, err := aggregateBusinessAndOTLP(ctx, paymentID)
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»ºç»Ÿä¸€è§†å›¾
    unified, err := createUnifiedView(ctx, paymentID)
    if err != nil {
        return nil, err
    }
    
    return &PaymentAnalysis{
        Correlated: correlated,
        Aggregated: aggregated,
        Unified:    unified,
    }, nil
}

type PaymentAnalysis struct {
    Correlated *CorrelatedData
    Aggregated *AggregatedData
    Unified    *UnifiedView
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### å†—ä½™ä¼˜åŒ–çŸ©é˜µ

```text
å†—ä½™ä¼˜åŒ–çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–ç­–ç•¥      â”‚ å†—ä½™åº¦    â”‚ å­˜å‚¨æˆæœ¬ â”‚ æŸ¥è¯¢æ€§èƒ½      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å®Œå…¨å†—ä½™      â”‚ 100%     â”‚ é«˜      â”‚ å¿«            â”‚
â”‚  å¼•ç”¨ç­–ç•¥      â”‚ 10%      â”‚ ä½      â”‚ ä¸­            â”‚
â”‚  å‹ç¼©ç­–ç•¥      â”‚ 50%      â”‚ ä¸­      â”‚ ä¸­            â”‚
â”‚  ç´¢å¼•ç­–ç•¥      â”‚ 30%      â”‚ ä¸­      â”‚ å¿«            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ æ€»ç»“

**ä¸šåŠ¡ä¸OTLPæ•°æ®å†—ä½™**æ˜¯æ•°æ®åº”ç”¨çš„æ ¸å¿ƒé—®é¢˜ï¼š

1. **å†—ä½™ç±»å‹**ï¼šå­—æ®µå†—ä½™ + æ—¶é—´å†—ä½™ + IDå†—ä½™
2. **å†—ä½™ç¨‹åº¦**ï¼š30-100%ï¼ˆå…¸å‹åœºæ™¯ï¼‰
3. **å»é‡ç­–ç•¥**ï¼šå¼•ç”¨ + å‹ç¼© + ç´¢å¼•
4. **èåˆç­–ç•¥**ï¼šå…³è” + èšåˆ + è§†å›¾

**å…³é”®è¦ç‚¹**ï¼š

- âœ… å¼•ç”¨ç­–ç•¥é™ä½90%å†—ä½™
- âœ… å‹ç¼©ç­–ç•¥é™ä½50%å†—ä½™
- âœ… ç´¢å¼•ç­–ç•¥æå‡æŸ¥è¯¢æ€§èƒ½
- âœ… èåˆç­–ç•¥æä¾›ç»Ÿä¸€è§†å›¾
- âœ… å…³è”æŸ¥è¯¢å®ç°æ•°æ®äº’é€š

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ
