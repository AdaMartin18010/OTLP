# å¾®æœåŠ¡è¿½è¸ªå®æˆ˜

> **OpenTelemetryç‰ˆæœ¬**: v1.20+
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [å¾®æœåŠ¡è¿½è¸ªå®æˆ˜](#å¾®æœåŠ¡è¿½è¸ªå®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. åœºæ™¯æ¦‚è¿°](#1-åœºæ™¯æ¦‚è¿°)
    - [1.1 ç³»ç»Ÿæ¶æ„](#11-ç³»ç»Ÿæ¶æ„)
    - [1.2 æŠ€æœ¯æ ˆ](#12-æŠ€æœ¯æ ˆ)
  - [2. æœåŠ¡å®ç°](#2-æœåŠ¡å®ç°)
    - [2.1 API Gateway (Go)](#21-api-gateway-go)
    - [2.2 Order Service (Go)](#22-order-service-go)
    - [2.3 Inventory Service (Python)](#23-inventory-service-python)
    - [2.4 Payment Service (Java)](#24-payment-service-java)
  - [3. æ•°æ®åº“è¿½è¸ª](#3-æ•°æ®åº“è¿½è¸ª)
    - [3.1 PostgreSQLè¿½è¸ª](#31-postgresqlè¿½è¸ª)
    - [3.2 Redisè¿½è¸ª](#32-redisè¿½è¸ª)
  - [4. æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª](#4-æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª)
    - [4.1 Kafka Producer](#41-kafka-producer)
    - [4.2 Kafka Consumer](#42-kafka-consumer)
  - [5. Collectoré…ç½®](#5-collectoré…ç½®)
  - [6. å¯è§†åŒ–åˆ†æ](#6-å¯è§†åŒ–åˆ†æ)
    - [6.1 æ­£å¸¸è¯·æ±‚é“¾è·¯](#61-æ­£å¸¸è¯·æ±‚é“¾è·¯)
    - [6.2 é”™è¯¯è¯Šæ–­](#62-é”™è¯¯è¯Šæ–­)
    - [6.3 æ€§èƒ½ç“¶é¢ˆåˆ†æ](#63-æ€§èƒ½ç“¶é¢ˆåˆ†æ)
  - [7. ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ](#7-ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ)
  - [8. æ•…éšœæ’æŸ¥æ¡ˆä¾‹](#8-æ•…éšœæ’æŸ¥æ¡ˆä¾‹)
    - [8.1 æ¡ˆä¾‹1: è®¢å•åˆ›å»ºæ…¢](#81-æ¡ˆä¾‹1-è®¢å•åˆ›å»ºæ…¢)
    - [8.2 æ¡ˆä¾‹2: é—´æ­‡æ€§å¤±è´¥](#82-æ¡ˆä¾‹2-é—´æ­‡æ€§å¤±è´¥)
  - [9. å‚è€ƒèµ„æº](#9-å‚è€ƒèµ„æº)

## 1. åœºæ™¯æ¦‚è¿°

### 1.1 ç³»ç»Ÿæ¶æ„

**ç”µå•†è®¢å•ç³»ç»Ÿæ¶æ„**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Browser   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ HTTP
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Gateway       â”‚ (Go)
â”‚   - è®¤è¯            â”‚
â”‚   - è·¯ç”±            â”‚
â”‚   - é™æµ            â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ gRPC
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Order Service     â”‚ (Go)
â”‚   - åˆ›å»ºè®¢å•         â”‚
â”‚   - è®¢å•ç®¡ç†         â”‚
â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚        â”‚
   â”‚ gRPC   â”‚ Kafka
   â”‚        â”‚
   â–¼        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Inventory    â”‚  â”‚ Notification   â”‚
â”‚ Service      â”‚  â”‚ Service        â”‚
â”‚ (Python)     â”‚  â”‚ (Node.js)      â”‚
â”‚ - åº“å­˜æ£€æŸ¥    â”‚  â”‚ - å‘é€é€šçŸ¥      â”‚
â”‚ - åº“å­˜æ‰£å‡    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ HTTP
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Payment Service   â”‚ (Java)
â”‚   - æ”¯ä»˜å¤„ç†         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ•°æ®å­˜å‚¨:
- PostgreSQL: è®¢å•ã€åº“å­˜
- Redis: ç¼“å­˜ã€ä¼šè¯
- Kafka: æ¶ˆæ¯é˜Ÿåˆ—
```

### 1.2 æŠ€æœ¯æ ˆ

**ç»„ä»¶æ¸…å•**ï¼š

```text
æœåŠ¡:
- API Gateway: Go + net/http
- Order Service: Go + gRPC
- Inventory Service: Python + FastAPI
- Payment Service: Java + Spring Boot
- Notification Service: Node.js + Express

æ•°æ®åº“:
- PostgreSQL 14
- Redis 7
- Kafka 3.0

å¯è§‚æµ‹æ€§:
- OpenTelemetry SDK (å„è¯­è¨€)
- OpenTelemetry Collector
- Jaeger (è¿½è¸ªåç«¯)
- Prometheus (æŒ‡æ ‡)
- Grafana (å¯è§†åŒ–)
```

---

## 2. æœåŠ¡å®ç°

### 2.1 API Gateway (Go)

**å®Œæ•´å®ç°**ï¼š

```go
package main

import (
    "context"
    "net/http"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

var tracer = otel.Tracer("api-gateway")

func main() {
    // åˆå§‹åŒ–è¿½è¸ª
    tp, err := initTracer()
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(context.Background())

    // è®¾ç½®è·¯ç”±
    http.HandleFunc("/api/orders", handleCreateOrder)
    http.HandleFunc("/api/orders/", handleGetOrder)

    // å¯åŠ¨æœåŠ¡å™¨
    http.ListenAndServe(":8080", TracingMiddleware(http.DefaultServeMux))
}

func initTracer() (*trace.TracerProvider, error) {
    // åˆ›å»ºOTLP exporter
    exporter, err := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("otel-collector:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }

    // å®šä¹‰Resource
    res, err := resource.New(context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String("api-gateway"),
            semconv.ServiceVersionKey.String("1.0.0"),
            semconv.DeploymentEnvironmentKey.String("production"),
        ),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»ºTracerProvider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(res),
        trace.WithSampler(trace.ParentBased(trace.TraceIDRatioBased(0.1))),
    )

    otel.SetTracerProvider(tp)
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return tp, nil
}

// TracingMiddleware: HTTPè¿½è¸ªä¸­é—´ä»¶
func TracingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // æå–ä¸Šæ¸¸è¿½è¸ªä¸Šä¸‹æ–‡
        ctx := otel.GetTextMapPropagator().Extract(r.Context(),
            propagation.HeaderCarrier(r.Header))

        // åˆ›å»ºSERVER span
        ctx, span := tracer.Start(ctx, r.Method+" "+r.URL.Path,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                semconv.HTTPMethodKey.String(r.Method),
                semconv.HTTPTargetKey.String(r.URL.Path),
                semconv.HTTPSchemeKey.String(getScheme(r)),
                semconv.HTTPClientIPKey.String(getClientIP(r)),
                semconv.UserAgentOriginalKey.String(r.UserAgent()),
            ),
        )
        defer span.End()

        // åŒ…è£…ResponseWriter
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}

        // å¤„ç†è¯·æ±‚
        next.ServeHTTP(wrapped, r.WithContext(ctx))

        // è®°å½•å“åº”
        span.SetAttributes(
            semconv.HTTPStatusCodeKey.Int(wrapped.statusCode),
        )

        if wrapped.statusCode >= 400 {
            span.SetStatus(codes.Error, http.StatusText(wrapped.statusCode))
        } else {
            span.SetStatus(codes.Ok, "")
        }
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// handleCreateOrder: åˆ›å»ºè®¢å•
func handleCreateOrder(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    // ä¸šåŠ¡é€»è¾‘span
    ctx, span := tracer.Start(ctx, "CreateOrder")
    defer span.End()

    // è§£æè¯·æ±‚
    var req CreateOrderRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Invalid request")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    span.SetAttributes(
        attribute.String("order.user_id", req.UserID),
        attribute.Int("order.item_count", len(req.Items)),
    )

    // è°ƒç”¨Order Service
    orderID, err := callOrderService(ctx, &req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Order service failed")
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "")

    // è¿”å›å“åº”
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]string{
        "order_id": orderID,
    })
}

// callOrderService: è°ƒç”¨Order Service (gRPC)
func callOrderService(ctx context.Context, req *CreateOrderRequest) (string, error) {
    // gRPCè¿æ¥ (ä½¿ç”¨è‡ªåŠ¨è¿½è¸ªæ‹¦æˆªå™¨)
    conn, err := grpc.Dial("order-service:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),
    )
    if err != nil {
        return "", err
    }
    defer conn.Close()

    client := pb.NewOrderServiceClient(conn)

    // è°ƒç”¨gRPC (è‡ªåŠ¨åˆ›å»ºCLIENT span)
    resp, err := client.CreateOrder(ctx, &pb.CreateOrderRequest{
        UserId: req.UserID,
        Items:  convertItems(req.Items),
    })
    if err != nil {
        return "", err
    }

    return resp.OrderId, nil
}

func getScheme(r *http.Request) string {
    if r.TLS != nil {
        return "https"
    }
    return "http"
}

func getClientIP(r *http.Request) string {
    if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
        return strings.Split(xff, ",")[0]
    }
    host, _, _ := net.SplitHostPort(r.RemoteAddr)
    return host
}
```

### 2.2 Order Service (Go)

**gRPCæœåŠ¡å®ç°**ï¼š

```go
package main

import (
    "context"
    "net"

    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "google.golang.org/grpc"
)

type orderServiceServer struct {
    pb.UnimplementedOrderServiceServer
    db              *sql.DB
    inventoryClient pb.InventoryServiceClient
    kafkaProducer   *kafka.Producer
}

func (s *orderServiceServer) CreateOrder(ctx context.Context, req *pb.CreateOrderRequest) (*pb.CreateOrderResponse, error) {
    // ctxå·²åŒ…å«SERVER span (é€šè¿‡æ‹¦æˆªå™¨)
    span := trace.SpanFromContext(ctx)

    span.SetAttributes(
        attribute.String("user.id", req.UserId),
        attribute.Int("items.count", len(req.Items)),
    )

    // 1. éªŒè¯åº“å­˜
    ctx, checkSpan := tracer.Start(ctx, "CheckInventory")
    available, err := s.checkInventory(ctx, req.Items)
    checkSpan.End()

    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Inventory check failed")
        return nil, err
    }

    if !available {
        span.SetStatus(codes.Error, "Insufficient inventory")
        return nil, status.Error(codes.FailedPrecondition, "Insufficient inventory")
    }

    // 2. åˆ›å»ºè®¢å• (æ•°æ®åº“)
    ctx, dbSpan := tracer.Start(ctx, "CreateOrderInDB",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemPostgreSQL,
            semconv.DBName("orders"),
            semconv.DBOperation("INSERT"),
        ),
    )

    orderID, err := s.createOrderInDB(ctx, req)
    dbSpan.End()

    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Database error")
        return nil, err
    }

    span.SetAttributes(attribute.String("order.id", orderID))

    // 3. æ‰£å‡åº“å­˜
    ctx, deductSpan := tracer.Start(ctx, "DeductInventory")
    err = s.deductInventory(ctx, req.Items)
    deductSpan.End()

    if err != nil {
        // è¡¥å¿: åˆ é™¤è®¢å•
        s.deleteOrder(ctx, orderID)
        span.RecordError(err)
        span.SetStatus(codes.Error, "Inventory deduction failed")
        return nil, err
    }

    // 4. å‘é€è®¢å•åˆ›å»ºäº‹ä»¶ (Kafka)
    ctx, kafkaSpan := tracer.Start(ctx, "PublishOrderCreated",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKafka,
            semconv.MessagingDestinationKindTopic,
            semconv.MessagingDestination("order.events"),
        ),
    )

    err = s.publishOrderCreatedEvent(ctx, orderID, req)
    kafkaSpan.End()

    if err != nil {
        // éå…³é”®é”™è¯¯, è®°å½•ä½†ç»§ç»­
        span.AddEvent("Failed to publish event", trace.WithAttributes(
            attribute.String("error", err.Error()),
        ))
    }

    span.SetStatus(codes.Ok, "")

    return &pb.CreateOrderResponse{
        OrderId: orderID,
        Status:  "CREATED",
    }, nil
}

func (s *orderServiceServer) checkInventory(ctx context.Context, items []*pb.OrderItem) (bool, error) {
    // è°ƒç”¨Inventory Service (gRPC)
    resp, err := s.inventoryClient.CheckAvailability(ctx, &pb.CheckAvailabilityRequest{
        Items: items,
    })
    if err != nil {
        return false, err
    }

    return resp.Available, nil
}

func (s *orderServiceServer) createOrderInDB(ctx context.Context, req *pb.CreateOrderRequest) (string, error) {
    span := trace.SpanFromContext(ctx)

    orderID := generateOrderID()

    // SQLæ‰§è¡Œ
    query := `INSERT INTO orders (id, user_id, status, created_at) VALUES ($1, $2, $3, $4)`

    span.SetAttributes(
        semconv.DBStatement(query),
        semconv.DBSQLTable("orders"),
    )

    _, err := s.db.ExecContext(ctx, query, orderID, req.UserId, "CREATED", time.Now())
    if err != nil {
        span.RecordError(err)
        return "", err
    }

    return orderID, nil
}

func main() {
    // åˆå§‹åŒ–è¿½è¸ª
    tp, _ := initTracer("order-service")
    defer tp.Shutdown(context.Background())

    // åˆ›å»ºgRPCæœåŠ¡å™¨ (ä½¿ç”¨è‡ªåŠ¨è¿½è¸ªæ‹¦æˆªå™¨)
    server := grpc.NewServer(
        grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()),
        grpc.StreamInterceptor(otelgrpc.StreamServerInterceptor()),
    )

    pb.RegisterOrderServiceServer(server, &orderServiceServer{
        db:              initDB(),
        inventoryClient: createInventoryClient(),
        kafkaProducer:   createKafkaProducer(),
    })

    lis, _ := net.Listen("tcp", ":50051")
    server.Serve(lis)
}
```

### 2.3 Inventory Service (Python)

**FastAPIå®ç°**ï¼š

```python
from fastapi import FastAPI, Request
from opentelemetry import trace
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
from opentelemetry.instrumentation.redis import RedisInstrumentor
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.sdk.resources import Resource
from opentelemetry.semconv.resource import ResourceAttributes

# åˆå§‹åŒ–è¿½è¸ª
resource = Resource(attributes={
    ResourceAttributes.SERVICE_NAME: "inventory-service",
    ResourceAttributes.SERVICE_VERSION: "1.0.0",
    ResourceAttributes.DEPLOYMENT_ENVIRONMENT: "production",
})

provider = TracerProvider(resource=resource)
processor = BatchSpanProcessor(OTLPSpanExporter(endpoint="otel-collector:4317"))
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)

tracer = trace.get_tracer(__name__)

# åˆ›å»ºFastAPIåº”ç”¨
app = FastAPI()

# è‡ªåŠ¨instrumentation
FastAPIInstrumentor.instrument_app(app)
SQLAlchemyInstrumentor().instrument(engine=db_engine)
RedisInstrumentor().instrument()

@app.post("/api/inventory/check")
async def check_inventory(request: CheckInventoryRequest):
    """æ£€æŸ¥åº“å­˜å¯ç”¨æ€§"""
    with tracer.start_as_current_span("CheckInventory") as span:
        span.set_attributes({
            "inventory.item_count": len(request.items),
        })

        # 1. æ£€æŸ¥Redisç¼“å­˜
        with tracer.start_as_current_span("CheckCache",
            kind=trace.SpanKind.CLIENT) as cache_span:
            cache_span.set_attributes({
                "db.system": "redis",
                "db.operation": "MGET",
            })

            cached = redis_client.mget([f"inventory:{item.sku}" for item in request.items])

        # 2. å¦‚æœç¼“å­˜æœªå‘½ä¸­,æŸ¥è¯¢æ•°æ®åº“
        if None in cached:
            with tracer.start_as_current_span("QueryDatabase",
                kind=trace.SpanKind.CLIENT) as db_span:
                db_span.set_attributes({
                    "db.system": "postgresql",
                    "db.name": "inventory",
                    "db.operation": "SELECT",
                    "db.sql.table": "inventory",
                })

                inventory = db.query(Inventory).filter(
                    Inventory.sku.in_([item.sku for item in request.items])
                ).all()

                # æ›´æ–°ç¼“å­˜
                for inv in inventory:
                    redis_client.setex(f"inventory:{inv.sku}", 300, inv.quantity)

        # 3. æ£€æŸ¥æ•°é‡
        available = all(inv.quantity >= item.quantity for inv in inventory)

        span.set_attribute("inventory.available", available)

        if available:
            span.set_status(trace.Status(trace.StatusCode.OK))
        else:
            span.set_status(trace.Status(
                trace.StatusCode.ERROR,
                "Insufficient inventory"
            ))

        return {"available": available}

@app.post("/api/inventory/deduct")
async def deduct_inventory(request: DeductInventoryRequest):
    """æ‰£å‡åº“å­˜"""
    with tracer.start_as_current_span("DeductInventory") as span:
        try:
            # æ•°æ®åº“äº‹åŠ¡
            with db.begin():
                for item in request.items:
                    db.execute(
                        "UPDATE inventory SET quantity = quantity - :qty WHERE sku = :sku",
                        {"qty": item.quantity, "sku": item.sku}
                    )

                    # æ¸…é™¤ç¼“å­˜
                    redis_client.delete(f"inventory:{item.sku}")

            span.set_status(trace.Status(trace.StatusCode.OK))
            return {"success": True}

        except Exception as e:
            span.record_exception(e)
            span.set_status(trace.Status(
                trace.StatusCode.ERROR,
                str(e)
            ))
            raise
```

### 2.4 Payment Service (Java)

**Spring Bootå®ç°**ï¼š

```java
package com.example.payment;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.*;

@SpringBootApplication
@RestController
@RequestMapping("/api/payment")
public class PaymentService {

    private final Tracer tracer;

    public PaymentService(OpenTelemetry openTelemetry) {
        this.tracer = openTelemetry.getTracer("payment-service", "1.0.0");
    }

    @PostMapping("/process")
    public PaymentResponse processPayment(@RequestBody PaymentRequest request) {
        // åˆ›å»ºspan
        Span span = tracer.spanBuilder("ProcessPayment")
            .setSpanKind(SpanKind.INTERNAL)
            .startSpan();

        try (Scope scope = span.makeCurrent()) {
            span.setAttribute("payment.order_id", request.getOrderId());
            span.setAttribute("payment.amount", request.getAmount());
            span.setAttribute("payment.method", request.getMethod());

            // 1. éªŒè¯æ”¯ä»˜ä¿¡æ¯
            Span validateSpan = tracer.spanBuilder("ValidatePayment")
                .startSpan();
            try (Scope validateScope = validateSpan.makeCurrent()) {
                validatePaymentInfo(request);
                validateSpan.setStatus(StatusCode.OK);
            } catch (Exception e) {
                validateSpan.recordException(e);
                validateSpan.setStatus(StatusCode.ERROR, "Validation failed");
                throw e;
            } finally {
                validateSpan.end();
            }

            // 2. è°ƒç”¨æ”¯ä»˜ç½‘å…³
            Span gatewaySpan = tracer.spanBuilder("CallPaymentGateway")
                .setSpanKind(SpanKind.CLIENT)
                .setAttribute("http.method", "POST")
                .setAttribute("http.url", "https://payment-gateway.com/charge")
                .startSpan();

            String transactionId;
            try (Scope gatewayScope = gatewaySpan.makeCurrent()) {
                transactionId = callPaymentGateway(request);
                gatewaySpan.setAttribute("payment.transaction_id", transactionId);
                gatewaySpan.setStatus(StatusCode.OK);
            } catch (Exception e) {
                gatewaySpan.recordException(e);
                gatewaySpan.setStatus(StatusCode.ERROR, "Gateway error");
                throw e;
            } finally {
                gatewaySpan.end();
            }

            // 3. ä¿å­˜æ”¯ä»˜è®°å½•
            Span dbSpan = tracer.spanBuilder("SavePaymentRecord")
                .setSpanKind(SpanKind.CLIENT)
                .setAttribute("db.system", "postgresql")
                .setAttribute("db.name", "payments")
                .setAttribute("db.operation", "INSERT")
                .startSpan();

            try (Scope dbScope = dbSpan.makeCurrent()) {
                savePaymentRecord(request, transactionId);
                dbSpan.setStatus(StatusCode.OK);
            } finally {
                dbSpan.end();
            }

            span.setStatus(StatusCode.OK);

            return new PaymentResponse(transactionId, "SUCCESS");

        } catch (Exception e) {
            span.recordException(e);
            span.setStatus(StatusCode.ERROR, e.getMessage());
            throw new PaymentException("Payment processing failed", e);
        } finally {
            span.end();
        }
    }

    public static void main(String[] args) {
        SpringApplication.run(PaymentService.class, args);
    }
}
```

---

## 3. æ•°æ®åº“è¿½è¸ª

### 3.1 PostgreSQLè¿½è¸ª

**è‡ªåŠ¨instrumentation (Go)**ï¼š

```go
import (
    "database/sql"
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// ä½¿ç”¨otelsqlåŒ…è£…database/sql
db, err := otelsql.Open("postgres", "postgres://user:pass@localhost/dbname",
    otelsql.WithAttributes(
        semconv.DBSystemPostgreSQL,
    ),
)

// æ‰€æœ‰SQLæ“ä½œè‡ªåŠ¨åˆ›å»ºspan
rows, err := db.QueryContext(ctx, "SELECT * FROM orders WHERE user_id = $1", userID)
// è‡ªåŠ¨åˆ›å»ºspan:
//   name: "SELECT orders"
//   attributes:
//     db.system: "postgresql"
//     db.statement: "SELECT * FROM orders WHERE user_id = $1"
//     db.sql.table: "orders"
```

### 3.2 Redisè¿½è¸ª

**æ‰‹åŠ¨è¿½è¸ªRedisæ“ä½œ**ï¼š

```go
func GetFromCache(ctx context.Context, key string) (string, error) {
    ctx, span := tracer.Start(ctx, "Redis GET",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemRedis,
            semconv.DBOperation("GET"),
            semconv.DBStatement(fmt.Sprintf("GET %s", key)),
        ),
    )
    defer span.End()

    val, err := redisClient.Get(ctx, key).Result()
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Redis error")
        return "", err
    }

    span.SetStatus(codes.Ok, "")
    return val, nil
}
```

---

## 4. æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª

### 4.1 Kafka Producer

```go
func PublishOrderCreatedEvent(ctx context.Context, orderID string, order *Order) error {
    ctx, span := tracer.Start(ctx, "Publish order.created",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKafka,
            semconv.MessagingDestinationKindTopic,
            semconv.MessagingDestination("order.events"),
            attribute.String("messaging.kafka.message.key", orderID),
        ),
    )
    defer span.End()

    // åºåˆ—åŒ–äº‹ä»¶
    event := OrderCreatedEvent{
        OrderID:   orderID,
        UserID:    order.UserID,
        Timestamp: time.Now(),
    }

    data, _ := json.Marshal(event)

    // åˆ›å»ºKafkaæ¶ˆæ¯
    msg := &kafka.Message{
        Topic: "order.events",
        Key:   []byte(orderID),
        Value: data,
        Headers: []kafka.Header{},
    }

    // æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡åˆ°æ¶ˆæ¯å¤´
    otel.GetTextMapPropagator().Inject(ctx, &kafkaHeaderCarrier{msg})

    // å‘é€æ¶ˆæ¯
    err := producer.WriteMessages(ctx, msg)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "Kafka publish failed")
        return err
    }

    span.SetStatus(codes.Ok, "")
    return nil
}

// Kafka Header Carrier
type kafkaHeaderCarrier struct {
    msg *kafka.Message
}

func (c *kafkaHeaderCarrier) Get(key string) string {
    for _, h := range c.msg.Headers {
        if h.Key == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeaderCarrier) Set(key, value string) {
    c.msg.Headers = append(c.msg.Headers, kafka.Header{
        Key:   key,
        Value: []byte(value),
    })
}

func (c *kafkaHeaderCarrier) Keys() []string {
    keys := make([]string, len(c.msg.Headers))
    for i, h := range c.msg.Headers {
        keys[i] = h.Key
    }
    return keys
}
```

### 4.2 Kafka Consumer

```go
func ConsumeOrderEvents(ctx context.Context) {
    reader := kafka.NewReader(kafka.ReaderConfig{
        Brokers: []string{"localhost:9092"},
        Topic:   "order.events",
        GroupID: "notification-service",
    })

    for {
        msg, err := reader.FetchMessage(ctx)
        if err != nil {
            break
        }

        // æå–è¿½è¸ªä¸Šä¸‹æ–‡
        ctx := otel.GetTextMapPropagator().Extract(context.Background(),
            &kafkaHeaderCarrier{&msg})

        // åˆ›å»ºCONSUMER span
        ctx, span := tracer.Start(ctx, "Process order.created",
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                semconv.MessagingSystemKafka,
                semconv.MessagingDestinationKindTopic,
                semconv.MessagingDestination("order.events"),
                semconv.MessagingOperationReceive,
                attribute.String("messaging.kafka.message.key", string(msg.Key)),
            ),
        )

        // å¤„ç†æ¶ˆæ¯
        err = processOrderCreatedEvent(ctx, msg.Value)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, "Processing failed")
        } else {
            span.SetStatus(codes.Ok, "")
        }

        span.End()

        // æäº¤offset
        reader.CommitMessages(ctx, msg)
    }
}
```

---

## 5. Collectoré…ç½®

**å®Œæ•´Collectoré…ç½®**ï¼š

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  # æ‰¹å¤„ç†
  batch:
    timeout: 10s
    send_batch_size: 1024

  # é‡‡æ · (ç”Ÿäº§ç¯å¢ƒ10%)
  probabilistic_sampler:
    sampling_percentage: 10

  # èµ„æºæ£€æµ‹
  resourcedetection:
    detectors: [env, system, docker]

  # å±æ€§å¤„ç†
  attributes:
    actions:
      - key: environment
        value: production
        action: upsert

exporters:
  # Jaeger
  jaeger:
    endpoint: jaeger:14250
    tls:
      insecure: true

  # Prometheus (metrics)
  prometheus:
    endpoint: 0.0.0.0:8889

  # Logging (è°ƒè¯•)
  logging:
    loglevel: info

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch, resourcedetection, attributes, probabilistic_sampler]
      exporters: [jaeger, logging]

    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [prometheus]
```

---

## 6. å¯è§†åŒ–åˆ†æ

### 6.1 æ­£å¸¸è¯·æ±‚é“¾è·¯

**Jaeger UIæ˜¾ç¤º**ï¼š

```text
Trace: 5b8efff798038103d269b633813fc60c
Duration: 285ms
Spans: 15

Timeline:
â”Œâ”€ API Gateway: POST /api/orders (285ms) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”œâ”€ CreateOrder (280ms)                                  â”‚
â”‚  â”‚  â””â”€ Order Service: CreateOrder (275ms)                â”‚
â”‚  â”‚     â”œâ”€ CheckInventory (50ms)                          â”‚
â”‚  â”‚     â”‚  â””â”€ Inventory Service: Check (45ms)             â”‚
â”‚  â”‚     â”‚     â”œâ”€ Redis GET (5ms)                          â”‚
â”‚  â”‚     â”‚     â””â”€ PostgreSQL SELECT (35ms)                 â”‚
â”‚  â”‚     â”œâ”€ CreateOrderInDB (80ms)                         â”‚
â”‚  â”‚     â”‚  â””â”€ PostgreSQL INSERT (75ms)                    â”‚
â”‚  â”‚     â”œâ”€ DeductInventory (100ms)                        â”‚
â”‚  â”‚     â”‚  â””â”€ Inventory Service: Deduct (95ms)            â”‚
â”‚  â”‚     â”‚     â””â”€ PostgreSQL UPDATE (90ms)                 â”‚
â”‚  â”‚     â””â”€ PublishOrderCreated (25ms)                     â”‚
â”‚  â”‚        â””â”€ Kafka Producer (20ms)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åˆ†æ:
- æ€»å»¶è¿Ÿ: 285ms
- æœ€æ…¢æ“ä½œ: DeductInventory (100ms)
- æ•°æ®åº“æ“ä½œ: 200ms (70%)
- ç½‘ç»œè°ƒç”¨: 3æ¬¡ gRPC + 1æ¬¡ Kafka
```

### 6.2 é”™è¯¯è¯Šæ–­

**é”™è¯¯traceç¤ºä¾‹**ï¼š

```text
Trace: abc123... (é”™è¯¯)
Duration: 5050ms (è¶…æ—¶!)
Spans: 8

Timeline:
â”Œâ”€ API Gateway: POST /api/orders (5050ms) âŒâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”œâ”€ CreateOrder (5045ms) âŒ                              â”‚
â”‚  â”‚  â””â”€ Order Service: CreateOrder (5040ms) âŒ            â”‚
â”‚  â”‚     â”œâ”€ CheckInventory (50ms) âœ…                       â”‚
â”‚  â”‚     â”œâ”€ CreateOrderInDB (80ms) âœ…                      â”‚
â”‚  â”‚     â””â”€ DeductInventory (5000ms) âŒ TIMEOUT            â”‚
â”‚  â”‚        â””â”€ Inventory Service: Deduct (5000ms) âŒ       â”‚
â”‚  â”‚           â””â”€ PostgreSQL UPDATE (5000ms) âŒ DEADLOCK   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é”™è¯¯è¯¦æƒ…:
Span: PostgreSQL UPDATE
Status: ERROR
Message: "pq: deadlock detected"
Stack Trace:
  at (*DB).ExecContext (db.go:1234)
  at deductInventory (inventory.go:56)

æ ¹å› åˆ†æ:
1. æ•°æ®åº“æ­»é”
2. å¯¼è‡´UPDATEè¶…æ—¶ (5s)
3. å½±å“æ•´ä¸ªè¯·æ±‚é“¾è·¯

è§£å†³æ–¹æ¡ˆ:
- ä¼˜åŒ–SQLæŸ¥è¯¢é¡ºåº
- å‡å°‘é”æŒæœ‰æ—¶é—´
- å®ç°é‡è¯•æœºåˆ¶
```

### 6.3 æ€§èƒ½ç“¶é¢ˆåˆ†æ

**æ…¢traceåˆ†æ**ï¼š

```text
åœºæ™¯: è®¢å•åˆ›å»ºå»¶è¿Ÿé«˜ (p95 > 2s)

æŸ¥è¯¢Jaeger:
- duration > 2000ms
- service: order-service
- operation: CreateOrder

å‘ç°:
1. 50%çš„æ…¢traceæœ‰ç›¸åŒç‰¹å¾:
   - CheckInventory: 1500ms (å¼‚å¸¸æ…¢!)
   - æ­£å¸¸åº”è¯¥: 50ms

2. æ·±å…¥CheckInventory span:
   - Redis GET: 5ms âœ…
   - PostgreSQL SELECT: 1480ms âŒ æ…¢æŸ¥è¯¢!

3. æŸ¥çœ‹SQL:
   db.statement: "SELECT * FROM inventory WHERE sku IN (...)"

   é—®é¢˜: æ²¡æœ‰ç´¢å¼•!

è§£å†³:
CREATE INDEX idx_inventory_sku ON inventory(sku);

ç»“æœ:
- CheckInventory: 50ms â†’ 10ms
- æ•´ä½“p95å»¶è¿Ÿ: 2000ms â†’ 300ms
```

---

## 7. ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ

```text
1. é‡‡æ ·
   âœ… ä½¿ç”¨ParentBased(TraceIDRatioBased(0.1))
   âœ… æ€»æ˜¯é‡‡æ ·é”™è¯¯ (è‡ªå®šä¹‰é‡‡æ ·å™¨)
   âœ… ç›‘æ§é‡‡æ ·ç‡

2. èµ„æºç®¡ç†
   âœ… é…ç½®åˆç†çš„batch sizeå’Œtimeout
   âœ… é™åˆ¶å¹¶å‘spanæ•°
   âœ… ç›‘æ§Collectoræ€§èƒ½

3. å±æ€§æ§åˆ¶
   âœ… é¿å…é«˜åŸºæ•°å±æ€§
   âŒ ä¸è¦è®°å½•user_id, request_id
   âœ… ä½¿ç”¨http.routeè€Œéurl.path

4. é”™è¯¯å¤„ç†
   âœ… æ€»æ˜¯è®°å½•exception
   âœ… è®¾ç½®span status
   âœ… æ·»åŠ æœ‰ç”¨çš„event

5. æ€§èƒ½
   âœ… ä½¿ç”¨å¼‚æ­¥å¯¼å‡º
   âœ… å¤ç”¨tracerå¯¹è±¡
   âœ… é¿å…è¿‡åº¦instrumentation

6. å®‰å…¨
   âœ… ä¸è¦è®°å½•æ•æ„Ÿä¿¡æ¯
   âœ… è„±æ•SQLè¯­å¥
   âœ… ä½¿ç”¨TLSä¼ è¾“

7. ç›‘æ§
   âœ… ç›‘æ§è¿½è¸ªè¦†ç›–ç‡
   âœ… ç›‘æ§spanä¸¢å¤±ç‡
   âœ… ç›‘æ§Collectorå¥åº·çŠ¶æ€
```

---

## 8. æ•…éšœæ’æŸ¥æ¡ˆä¾‹

### 8.1 æ¡ˆä¾‹1: è®¢å•åˆ›å»ºæ…¢

**é—®é¢˜æè¿°**ï¼š

```text
ç°è±¡:
- p95å»¶è¿Ÿä»300msçªç„¶ä¸Šå‡åˆ°2000ms
- é”™è¯¯ç‡æ­£å¸¸ (<1%)
- å½±å“: ç”¨æˆ·ä½“éªŒå·®

æ’æŸ¥æ­¥éª¤:
1. JaegeræŸ¥è¯¢æ…¢trace
   - operation: CreateOrder
   - duration > 2000ms
   - time range: æœ€è¿‘1å°æ—¶

2. åˆ†ææ…¢traceå…±åŒç‚¹
   - 50ä¸ªtraceæ ·æœ¬
   - å…±åŒç‰¹å¾: CheckInventoryæ…¢ (1500ms)

3. æ·±å…¥CheckInventory
   - Redis GET: 5ms (æ­£å¸¸)
   - PostgreSQL SELECT: 1480ms (å¼‚å¸¸!)

4. æŸ¥çœ‹æ•°æ®åº“
   - æ…¢æŸ¥è¯¢æ—¥å¿—
   - å‘ç°: "SELECT * FROM inventory WHERE sku IN (...)"
   - æ‰§è¡Œè®¡åˆ’: Seq Scan (å…¨è¡¨æ‰«æ)

5. æ ¹å› 
   - ç´¢å¼•è¢«æ„å¤–åˆ é™¤
   - æˆ–æ•°æ®é‡å¢é•¿å¯¼è‡´ç´¢å¼•å¤±æ•ˆ

è§£å†³:
CREATE INDEX idx_inventory_sku ON inventory(sku);
ANALYZE inventory;

éªŒè¯:
- é‡æ–°é‡‡æ ·
- CheckInventory: 10ms
- p95å»¶è¿Ÿ: 300ms
- é—®é¢˜è§£å†³!
```

### 8.2 æ¡ˆä¾‹2: é—´æ­‡æ€§å¤±è´¥

**é—®é¢˜æè¿°**ï¼š

```text
ç°è±¡:
- é”™è¯¯ç‡å‘¨æœŸæ€§ä¸Šå‡ (æ¯5åˆ†é’Ÿ)
- é”™è¯¯: "Payment service unavailable"
- å½±å“: 10%è¯·æ±‚å¤±è´¥

æ’æŸ¥æ­¥éª¤:
1. JaegeræŸ¥è¯¢é”™è¯¯trace
   - status: error
   - service: order-service
   - error.message: "Payment service unavailable"

2. åˆ†æé”™è¯¯trace
   - CallPaymentService span: ERROR
   - gRPC status: UNAVAILABLE (14)
   - pattern: æ¯5åˆ†é’Ÿä¸€æ¬¡

3. æ£€æŸ¥Payment Service
   - æ—¥å¿—: "Connection reset by peer"
   - æŒ‡æ ‡: è¿æ¥æ± è€—å°½

4. å‘ç°é—®é¢˜
   - Payment Serviceæœ‰å®šæ—¶ä»»åŠ¡
   - æ¯5åˆ†é’Ÿé‡å¯è¿æ¥æ± 
   - å¯¼è‡´æ­£åœ¨å¤„ç†çš„è¯·æ±‚å¤±è´¥

è§£å†³:
- ä¼˜é›…å…³é—­è¿æ¥æ± 
- ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ
- å®ç°é‡è¯•æœºåˆ¶ (Order Service)

ä»£ç ä¿®æ”¹:
// Order Serviceæ·»åŠ é‡è¯•
client := pb.NewPaymentServiceClient(conn)
for i := 0; i < 3; i++ {
    resp, err := client.ProcessPayment(ctx, req)
    if err == nil {
        return resp, nil
    }
    if isRetryable(err) {
        time.Sleep(time.Second * time.Duration(i+1))
        continue
    }
    return nil, err
}

éªŒè¯:
- é”™è¯¯ç‡: 10% â†’ 0.1%
- é‡è¯•æˆåŠŸç‡: 95%
- ç”¨æˆ·å½±å“: æœ€å°åŒ–
```

---

## 9. å‚è€ƒèµ„æº

- **OpenTelemetry Go**: <https://github.com/open-telemetry/opentelemetry-go>
- **OpenTelemetry Python**: <https://github.com/open-telemetry/opentelemetry-python>
- **OpenTelemetry Java**: <https://github.com/open-telemetry/opentelemetry-java>
- **Jaeger**: <https://www.jaegertracing.io/>

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸
**ç›¸å…³æ–‡æ¡£**: [é‡‡æ ·ç­–ç•¥](../05_é‡‡æ ·ä¸æ€§èƒ½/01_é‡‡æ ·ç­–ç•¥.md), [SDKæ¦‚è¿°](../04_æ ¸å¿ƒç»„ä»¶/01_SDKæ¦‚è¿°.md)
