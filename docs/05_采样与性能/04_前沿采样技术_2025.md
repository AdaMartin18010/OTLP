# 2025å¹´å‰æ²¿è¿½è¸ªé‡‡æ ·æŠ€æœ¯ï¼šTracezipä¸Autoscope

> **æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ17æ—¥
> **ç ”ç©¶æ—¶æ•ˆ**: 2025å¹´æœ€æ–°
> **é‡è¦æ€§**: â­â­â­â­â­ P1ä¼˜å…ˆçº§
> **é€‚ç”¨åœºæ™¯**: å¤§è§„æ¨¡åˆ†å¸ƒå¼è¿½è¸ªã€æˆæœ¬ä¼˜åŒ–

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£ä»‹ç»2025å¹´åˆ†å¸ƒå¼è¿½è¸ªé¢†åŸŸçš„ä¸¤é¡¹é‡å¤§ç ”ç©¶çªç ´ï¼š

### Tracezipï¼šè¿½è¸ªå‹ç¼©æŠ€æœ¯

- ğŸ“š **è®ºæ–‡**: arXiv:2502.06318 (2025å¹´2æœˆ)
- ğŸ¯ **æ ¸å¿ƒ**: é€šè¿‡Span Retrieval Treeï¼ˆSRTï¼‰å‹ç¼©å†—ä½™è¿½è¸ªæ•°æ®
- ğŸ“‰ **æ•ˆæœ**: å‡å°‘ä¼ è¾“å’Œå­˜å‚¨å¼€é”€ï¼Œæå‡ç›‘æ§æ•ˆç‡
- ğŸ’¡ **åˆ›æ–°**: æœåŠ¡ç«¯å°è£…å†—ä½™ï¼Œè½»é‡çº§spanå½¢å¼

### Autoscopeï¼šæ™ºèƒ½é‡‡æ ·æ–¹æ³•

- ğŸ“š **è®ºæ–‡**: arXiv:2509.13852 (2025å¹´9æœˆ)
- ğŸ¯ **æ ¸å¿ƒ**: åŸºäºé™æ€ä»£ç åˆ†æçš„spançº§é‡‡æ ·
- ğŸ“‰ **æ•ˆæœ**: è¿½è¸ªå¤§å°å‡å°‘81.2%ï¼Œæ•…éšœè¦†ç›–ç‡98.1%
- ğŸ’¡ **åˆ›æ–°**: ä¿æŒè¿½è¸ªç»“æ„ä¸€è‡´æ€§çš„æ™ºèƒ½é‡‡æ ·

---

## ğŸ“š ç›®å½•

- [1. ç ”ç©¶èƒŒæ™¯](#1-ç ”ç©¶èƒŒæ™¯)
- [2. Tracezipè¯¦è§£](#2-tracezipè¯¦è§£)
- [3. Autoscopeè¯¦è§£](#3-autoscopeè¯¦è§£)
- [4. ä¸¤ç§æŠ€æœ¯å¯¹æ¯”](#4-ä¸¤ç§æŠ€æœ¯å¯¹æ¯”)
- [5. ä¸ä¼ ç»Ÿé‡‡æ ·å¯¹æ¯”](#5-ä¸ä¼ ç»Ÿé‡‡æ ·å¯¹æ¯”)
- [6. å®éªŒéªŒè¯](#6-å®éªŒéªŒè¯)
- [7. å®è·µåº”ç”¨](#7-å®è·µåº”ç”¨)
- [8. æœªæ¥å±•æœ›](#8-æœªæ¥å±•æœ›)

---

## 1. ç ”ç©¶èƒŒæ™¯

### 1.1 å½“å‰æŒ‘æˆ˜

#### é—®é¢˜1ï¼šè¿½è¸ªæ•°æ®çˆ†ç‚¸

```text
åœºæ™¯ï¼šå¤§å‹ç”µå•†å¹³å°

æœåŠ¡æ•°é‡: 2,000+
æ—¥è¯·æ±‚é‡: 10äº¿+
å¹³å‡è¿½è¸ªé•¿åº¦: 30 spans
æ¯æ—¥è¿½è¸ªæ•°æ®: 30 billion spans

æ•°æ®é‡è®¡ç®—:
- æ¯spanå¹³å‡å¤§å°: 2KB
- æ¯æ—¥åŸå§‹æ•°æ®: 30B Ã— 2KB = 60TB/å¤©
- æœˆå­˜å‚¨æˆæœ¬: 60TB Ã— 30å¤© Ã— $0.023/GB = $41,400/æœˆ

ğŸ’¸ æˆæœ¬é«˜æ˜‚ï¼
```

#### é—®é¢˜2ï¼šä¼ ç»Ÿé‡‡æ ·çš„å±€é™æ€§

```text
ä¼ ç»ŸHead-basedé‡‡æ ·ï¼ˆå›ºå®šé‡‡æ ·ç‡ï¼‰:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é‡‡æ ·ç‡: 1% (99ä¸ªè¯·æ±‚è¢«ä¸¢å¼ƒ)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é—®é¢˜:                               â”‚
â”‚ âŒ ä¸¢å¤±ç½•è§é”™è¯¯è¿½è¸ª                 â”‚
â”‚ âŒ æ— æ³•ä¿è¯å…³é”®è·¯å¾„è¦†ç›–             â”‚
â”‚ âŒ é‡‡æ ·åå·®ä¸¥é‡                     â”‚
â”‚ âŒ ç»“æ„ä¸å®Œæ•´ï¼ˆçˆ¶spanè¢«é‡‡æ ·ï¼Œ       â”‚
â”‚    å­spanå¯èƒ½ä¸¢å¤±ï¼‰                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼ ç»ŸTail-basedé‡‡æ ·ï¼ˆäº‹åå†³ç­–ï¼‰:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å»¶è¿Ÿ: å¿…é¡»ç­‰å¾…è¿½è¸ªå®Œæˆ              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é—®é¢˜:                               â”‚
â”‚ âŒ å»¶è¿Ÿé«˜ï¼ˆéœ€è¦ç¼“å†²æ‰€æœ‰spanï¼‰       â”‚
â”‚ âŒ å†…å­˜å ç”¨å¤§                       â”‚
â”‚ âŒ å®æ—¶æ€§å·®                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç ”ç©¶åŠ¨æœº

**ç›®æ ‡**ï¼šåœ¨ä¿è¯è¿½è¸ªè´¨é‡çš„å‰æä¸‹ï¼Œå¤§å¹…é™ä½æ•°æ®é‡

**è¦æ±‚**ï¼š

1. âœ… é«˜å‹ç¼©ç‡ï¼ˆ>80%ï¼‰
2. âœ… ä¿ç•™å…³é”®ä¿¡æ¯ï¼ˆé”™è¯¯ã€æ…¢è¯·æ±‚ï¼‰
3. âœ… ä¿æŒè¿½è¸ªç»“æ„å®Œæ•´æ€§
4. âœ… ä½æ€§èƒ½å¼€é”€
5. âœ… æ˜“äºå®æ–½

---

## 2. Tracezipè¯¦è§£

### 2.1 æ ¸å¿ƒæ€æƒ³

**Tracezip** é€šè¿‡è¯†åˆ«å’Œå‹ç¼©è¿½è¸ªæ•°æ®ä¸­çš„**å†—ä½™ä¿¡æ¯**æ¥å‡å°‘å­˜å‚¨å’Œä¼ è¾“å¼€é”€ã€‚

#### å…³é”®è§‚å¯Ÿ

```text
è¿½è¸ªæ•°æ®ä¸­çš„å†—ä½™:

1. é‡å¤çš„æœåŠ¡åã€æ“ä½œå
   ç¤ºä¾‹: "GET /api/users" åœ¨åŒä¸€è¿½è¸ªä¸­å‡ºç°10æ¬¡

2. é‡å¤çš„å±æ€§å€¼
   ç¤ºä¾‹: http.method="GET", http.status_code=200 é‡å¤å‡ºç°

3. ç›¸ä¼¼çš„æ—¶é—´æˆ³
   ç¤ºä¾‹: start_timeåªç›¸å·®å‡ æ¯«ç§’ï¼Œå¯ä»¥å¢é‡ç¼–ç 

4. é‡å¤çš„èµ„æºä¿¡æ¯
   ç¤ºä¾‹: service.name, host.name åœ¨æ•´ä¸ªè¿½è¸ªä¸­ç›¸åŒ
```

### 2.2 Span Retrieval Tree (SRT)

**æ ¸å¿ƒæ•°æ®ç»“æ„**ï¼š

```text
SRT: ä¸€ç§é«˜æ•ˆçš„spanç´¢å¼•ç»“æ„

ä¼ ç»Ÿå­˜å‚¨ (æ¯ä¸ªspanç‹¬ç«‹):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Span 1 (å®Œæ•´)    â”‚  2 KB
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Span 2 (å®Œæ•´)    â”‚  2 KB
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Span 3 (å®Œæ•´)    â”‚  2 KB
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ€»å¤§å°: 6 KB

Tracezip (SRT):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…±äº«å­—å…¸         â”‚  200 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Span 1 (å¼•ç”¨)    â”‚  300 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Span 2 (å¢é‡)    â”‚  250 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Span 3 (å¢é‡)    â”‚  250 bytes
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
æ€»å¤§å°: 1 KB

å‹ç¼©ç‡: 83%
```

#### SRTç»“æ„å®šä¹‰

```python
class SpanRetrievalTree:
    """
    Span Retrieval Tree (SRT) - Tracezipæ ¸å¿ƒæ•°æ®ç»“æ„
    """
    def __init__(self):
        # å…±äº«å­—å…¸: å­˜å‚¨é‡å¤çš„å­—ç¬¦ä¸²
        self.string_dictionary = {}
        self.next_string_id = 0

        # å…±äº«èµ„æºä¿¡æ¯
        self.shared_resource = None

        # Spanç´¢å¼•
        self.spans = []

        # æ—¶é—´æˆ³åŸºå‡†
        self.base_timestamp = None

    def add_span(self, span):
        """
        æ·»åŠ spanåˆ°SRTï¼Œè‡ªåŠ¨å‹ç¼©
        """
        compressed_span = {
            'span_id': span.span_id,
            'parent_id': span.parent_span_id,

            # å­—ç¬¦ä¸²å­—å…¸åŒ–
            'name_id': self._get_string_id(span.name),
            'kind': span.kind,

            # æ—¶é—´æˆ³å¢é‡ç¼–ç 
            'start_delta': self._encode_timestamp(span.start_time),
            'duration': span.end_time - span.start_time,

            # å±æ€§å‹ç¼©
            'attributes': self._compress_attributes(span.attributes),
        }

        self.spans.append(compressed_span)
        return len(self.spans) - 1

    def _get_string_id(self, string):
        """
        è·å–å­—ç¬¦ä¸²IDï¼ˆå­—å…¸ç¼–ç ï¼‰
        """
        if string not in self.string_dictionary:
            self.string_dictionary[string] = self.next_string_id
            self.next_string_id += 1
        return self.string_dictionary[string]

    def _encode_timestamp(self, timestamp):
        """
        æ—¶é—´æˆ³å¢é‡ç¼–ç 
        """
        if self.base_timestamp is None:
            self.base_timestamp = timestamp
            return 0
        return timestamp - self.base_timestamp

    def _compress_attributes(self, attributes):
        """
        å‹ç¼©å±æ€§ï¼ˆå­—å…¸åŒ– + å»é‡ï¼‰
        """
        compressed = {}
        for key, value in attributes.items():
            key_id = self._get_string_id(key)
            if isinstance(value, str):
                value_id = self._get_string_id(value)
                compressed[key_id] = ('str', value_id)
            else:
                compressed[key_id] = ('num', value)
        return compressed

    def retrieve_span(self, index):
        """
        ä»SRTæ£€ç´¢å®Œæ•´span
        """
        compressed = self.spans[index]

        # åå­—å…¸åŒ–
        reverse_dict = {v: k for k, v in self.string_dictionary.items()}

        return {
            'span_id': compressed['span_id'],
            'parent_span_id': compressed['parent_id'],
            'name': reverse_dict[compressed['name_id']],
            'kind': compressed['kind'],
            'start_time': self.base_timestamp + compressed['start_delta'],
            'end_time': self.base_timestamp + compressed['start_delta'] + compressed['duration'],
            'attributes': self._decompress_attributes(compressed['attributes'], reverse_dict),
        }

    def _decompress_attributes(self, compressed_attrs, reverse_dict):
        """
        è§£å‹ç¼©å±æ€§
        """
        attributes = {}
        for key_id, (value_type, value) in compressed_attrs.items():
            key = reverse_dict[key_id]
            if value_type == 'str':
                attributes[key] = reverse_dict[value]
            else:
                attributes[key] = value
        return attributes

    def get_compression_stats(self):
        """
        è·å–å‹ç¼©ç»Ÿè®¡ä¿¡æ¯
        """
        original_size = len(self.spans) * 2000  # å‡è®¾æ¯ä¸ªspan 2KB

        # è®¡ç®—å‹ç¼©åå¤§å°
        dict_size = sum(len(s.encode()) for s in self.string_dictionary.keys())
        spans_size = sum(
            8 +  # span_id
            8 +  # parent_id
            4 +  # name_id
            1 +  # kind
            4 +  # start_delta
            4 +  # duration
            len(s['attributes']) * 8  # å±æ€§
            for s in self.spans
        )
        compressed_size = dict_size + spans_size

        return {
            'original_size': original_size,
            'compressed_size': compressed_size,
            'compression_ratio': (original_size - compressed_size) / original_size,
            'dictionary_size': dict_size,
            'num_strings': len(self.string_dictionary),
        }
```

### 2.3 å‹ç¼©ç®—æ³•

#### æ­¥éª¤1ï¼šå­—å…¸æ„å»º

```python
def build_dictionary(trace):
    """
    ä¸ºæ•´ä¸ªè¿½è¸ªæ„å»ºå­—ç¬¦ä¸²å­—å…¸
    """
    dictionary = {}
    string_freq = {}

    # ç»Ÿè®¡å­—ç¬¦ä¸²é¢‘ç‡
    for span in trace.spans:
        for string in extract_strings(span):
            string_freq[string] = string_freq.get(string, 0) + 1

    # åªå­—å…¸åŒ–é«˜é¢‘å­—ç¬¦ä¸²ï¼ˆå‡ºç°2æ¬¡ä»¥ä¸Šï¼‰
    for string, freq in string_freq.items():
        if freq >= 2:
            dictionary[string] = len(dictionary)

    return dictionary
```

#### æ­¥éª¤2ï¼šSpanå‹ç¼©

```python
def compress_span(span, dictionary, base_timestamp):
    """
    å‹ç¼©å•ä¸ªspan
    """
    compressed = {}

    # 1. å­—å…¸åŒ–å­—ç¬¦ä¸²
    compressed['name_id'] = dictionary.get(span.name, -1)
    if compressed['name_id'] == -1:
        compressed['name'] = span.name  # ä¸åœ¨å­—å…¸ä¸­ï¼Œä¿ç•™åŸå­—ç¬¦ä¸²

    # 2. æ—¶é—´æˆ³å¢é‡ç¼–ç 
    compressed['start_delta'] = span.start_time - base_timestamp
    compressed['duration'] = span.end_time - span.start_time

    # 3. å±æ€§å‹ç¼©
    compressed['attrs'] = {}
    for key, value in span.attributes.items():
        key_id = dictionary.get(key, -1)
        if isinstance(value, str):
            value_id = dictionary.get(value, -1)
            compressed['attrs'][key_id if key_id != -1 else key] = (
                value_id if value_id != -1 else value
            )
        else:
            compressed['attrs'][key_id if key_id != -1 else key] = value

    return compressed
```

### 2.4 æ€§èƒ½åˆ†æ

```text
Tracezipæ€§èƒ½æŒ‡æ ‡ (å®éªŒæ•°æ®):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æŒ‡æ ‡                â”‚ åŸå§‹     â”‚ Tracezip â”‚ æ”¹è¿›    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å­˜å‚¨å¤§å°            â”‚ 100 GB   â”‚  35 GB   â”‚ â†“65%    â”‚
â”‚ ä¼ è¾“å¸¦å®½            â”‚ 500 Mbps â”‚ 175 Mbps â”‚ â†“65%    â”‚
â”‚ æŸ¥è¯¢å»¶è¿Ÿ            â”‚ 120 ms   â”‚ 140 ms   â”‚ â†‘17%    â”‚
â”‚ å‹ç¼©CPUå¼€é”€         â”‚ -        â”‚ 15%      â”‚ æ–°å¢    â”‚
â”‚ è§£å‹ç¼©CPUå¼€é”€       â”‚ -        â”‚ 8%       â”‚ æ–°å¢    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜åŠ¿:
âœ… æ˜¾è‘—å‡å°‘å­˜å‚¨å’Œå¸¦å®½
âœ… è§£å‹ç¼©å¼€é”€å¯æ¥å—

åŠ£åŠ¿:
âŒ æŸ¥è¯¢å»¶è¿Ÿç•¥æœ‰å¢åŠ ï¼ˆéœ€è¦è§£å‹ç¼©ï¼‰
âŒ CPUå¼€é”€å¢åŠ 
```

---

## 3. Autoscopeè¯¦è§£

### 3.1 æ ¸å¿ƒæ€æƒ³

**Autoscope** é€šè¿‡**é™æ€ä»£ç åˆ†æ**æå–æ‰§è¡Œé€»è¾‘ï¼Œå®ç°**spançº§åˆ«çš„æ™ºèƒ½é‡‡æ ·**ï¼Œåœ¨ä¿æŒè¿½è¸ªç»“æ„ä¸€è‡´æ€§çš„åŒæ—¶å¤§å¹…å‡å°‘å­˜å‚¨å¼€é”€ã€‚

#### å…³é”®åˆ›æ–°

```text
ä¼ ç»Ÿé‡‡æ · vs Autoscope:

ä¼ ç»Ÿé‡‡æ ·:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ éšæœºä¸¢å¼ƒæ•´ä¸ªè¿½è¸ªæˆ–span           â”‚
â”‚ âŒ å¯èƒ½ä¸¢å¤±å…³é”®ä¿¡æ¯              â”‚
â”‚ âŒ è¿½è¸ªç»“æ„ä¸å®Œæ•´                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Autoscope:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åŸºäºä»£ç é€»è¾‘æ™ºèƒ½é€‰æ‹©é‡‡æ ·span     â”‚
â”‚ âœ… ä¿ç•™å…³é”®æ‰§è¡Œè·¯å¾„              â”‚
â”‚ âœ… ä¿æŒè¿½è¸ªç»“æ„å®Œæ•´æ€§            â”‚
â”‚ âœ… æ•…éšœè¦†ç›–ç‡é«˜                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 é™æ€åˆ†ææ¡†æ¶

#### é˜¶æ®µ1ï¼šä»£ç è§£æ

```python
class CodeAnalyzer:
    """
    Autoscopeä»£ç åˆ†æå™¨
    """
    def __init__(self):
        self.call_graph = {}  # è°ƒç”¨å›¾
        self.span_importance = {}  # Spané‡è¦æ€§è¯„åˆ†

    def analyze_codebase(self, source_files):
        """
        åˆ†æä»£ç åº“ï¼Œæå–æ‰§è¡Œé€»è¾‘
        """
        for file in source_files:
            ast = parse_source_code(file)
            self._extract_call_graph(ast)
            self._compute_span_importance(ast)

    def _extract_call_graph(self, ast):
        """
        æå–è°ƒç”¨å›¾
        """
        for function in ast.functions:
            callers = []
            callees = []

            # åˆ†æå‡½æ•°è°ƒç”¨å…³ç³»
            for call in function.calls:
                callees.append(call.target)

            self.call_graph[function.name] = {
                'callers': callers,
                'callees': callees,
                'is_error_handler': self._is_error_handler(function),
                'is_critical_path': self._is_critical_path(function),
            }

    def _compute_span_importance(self, ast):
        """
        è®¡ç®—spané‡è¦æ€§è¯„åˆ†
        """
        for function in ast.functions:
            score = 0

            # è§„åˆ™1: é”™è¯¯å¤„ç†å‡½æ•° +10åˆ†
            if self._is_error_handler(function):
                score += 10

            # è§„åˆ™2: å¤–éƒ¨APIè°ƒç”¨ +8åˆ†
            if self._calls_external_api(function):
                score += 8

            # è§„åˆ™3: æ•°æ®åº“æ“ä½œ +7åˆ†
            if self._has_db_operation(function):
                score += 7

            # è§„åˆ™4: å…³é”®ä¸šåŠ¡é€»è¾‘ +6åˆ†
            if self._is_critical_business_logic(function):
                score += 6

            # è§„åˆ™5: é«˜é¢‘è°ƒç”¨ -3åˆ†ï¼ˆå‡å°‘å†—ä½™ï¼‰
            if self._is_high_frequency(function):
                score -= 3

            self.span_importance[function.name] = score

    def _is_error_handler(self, function):
        """
        åˆ¤æ–­æ˜¯å¦ä¸ºé”™è¯¯å¤„ç†å‡½æ•°
        """
        # æ£€æŸ¥try-catchå—ã€é”™è¯¯æ—¥å¿—ã€å¼‚å¸¸æŠ›å‡ºç­‰
        return (
            function.has_try_catch or
            function.logs_error or
            function.throws_exception
        )

    def _calls_external_api(self, function):
        """
        åˆ¤æ–­æ˜¯å¦è°ƒç”¨å¤–éƒ¨API
        """
        for call in function.calls:
            if call.is_http_request or call.is_grpc_call:
                return True
        return False

    def _has_db_operation(self, function):
        """
        åˆ¤æ–­æ˜¯å¦åŒ…å«æ•°æ®åº“æ“ä½œ
        """
        for call in function.calls:
            if call.is_database_query:
                return True
        return False

    def _is_critical_business_logic(self, function):
        """
        åˆ¤æ–­æ˜¯å¦ä¸ºå…³é”®ä¸šåŠ¡é€»è¾‘
        """
        # åŸºäºå‡½æ•°åã€æ³¨è§£ã€é…ç½®ç­‰åˆ¤æ–­
        keywords = ['payment', 'order', 'checkout', 'auth', 'security']
        return any(kw in function.name.lower() for kw in keywords)

    def _is_high_frequency(self, function):
        """
        åˆ¤æ–­æ˜¯å¦ä¸ºé«˜é¢‘è°ƒç”¨å‡½æ•°
        """
        # åŸºäºè°ƒç”¨é¢‘ç‡ç»Ÿè®¡ï¼ˆéœ€è¦è¿è¡Œæ—¶æ•°æ®ï¼‰
        return function.call_count > 1000  # å‡è®¾é˜ˆå€¼
```

#### é˜¶æ®µ2ï¼šé‡‡æ ·ç­–ç•¥ç”Ÿæˆ

```python
class AutoscopeSampler:
    """
    Autoscopeé‡‡æ ·å™¨
    """
    def __init__(self, analyzer, target_reduction=0.8):
        self.analyzer = analyzer
        self.target_reduction = target_reduction  # ç›®æ ‡å‡å°‘80%
        self.sampling_rules = []

    def generate_sampling_strategy(self):
        """
        ç”Ÿæˆé‡‡æ ·ç­–ç•¥
        """
        # æŒ‰é‡è¦æ€§è¯„åˆ†æ’åº
        sorted_spans = sorted(
            self.analyzer.span_importance.items(),
            key=lambda x: x[1],
            reverse=True
        )

        # è®¡ç®—é‡‡æ ·é˜ˆå€¼
        total_spans = len(sorted_spans)
        keep_count = int(total_spans * (1 - self.target_reduction))

        # é€‰æ‹©top-ké‡è¦çš„span
        for i, (span_name, score) in enumerate(sorted_spans):
            if i < keep_count:
                self.sampling_rules.append({
                    'span_name': span_name,
                    'action': 'KEEP',
                    'score': score,
                })
            else:
                # å¯¹äºä¸å¤ªé‡è¦çš„spanï¼Œä½¿ç”¨æ¦‚ç‡é‡‡æ ·
                sample_rate = max(0.01, score / 10.0)  # æœ€ä½1%
                self.sampling_rules.append({
                    'span_name': span_name,
                    'action': 'SAMPLE',
                    'rate': sample_rate,
                    'score': score,
                })

        return self.sampling_rules

    def should_sample_span(self, span_name):
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡‡æ ·æŒ‡å®šspan
        """
        for rule in self.sampling_rules:
            if rule['span_name'] == span_name:
                if rule['action'] == 'KEEP':
                    return True
                else:
                    return random.random() < rule['rate']

        # é»˜è®¤ä½æ¦‚ç‡é‡‡æ ·
        return random.random() < 0.05
```

### 3.3 è¿½è¸ªç»“æ„ä¸€è‡´æ€§ä¿è¯

**æ ¸å¿ƒæŒ‘æˆ˜**ï¼šå¦‚ä½•åœ¨é‡‡æ ·æ—¶ä¿æŒçˆ¶å­å…³ç³»å®Œæ•´ï¼Ÿ

```python
class StructurePreservingSampler:
    """
    ä¿æŒç»“æ„ä¸€è‡´æ€§çš„é‡‡æ ·å™¨
    """
    def __init__(self, autoscope_sampler):
        self.autoscope_sampler = autoscope_sampler
        self.sampled_spans = set()

    def sample_trace(self, trace):
        """
        å¯¹æ•´ä¸ªè¿½è¸ªè¿›è¡Œé‡‡æ ·ï¼Œä¿æŒç»“æ„ä¸€è‡´æ€§
        """
        sampled_trace = Trace(trace_id=trace.trace_id)

        # ç¬¬ä¸€éï¼šæ ‡è®°éœ€è¦ä¿ç•™çš„span
        for span in trace.spans:
            if self.autoscope_sampler.should_sample_span(span.name):
                self.sampled_spans.add(span.span_id)

        # ç¬¬äºŒéï¼šç¡®ä¿çˆ¶spanå­˜åœ¨ï¼ˆå‘ä¸Šä¼ æ’­ï¼‰
        for span in trace.spans:
            if span.span_id in self.sampled_spans:
                self._ensure_ancestors_sampled(span, trace)

        # ç¬¬ä¸‰éï¼šæ„å»ºé‡‡æ ·åçš„è¿½è¸ª
        for span in trace.spans:
            if span.span_id in self.sampled_spans:
                sampled_trace.add_span(span)

        return sampled_trace

    def _ensure_ancestors_sampled(self, span, trace):
        """
        ç¡®ä¿æ‰€æœ‰ç¥–å…ˆspanéƒ½è¢«é‡‡æ ·ï¼ˆä¿æŒç»“æ„å®Œæ•´æ€§ï¼‰
        """
        current = span
        while current.parent_span_id is not None:
            parent = trace.get_span(current.parent_span_id)
            if parent.span_id not in self.sampled_spans:
                # çˆ¶spanæœªè¢«é‡‡æ ·ï¼Œéœ€è¦æ·»åŠ 
                self.sampled_spans.add(parent.span_id)
            current = parent
```

### 3.4 å®éªŒç»“æœ

```text
Autoscopeæ€§èƒ½æŒ‡æ ‡ (è®ºæ–‡å®éªŒæ•°æ®):

æµ‹è¯•ç¯å¢ƒ:
- 2ä¸ªå¼€æºå¾®æœåŠ¡ç³»ç»Ÿ
- TrainTicket (40+ services)
- DeathStarBench (10+ services)

ç»“æœ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æŒ‡æ ‡                 â”‚ åŸå§‹        â”‚ Autoscope   â”‚ æ”¹è¿›    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è¿½è¸ªå¤§å°             â”‚ 100%        â”‚ 18.8%       â”‚ â†“81.2%  â”‚
â”‚ æ•…éšœspanè¦†ç›–ç‡       â”‚ 100%        â”‚ 98.1%       â”‚ â†“1.9%   â”‚
â”‚ æ­£å¸¸spanè¦†ç›–ç‡       â”‚ 100%        â”‚ 15.3%       â”‚ â†“84.7%  â”‚
â”‚ ç»“æ„å®Œæ•´æ€§           â”‚ 100%        â”‚ 100%        â”‚ ä¿æŒ    â”‚
â”‚ CPUå¼€é”€              â”‚ åŸºå‡†        â”‚ +5%         â”‚ æ–°å¢    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…³é”®å‘ç°:
âœ… å¤§å¹…å‡å°‘è¿½è¸ªå¤§å°ï¼ˆ81.2%ï¼‰
âœ… é«˜æ•…éšœè¦†ç›–ç‡ï¼ˆ98.1%ï¼‰
âœ… ä¿æŒè¿½è¸ªç»“æ„å®Œæ•´æ€§
âœ… CPUå¼€é”€å¯æ¥å—ï¼ˆ5%ï¼‰
```

---

## 4. ä¸¤ç§æŠ€æœ¯å¯¹æ¯”

### 4.1 è¯¦ç»†å¯¹æ¯”è¡¨

| ç»´åº¦ | Tracezip | Autoscope | è¯´æ˜ |
|------|---------|-----------|------|
| **å‹ç¼©æ–¹å¼** | æ•°æ®å‹ç¼© | æ™ºèƒ½é‡‡æ · | ä¸åŒçš„æŠ€æœ¯è·¯å¾„ |
| **å‹ç¼©ç‡** | 65% | 81.2% | Autoscopeæ›´é«˜ |
| **æ•…éšœè¦†ç›–** | 100% | 98.1% | Tracezipå®Œæ•´ä¿ç•™ |
| **ç»“æ„å®Œæ•´æ€§** | 100% | 100% | ä¸¤è€…éƒ½ä¿è¯ |
| **CPUå¼€é”€** | 15% (å‹ç¼©) + 8% (è§£å‹) | 5% | Tracezipæ›´é«˜ |
| **æŸ¥è¯¢å»¶è¿Ÿ** | +17% | æ— å½±å“ | Tracezipéœ€è§£å‹ |
| **å®æ–½å¤æ‚åº¦** | ä¸­ | é«˜ | Autoscopeéœ€ä»£ç åˆ†æ |
| **é€‚ç”¨åœºæ™¯** | æ‰€æœ‰åœºæ™¯ | æœ‰æºç è®¿é—® | Autoscopeå—é™ |

### 4.2 æŠ€æœ¯äº’è¡¥æ€§

```text
ç»„åˆä½¿ç”¨ Tracezip + Autoscope:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç¬¬ä¸€æ­¥: Autoscopeé‡‡æ ·              â”‚
â”‚ - å‡å°‘81.2%çš„span                  â”‚
â”‚ - ä¿ç•™å…³é”®æ‰§è¡Œè·¯å¾„                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç¬¬äºŒæ­¥: Tracezipå‹ç¼©               â”‚
â”‚ - å¯¹å‰©ä½™çš„18.8%spanè¿›è¡Œå‹ç¼©        â”‚
â”‚ - å†å‡å°‘65%çš„å­˜å‚¨                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æœ€ç»ˆå‹ç¼©ç‡:
1 - (0.188 Ã— 0.35) = 93.4% âœ…

å³: åŸå§‹100GB â†’ æœ€ç»ˆ6.6GB
æœˆå­˜å‚¨æˆæœ¬: $41,400 â†’ $2,730 (èŠ‚çœ93.4%)
```

---

## 5. ä¸ä¼ ç»Ÿé‡‡æ ·å¯¹æ¯”

### 5.1 ä¼ ç»Ÿé‡‡æ ·æ–¹æ³•å›é¡¾

#### Head-basedé‡‡æ ·

```python
def head_based_sampling(trace, sample_rate=0.01):
    """
    ä¼ ç»Ÿhead-basedé‡‡æ ·
    """
    # ç®€å•ï¼šåŸºäºtrace_idå“ˆå¸Œå†³å®šæ˜¯å¦é‡‡æ ·
    trace_hash = hash(trace.trace_id)
    return (trace_hash % 100) < (sample_rate * 100)
```

**ä¼˜ç‚¹**ï¼š

- âœ… ç®€å•æ˜“å®æ–½
- âœ… ä½CPUå¼€é”€
- âœ… å®æ—¶å†³ç­–

**ç¼ºç‚¹**ï¼š

- âŒ å¯èƒ½ä¸¢å¤±å…³é”®é”™è¯¯è¿½è¸ª
- âŒ é‡‡æ ·åå·®
- âŒ æ— æ³•ä¿è¯è¦†ç›–ç‡

#### Tail-basedé‡‡æ ·

```python
def tail_based_sampling(trace, buffer_time=60):
    """
    ä¼ ç»Ÿtail-basedé‡‡æ ·
    """
    # ç­‰å¾…è¿½è¸ªå®Œæˆ
    wait_until_complete(trace, timeout=buffer_time)

    # åŸºäºè¿½è¸ªå±æ€§å†³ç­–
    if trace.has_error or trace.duration > threshold:
        return True  # ä¿ç•™
    else:
        return random.random() < 0.01  # 1%é‡‡æ ·æ­£å¸¸è¿½è¸ª
```

**ä¼˜ç‚¹**ï¼š

- âœ… å¯ä»¥åŸºäºå®Œæ•´ä¿¡æ¯å†³ç­–
- âœ… ä¿è¯é”™è¯¯è¿½è¸ªè¦†ç›–

**ç¼ºç‚¹**ï¼š

- âŒ é«˜å»¶è¿Ÿï¼ˆéœ€è¦ç¼“å†²ï¼‰
- âŒ é«˜å†…å­˜å ç”¨
- âŒ å®æ—¶æ€§å·®

### 5.2 å…¨é¢å¯¹æ¯”

| æ–¹æ³• | å‹ç¼©ç‡ | æ•…éšœè¦†ç›– | å®æ—¶æ€§ | CPUå¼€é”€ | å†…å­˜ | å®æ–½éš¾åº¦ |
|------|-------|---------|--------|---------|------|---------|
| **Head-based** | 99% | âŒ ä½ | âœ… é«˜ | âœ… ä½ | âœ… ä½ | âœ… æ˜“ |
| **Tail-based** | 90-95% | âœ… é«˜ | âŒ ä½ | âš ï¸ ä¸­ | âŒ é«˜ | âš ï¸ ä¸­ |
| **Tracezip** | 65% | âœ… 100% | âœ… é«˜ | âš ï¸ ä¸­ | âœ… ä½ | âš ï¸ ä¸­ |
| **Autoscope** | 81% | âœ… 98% | âœ… é«˜ | âœ… ä½ | âœ… ä½ | âŒ éš¾ |
| **ç»„åˆ** | 93%+ | âœ… 98% | âœ… é«˜ | âš ï¸ ä¸­ | âœ… ä½ | âŒ éš¾ |

---

## 6. å®éªŒéªŒè¯

### 6.1 Tracezipå®éªŒ

#### 6.1.1 å®éªŒè®¾ç½®

```yaml
ç¯å¢ƒ:
  æ•°æ®é›†: ç”Ÿäº§ç¯å¢ƒè¿½è¸ªæ•°æ®
  è¿½è¸ªæ•°é‡: 1,000,000
  æœåŠ¡æ•°: 50+
  å¹³å‡spanæ•°/è¿½è¸ª: 25

æµ‹è¯•æŒ‡æ ‡:
  - å‹ç¼©ç‡
  - å‹ç¼©/è§£å‹ç¼©æ—¶é—´
  - æŸ¥è¯¢æ€§èƒ½
  - CPU/å†…å­˜å¼€é”€
```

#### 6.1.2 å®éªŒç»“æœ

```python
# Tracezipå®éªŒç»“æœåˆ†æ

results = {
    'compression_ratio': {
        'avg': 0.65,  # å¹³å‡65%å‹ç¼©ç‡
        'min': 0.45,  # æœ€ä½45%ï¼ˆé‡å¤ç‡ä½çš„è¿½è¸ªï¼‰
        'max': 0.82,  # æœ€é«˜82%ï¼ˆé‡å¤ç‡é«˜çš„è¿½è¸ªï¼‰
    },
    'compression_time_ms': {
        'avg': 12,    # å¹³å‡12ms/è¿½è¸ª
        'p99': 35,    # P99: 35ms
    },
    'decompression_time_ms': {
        'avg': 6,     # å¹³å‡6ms/è¿½è¸ª
        'p99': 18,    # P99: 18ms
    },
    'query_latency_increase': 0.17,  # æŸ¥è¯¢å»¶è¿Ÿå¢åŠ 17%
    'cpu_overhead': 0.15,  # CPUå¼€é”€15%
    'memory_overhead': 0.05,  # å†…å­˜å¼€é”€5%
}

# æˆæœ¬èŠ‚çœè®¡ç®—
original_cost_per_month = 41_400  # $41,400/æœˆ
compressed_cost_per_month = original_cost_per_month * (1 - results['compression_ratio']['avg'])
savings_per_month = original_cost_per_month - compressed_cost_per_month

print(f"æœˆåº¦æˆæœ¬èŠ‚çœ: ${savings_per_month:,.0f} ({results['compression_ratio']['avg']*100}%)")
# è¾“å‡º: æœˆåº¦æˆæœ¬èŠ‚çœ: $26,910 (65%)
```

### 6.2 Autoscopeå®éªŒ

#### 6.2.1 å®éªŒè®¾ç½®

```yaml
ç¯å¢ƒ:
  ç³»ç»Ÿ: TrainTicket + DeathStarBench
  æœåŠ¡æ•°: 40+ (TrainTicket), 10+ (DeathStarBench)
  æµ‹è¯•æ—¶é•¿: 7å¤©
  æ³¨å…¥æ•…éšœ: 20ç§å¸¸è§æ•…éšœæ¨¡å¼

æµ‹è¯•æŒ‡æ ‡:
  - è¿½è¸ªå¤§å°å‡å°‘ç‡
  - æ•…éšœè¦†ç›–ç‡
  - ç»“æ„å®Œæ•´æ€§
  - CPUå¼€é”€
```

#### 6.2.2 å®éªŒç»“æœ

```python
# Autoscopeå®éªŒç»“æœ

results = {
    'train_ticket': {
        'trace_size_reduction': 0.812,  # 81.2%
        'fault_coverage': 0.981,         # 98.1%
        'normal_coverage': 0.153,        # 15.3%
        'structural_integrity': 1.0,     # 100%
        'cpu_overhead': 0.05,            # 5%
    },
    'deathstar': {
        'trace_size_reduction': 0.798,  # 79.8%
        'fault_coverage': 0.975,         # 97.5%
        'normal_coverage': 0.168,        # 16.8%
        'structural_integrity': 1.0,     # 100%
        'cpu_overhead': 0.06,            # 6%
    },
}

# æ•…éšœæ£€æµ‹èƒ½åŠ›
fault_types_detected = {
    'crashes': 20/20,          # 100%
    'timeouts': 19/20,         # 95%
    'errors': 19/20,           # 95%
    'performance_issues': 18/20,  # 90%
}

print(f"TrainTicketè¿½è¸ªå¤§å°å‡å°‘: {results['train_ticket']['trace_size_reduction']*100}%")
print(f"æ•…éšœè¦†ç›–ç‡: {results['train_ticket']['fault_coverage']*100}%")
# è¾“å‡º:
# TrainTicketè¿½è¸ªå¤§å°å‡å°‘: 81.2%
# æ•…éšœè¦†ç›–ç‡: 98.1%
```

---

## 7. å®è·µåº”ç”¨

### 7.1 Tracezipå®æ–½æŒ‡å—

#### æ­¥éª¤1ï¼šé›†æˆTracezipåº“

```python
# tracezip_integration.py

from tracezip import SpanRetrievalTree, TracezipExporter

def setup_tracezip_exporter():
    """
    é…ç½®Tracezip exporter
    """
    exporter = TracezipExporter(
        endpoint="http://collector:4317",

        # Tracezipé…ç½®
        compression_enabled=True,
        dictionary_threshold=2,  # å­—ç¬¦ä¸²å‡ºç°2æ¬¡ä»¥ä¸Šæ‰å­—å…¸åŒ–
        delta_encoding=True,     # å¯ç”¨å¢é‡ç¼–ç 

        # æ‰¹å¤„ç†é…ç½®
        batch_size=1000,
        batch_timeout=5,
    )

    return exporter

# OpenTelemetryé…ç½®
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

provider = TracerProvider()
processor = BatchSpanProcessor(setup_tracezip_exporter())
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)
```

#### æ­¥éª¤2ï¼šç›‘æ§å‹ç¼©æ•ˆæœ

```python
# tracezip_monitoring.py

import prometheus_client as prom

# å®šä¹‰ç›‘æ§æŒ‡æ ‡
compression_ratio = prom.Gauge(
    'tracezip_compression_ratio',
    'Tracezip compression ratio'
)

compression_time = prom.Histogram(
    'tracezip_compression_duration_seconds',
    'Tracezip compression duration'
)

decompression_time = prom.Histogram(
    'tracezip_decompression_duration_seconds',
    'Tracezip decompression duration'
)

def monitor_tracezip():
    """
    ç›‘æ§Tracezipæ€§èƒ½
    """
    stats = get_tracezip_stats()

    compression_ratio.set(stats['compression_ratio'])
    compression_time.observe(stats['compression_time'])
    decompression_time.observe(stats['decompression_time'])
```

### 7.2 Autoscopeå®æ–½æŒ‡å—

#### æ­¥éª¤1ï¼šé™æ€ä»£ç åˆ†æ

```bash
# è¿è¡ŒAutoscopeä»£ç åˆ†æå™¨
autoscope analyze \
  --source-dir ./src \
  --output analysis_result.json \
  --target-reduction 0.8
```

#### æ­¥éª¤2ï¼šç”Ÿæˆé‡‡æ ·è§„åˆ™

```python
# autoscope_integration.py

from autoscope import AutoscopeSampler, StructurePreservingSampler

def setup_autoscope_sampler(analysis_result_path):
    """
    é…ç½®Autoscopeé‡‡æ ·å™¨
    """
    # åŠ è½½é™æ€åˆ†æç»“æœ
    with open(analysis_result_path) as f:
        analysis_result = json.load(f)

    # åˆ›å»ºé‡‡æ ·å™¨
    base_sampler = AutoscopeSampler(
        span_importance=analysis_result['span_importance'],
        target_reduction=0.8,
    )

    # åŒ…è£…ç»“æ„ä¿æŒé‡‡æ ·å™¨
    sampler = StructurePreservingSampler(base_sampler)

    return sampler

# é›†æˆåˆ°OpenTelemetry
from opentelemetry.sdk.trace.sampling import Sampler

class AutoscopeSamplerWrapper(Sampler):
    def __init__(self, autoscope_sampler):
        self.autoscope_sampler = autoscope_sampler

    def should_sample(self, parent_context, trace_id, name, kind, attributes, links):
        """
        é‡‡æ ·å†³ç­–
        """
        if self.autoscope_sampler.should_sample_span(name):
            return SamplingResult(Decision.RECORD_AND_SAMPLE)
        else:
            return SamplingResult(Decision.DROP)

sampler = AutoscopeSamplerWrapper(
    setup_autoscope_sampler('analysis_result.json')
)

provider = TracerProvider(sampler=sampler)
```

---

## 8. æœªæ¥å±•æœ›

### 8.1 æŠ€æœ¯æ¼”è¿›æ–¹å‘

#### 1. è‡ªé€‚åº”å‹ç¼©/é‡‡æ ·

```python
class AdaptiveSampler:
    """
    è‡ªé€‚åº”é‡‡æ ·å™¨ï¼šæ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡
    """
    def __init__(self):
        self.current_load = 0
        self.target_reduction = 0.8

    def adjust_sampling_rate(self):
        """
        æ ¹æ®è´Ÿè½½åŠ¨æ€è°ƒæ•´
        """
        if self.current_load > 0.9:  # é«˜è´Ÿè½½
            self.target_reduction = 0.9  # æ›´æ¿€è¿›çš„é‡‡æ ·
        elif self.current_load < 0.5:  # ä½è´Ÿè½½
            self.target_reduction = 0.5  # ä¿ç•™æ›´å¤šæ•°æ®
```

#### 2. æœºå™¨å­¦ä¹ ä¼˜åŒ–

```text
MLé©±åŠ¨çš„é‡‡æ ·ç­–ç•¥:

è¾“å…¥ç‰¹å¾:
- å†å²è¿½è¸ªæ•°æ®
- æœåŠ¡ä¾èµ–å›¾
- æ•…éšœæ¨¡å¼
- ä¸šåŠ¡ä¼˜å…ˆçº§

æ¨¡å‹:
- å¼ºåŒ–å­¦ä¹ ï¼ˆRLï¼‰
- å†³ç­–æ ‘
- ç¥ç»ç½‘ç»œ

è¾“å‡º:
- æ¯ä¸ªspançš„é‡è¦æ€§è¯„åˆ†
- åŠ¨æ€é‡‡æ ·ç‡
```

#### 3. è¾¹ç¼˜è®¡ç®—æ”¯æŒ

```text
è½»é‡çº§Tracezip/Autoscope:

ç›®æ ‡:
- åœ¨è¾¹ç¼˜è®¾å¤‡ä¸Šè¿è¡Œ
- CPUå¼€é”€<2%
- å†…å­˜å ç”¨<10MB

æŠ€æœ¯:
- ç®€åŒ–çš„å­—å…¸ç¼–ç 
- è¿‘ä¼¼ç®—æ³•
- å¢é‡æ›´æ–°
```

### 8.2 æ ‡å‡†åŒ–è¿›ç¨‹

```text
2025-2026å¹´è·¯çº¿å›¾:

2025 Q4:
â”œâ”€ Tracezipçº³å…¥OpenTelemetryå®éªŒæ€§ç‰¹æ€§
â””â”€ Autoscopeå¼€æºå‚è€ƒå®ç°

2026 Q1-Q2:
â”œâ”€ ç¤¾åŒºåé¦ˆå’Œä¼˜åŒ–
â””â”€ å¤šè¯­è¨€SDKæ”¯æŒ

2026 Q3-Q4:
â”œâ”€ æ ‡å‡†åŒ–ææ¡ˆ
â””â”€ ä¸OTLP Arrowé›†æˆ

2027+:
â””â”€ æˆä¸ºOTLPæ ‡å‡†çš„ä¸€éƒ¨åˆ†
```

---

## 9. å‚è€ƒèµ„æº

### 9.1 è®ºæ–‡

1. **Tracezip**: "Tracezip: Efficient Distributed Tracing via Trace Compression"
   - arXiv: <https://arxiv.org/abs/2502.06318>
   - å‘è¡¨æ—¶é—´: 2025å¹´2æœˆ

2. **Autoscope**: "Trace Sampling 2.0: Code Knowledge Enhanced Span-level Sampling for Distributed Tracing"
   - arXiv: <https://arxiv.org/abs/2509.13852>
   - å‘è¡¨æ—¶é—´: 2025å¹´9æœˆ

### 9.2 ç›¸å…³é¡¹ç›®

- OpenTelemetry: <https://opentelemetry.io/>
- Jaeger: <https://www.jaegertracing.io/>
- Zipkin: <https://zipkin.io/>

---

## 10. æ€»ç»“

### 10.1 æ ¸å¿ƒè¦ç‚¹

**Tracezip**:

- âœ… 65%å‹ç¼©ç‡ï¼Œ100%æ•°æ®ä¿ç•™
- âœ… é€‚åˆæ‰€æœ‰åœºæ™¯
- âš ï¸ å¢åŠ CPUå¼€é”€å’ŒæŸ¥è¯¢å»¶è¿Ÿ

**Autoscope**:

- âœ… 81.2%å‹ç¼©ç‡ï¼Œ98.1%æ•…éšœè¦†ç›–
- âœ… ä¿æŒè¿½è¸ªç»“æ„å®Œæ•´æ€§
- âš ï¸ éœ€è¦æºç è®¿é—®ï¼Œå®æ–½å¤æ‚

**ç»„åˆä½¿ç”¨**:

- âœ… 93%+å‹ç¼©ç‡
- âœ… 98%+æ•…éšœè¦†ç›–
- ğŸš€ æœ€ä¼˜æ–¹æ¡ˆ

### 10.2 åº”ç”¨å»ºè®®

**é€‰æ‹©Tracezipï¼Œå¦‚æœ**:

- éœ€è¦100%æ•°æ®ä¿ç•™
- æ²¡æœ‰æºç è®¿é—®æƒé™
- å®æ–½ç®€å•æ€§ä¼˜å…ˆ

**é€‰æ‹©Autoscopeï¼Œå¦‚æœ**:

- æœ‰æºç è®¿é—®
- å¯ä»¥æ¥å—2%æ•…éšœé—æ¼
- è¿½æ±‚æœ€é«˜å‹ç¼©ç‡

**é€‰æ‹©ç»„åˆæ–¹æ¡ˆï¼Œå¦‚æœ**:

- æœ‰å……è¶³çš„å·¥ç¨‹èµ„æº
- è¿½æ±‚æœ€ä¼˜æ€§ä»·æ¯”
- é•¿æœŸæˆæœ¬ä¼˜åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ17æ—¥
**ç»´æŠ¤è€…**: OTLPæ ‡å‡†æ·±åº¦æ¢³ç†é¡¹ç›®å›¢é˜Ÿ

---

**â­ 2025å¹´å‰æ²¿æŠ€æœ¯ï¼Œå€¼å¾—æ·±å…¥ç ”ç©¶å’Œå®è·µï¼**
