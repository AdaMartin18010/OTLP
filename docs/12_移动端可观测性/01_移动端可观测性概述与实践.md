# ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§æ¦‚è¿°ä¸å®è·µ

> **æ ‡å‡†ç‰ˆæœ¬**: v1.27.0
> **çŠ¶æ€**: Stable
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§æ¦‚è¿°ä¸å®è·µ](#ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§æ¦‚è¿°ä¸å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§ç‰¹ç‚¹](#2-ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§ç‰¹ç‚¹)
    - [2.1 æŒ‘æˆ˜](#21-æŒ‘æˆ˜)
    - [2.2 å…³é”®æŒ‡æ ‡](#22-å…³é”®æŒ‡æ ‡)
  - [3. iOSé›†æˆ](#3-iosé›†æˆ)
    - [3.1 SDKå®‰è£…](#31-sdkå®‰è£…)
    - [3.2 åŸºç¡€é…ç½®](#32-åŸºç¡€é…ç½®)
    - [3.3 è‡ªåŠ¨Instrumentation](#33-è‡ªåŠ¨instrumentation)
    - [3.4 æ‰‹åŠ¨Instrumentation](#34-æ‰‹åŠ¨instrumentation)
    - [3.5 iOSç‰¹å®šæŒ‡æ ‡](#35-iosç‰¹å®šæŒ‡æ ‡)
  - [4. Androidé›†æˆ](#4-androidé›†æˆ)
    - [4.1 SDKå®‰è£…](#41-sdkå®‰è£…)
    - [4.2 åŸºç¡€é…ç½®](#42-åŸºç¡€é…ç½®)
    - [4.3 è‡ªåŠ¨Instrumentation](#43-è‡ªåŠ¨instrumentation)
    - [4.4 æ‰‹åŠ¨Instrumentation](#44-æ‰‹åŠ¨instrumentation)
    - [4.5 Androidç‰¹å®šæŒ‡æ ‡](#45-androidç‰¹å®šæŒ‡æ ‡)
  - [5. ç§»åŠ¨ç«¯è¯­ä¹‰çº¦å®š](#5-ç§»åŠ¨ç«¯è¯­ä¹‰çº¦å®š)
    - [5.1 è®¾å¤‡å±æ€§](#51-è®¾å¤‡å±æ€§)
    - [5.2 åº”ç”¨å±æ€§](#52-åº”ç”¨å±æ€§)
    - [5.3 ç½‘ç»œå±æ€§](#53-ç½‘ç»œå±æ€§)
  - [6. æ€§èƒ½ç›‘æ§](#6-æ€§èƒ½ç›‘æ§)
    - [6.1 åº”ç”¨å¯åŠ¨æ—¶é—´](#61-åº”ç”¨å¯åŠ¨æ—¶é—´)
    - [6.2 å±å¹•æ¸²æŸ“æ€§èƒ½](#62-å±å¹•æ¸²æŸ“æ€§èƒ½)
    - [6.3 ç½‘ç»œæ€§èƒ½](#63-ç½‘ç»œæ€§èƒ½)
    - [6.4 å†…å­˜ä¸ç”µæ± ](#64-å†…å­˜ä¸ç”µæ± )
  - [7. å´©æºƒä¸é”™è¯¯è¿½è¸ª](#7-å´©æºƒä¸é”™è¯¯è¿½è¸ª)
    - [7.1 iOSå´©æºƒè¿½è¸ª](#71-ioså´©æºƒè¿½è¸ª)
    - [7.2 Androidå´©æºƒè¿½è¸ª](#72-androidå´©æºƒè¿½è¸ª)
  - [8. ç”¨æˆ·ä½“éªŒç›‘æ§](#8-ç”¨æˆ·ä½“éªŒç›‘æ§)
    - [8.1 ç”¨æˆ·ä¼šè¯è¿½è¸ª](#81-ç”¨æˆ·ä¼šè¯è¿½è¸ª)
    - [8.2 ç”¨æˆ·äº¤äº’è¿½è¸ª](#82-ç”¨æˆ·äº¤äº’è¿½è¸ª)
  - [9. æ•°æ®é‡‡æ ·ä¸ä¼˜åŒ–](#9-æ•°æ®é‡‡æ ·ä¸ä¼˜åŒ–)
    - [9.1 é‡‡æ ·ç­–ç•¥](#91-é‡‡æ ·ç­–ç•¥)
    - [9.2 ç¦»çº¿ç¼“å­˜](#92-ç¦»çº¿ç¼“å­˜)
    - [9.3 ç”µæ± ä¼˜åŒ–](#93-ç”µæ± ä¼˜åŒ–)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 éšç§ä¿æŠ¤](#101-éšç§ä¿æŠ¤)
    - [10.2 æ€§èƒ½å½±å“æœ€å°åŒ–](#102-æ€§èƒ½å½±å“æœ€å°åŒ–)
    - [10.3 æ•°æ®ä¼ è¾“ä¼˜åŒ–](#103-æ•°æ®ä¼ è¾“ä¼˜åŒ–)
  - [11. å®Œæ•´ç¤ºä¾‹](#11-å®Œæ•´ç¤ºä¾‹)
    - [11.1 iOSå®Œæ•´ç¤ºä¾‹](#111-ioså®Œæ•´ç¤ºä¾‹)
    - [11.2 Androidå®Œæ•´ç¤ºä¾‹](#112-androidå®Œæ•´ç¤ºä¾‹)
  - [12. å‚è€ƒèµ„æº](#12-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [SDKæ–‡æ¡£](#sdkæ–‡æ¡£)

---

## 1. æ¦‚è¿°

ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§é¢ä¸´ç‹¬ç‰¹çš„æŒ‘æˆ˜å’Œéœ€æ±‚ï¼ŒåŒ…æ‹¬æœ‰é™çš„èµ„æºã€ä¸ç¨³å®šçš„ç½‘ç»œè¿æ¥ã€ç”¨æˆ·éšç§ä¿æŠ¤ç­‰ã€‚
OpenTelemetryä¸ºiOSå’ŒAndroidæä¾›äº†ä¸“é—¨çš„SDKæ”¯æŒã€‚

**æ ¸å¿ƒç›®æ ‡**ï¼š

```text
âœ… ç›‘æ§åº”ç”¨æ€§èƒ½ï¼ˆå¯åŠ¨æ—¶é—´ã€å“åº”é€Ÿåº¦ï¼‰
âœ… è¿½è¸ªç”¨æˆ·ä½“éªŒï¼ˆå±å¹•å¯¼èˆªã€äº¤äº’å»¶è¿Ÿï¼‰
âœ… æ£€æµ‹å´©æºƒä¸é”™è¯¯
âœ… ä¼˜åŒ–ç½‘ç»œè¯·æ±‚
âœ… æœ€å°åŒ–å¯¹ç”µæ± å’Œæ€§èƒ½çš„å½±å“
```

---

## 2. ç§»åŠ¨ç«¯å¯è§‚æµ‹æ€§ç‰¹ç‚¹

### 2.1 æŒ‘æˆ˜

```text
â— èµ„æºå—é™:      æœ‰é™çš„CPU/å†…å­˜/ç”µæ± 
â— ç½‘ç»œä¸ç¨³å®š:    ç§»åŠ¨ç½‘ç»œæ³¢åŠ¨ã€ç¦»çº¿åœºæ™¯
â— è®¾å¤‡ç¢ç‰‡åŒ–:    å¤šç§è®¾å¤‡å‹å·å’ŒOSç‰ˆæœ¬
â— éšç§ä¿æŠ¤:      GDPR/CCPAç­‰éšç§æ³•è§„
â— åº”ç”¨ç”Ÿå‘½å‘¨æœŸ:  é¢‘ç¹çš„å‰åå°åˆ‡æ¢
```

### 2.2 å…³é”®æŒ‡æ ‡

**æ€§èƒ½æŒ‡æ ‡**ï¼š

```text
- åº”ç”¨å¯åŠ¨æ—¶é—´ï¼ˆå†·å¯åŠ¨/çƒ­å¯åŠ¨ï¼‰
- å±å¹•åŠ è½½æ—¶é—´
- å¸§ç‡ï¼ˆFPSï¼‰
- ç½‘ç»œè¯·æ±‚å»¶è¿Ÿ
- å†…å­˜ä½¿ç”¨é‡
- ç”µæ± æ¶ˆè€—
```

**ç”¨æˆ·ä½“éªŒæŒ‡æ ‡**ï¼š

```text
- ç”¨æˆ·ä¼šè¯æ—¶é•¿
- å±å¹•å¯¼èˆªè·¯å¾„
- äº¤äº’å“åº”æ—¶é—´
- å´©æºƒç‡
- ANRç‡ï¼ˆAndroidï¼‰
- é”™è¯¯ç‡
```

---

## 3. iOSé›†æˆ

### 3.1 SDKå®‰è£…

**CocoaPods**ï¼š

```ruby
# Podfile
platform :ios, '13.0'

target 'YourApp' do
  use_frameworks!

  # OpenTelemetryæ ¸å¿ƒ
  pod 'OpenTelemetryApi', '~> 1.6.0'
  pod 'OpenTelemetrySdk', '~> 1.6.0'

  # OTLP Exporter
  pod 'OpenTelemetryProtocolExporterGrpc', '~> 1.6.0'

  # è‡ªåŠ¨Instrumentation
  pod 'OpenTelemetryInstrumentationURLSession', '~> 1.6.0'
end
```

**Swift Package Manager**ï¼š

```swift
dependencies: [
    .package(
        url: "https://github.com/open-telemetry/opentelemetry-swift",
        from: "1.6.0"
    )
]
```

### 3.2 åŸºç¡€é…ç½®

**Swiftåˆå§‹åŒ–**ï¼š

```swift
import OpenTelemetryApi
import OpenTelemetrySdk
import OpenTelemetryProtocolExporterGrpc

class TelemetryManager {
    static let shared = TelemetryManager()

    private var tracerProvider: TracerProviderSdk!
    private var meterProvider: MeterProviderSdk!

    private init() {
        setupTelemetry()
    }

    private func setupTelemetry() {
        // Resourceé…ç½®
        let resource = Resource(attributes: [
            ResourceAttributes.serviceName: AttributeValue.string("ios-app"),
            ResourceAttributes.serviceVersion: AttributeValue.string("1.0.0"),
            "device.model": AttributeValue.string(UIDevice.current.model),
            "os.type": AttributeValue.string("ios"),
            "os.version": AttributeValue.string(UIDevice.current.systemVersion)
        ])

        // OTLP Exporteré…ç½®
        let otlpConfiguration = OtlpConfiguration(
            timeout: TimeInterval(10),
            headers: [("Authorization", "Bearer your-token")]
        )

        let otlpExporter = OtlpTraceExporter(
            endpoint: "https://your-collector.example.com:4317",
            config: otlpConfiguration
        )

        // TracerProvideré…ç½®
        tracerProvider = TracerProviderBuilder()
            .with(resource: resource)
            .add(spanProcessor: BatchSpanProcessor(
                spanExporter: otlpExporter,
                scheduleDelay: 5.0  // 5ç§’æ‰¹æ¬¡å»¶è¿Ÿ
            ))
            .build()

        OpenTelemetry.registerTracerProvider(tracerProvider: tracerProvider)
    }

    func getTracer() -> Tracer {
        return OpenTelemetry.instance.tracerProvider.get(
            instrumentationName: "ios-app",
            instrumentationVersion: "1.0.0"
        )
    }
}
```

### 3.3 è‡ªåŠ¨Instrumentation

**URLSessionè‡ªåŠ¨è¿½è¸ª**ï¼š

```swift
import OpenTelemetryInstrumentationURLSession

// å¯ç”¨URLSessionè‡ªåŠ¨instrumentation
let urlSessionInstrumentation = URLSessionInstrumentation(configuration:
    URLSessionInstrumentationConfiguration(
        shouldRecordPayload: { request in
            // å†³å®šæ˜¯å¦è®°å½•è¯·æ±‚ä½“
            return true
        },
        shouldInstrument: { request in
            // å†³å®šæ˜¯å¦è¿½è¸ªè¯¥è¯·æ±‚
            return !request.url?.absoluteString.contains("sensitive") ?? true
        },
        createdRequest: { request, span in
            // è‡ªå®šä¹‰Span
            span.setAttribute(key: "custom.attribute", value: "value")
        }
    )
)
```

**ç”Ÿå‘½å‘¨æœŸè‡ªåŠ¨è¿½è¸ª**ï¼š

```swift
import UIKit

class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // åˆå§‹åŒ–é¥æµ‹
        TelemetryManager.shared

        // è¿½è¸ªåº”ç”¨å¯åŠ¨
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "app.launch")
            .setSpanKind(spanKind: .client)
            .startSpan()

        // åº”ç”¨å¯åŠ¨é€»è¾‘...

        span.end()
        return true
    }

    func applicationDidEnterBackground(_ application: UIApplication) {
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "app.enter_background")
            .startSpan()
        span.end()
    }
}
```

### 3.4 æ‰‹åŠ¨Instrumentation

**å±å¹•å¯¼èˆªè¿½è¸ª**ï¼š

```swift
import UIKit
import OpenTelemetryApi

class BaseViewController: UIViewController {
    private var screenSpan: Span?

    override func viewDidLoad() {
        super.viewDidLoad()

        let tracer = TelemetryManager.shared.getTracer()
        screenSpan = tracer.spanBuilder(spanName: "screen.\(screenName)")
            .setSpanKind(spanKind: .client)
            .setAttribute(key: "screen.name", value: screenName)
            .setAttribute(key: "screen.class", value: String(describing: type(of: self)))
            .startSpan()
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        screenSpan?.addEvent(name: "screen.appeared")
    }

    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        screenSpan?.end()
    }

    var screenName: String {
        return String(describing: type(of: self))
    }
}
```

**ç”¨æˆ·æ“ä½œè¿½è¸ª**ï¼š

```swift
@IBAction func buttonTapped(_ sender: UIButton) {
    let tracer = TelemetryManager.shared.getTracer()
    let span = tracer.spanBuilder(spanName: "user.action.button_tap")
        .setSpanKind(spanKind: .client)
        .setAttribute(key: "button.id", value: sender.accessibilityIdentifier ?? "unknown")
        .setAttribute(key: "button.title", value: sender.title(for: .normal) ?? "")
        .startSpan()

    defer {
        span.end()
    }

    // æ‰§è¡ŒæŒ‰é’®æ“ä½œ
    performButtonAction()
}
```

### 3.5 iOSç‰¹å®šæŒ‡æ ‡

**å†…å­˜ç›‘æ§**ï¼š

```swift
import Foundation

func collectMemoryMetrics() {
    var info = mach_task_basic_info()
    var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4

    let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
        $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
            task_info(mach_task_self_,
                     task_flavor_t(MACH_TASK_BASIC_INFO),
                     $0,
                     &count)
        }
    }

    if kerr == KERN_SUCCESS {
        let usedMemory = Double(info.resident_size) / 1024.0 / 1024.0

        // è®°å½•å†…å­˜æŒ‡æ ‡
        let meter = OpenTelemetry.instance.meterProvider.get(instrumentationName: "ios-app")
        let memoryGauge = meter.createDoubleObservableGauge(name: "app.memory.used_mb")
        memoryGauge.observe(value: usedMemory, attributes: [:])
    }
}
```

---

## 4. Androidé›†æˆ

### 4.1 SDKå®‰è£…

**Gradleé…ç½®**ï¼š

```gradle
// build.gradle (Project level)
buildscript {
    ext {
        opentelemetry_version = '1.32.0'
        opentelemetry_alpha_version = '1.32.0-alpha'
    }
}

// build.gradle (App level)
dependencies {
    // OpenTelemetryæ ¸å¿ƒ
    implementation "io.opentelemetry:opentelemetry-api:${opentelemetry_version}"
    implementation "io.opentelemetry:opentelemetry-sdk:${opentelemetry_version}"

    // OTLP Exporter
    implementation "io.opentelemetry:opentelemetry-exporter-otlp:${opentelemetry_version}"

    // Android Instrumentation
    implementation "io.opentelemetry.android:instrumentation:${opentelemetry_alpha_version}"
    implementation "io.opentelemetry.android:instrumentation-okhttp:${opentelemetry_alpha_version}"
}
```

### 4.2 åŸºç¡€é…ç½®

**Kotlinåˆå§‹åŒ–**ï¼š

```kotlin
package com.example.app

import android.app.Application
import io.opentelemetry.api.OpenTelemetry
import io.opentelemetry.api.common.Attributes
import io.opentelemetry.api.trace.Tracer
import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter
import io.opentelemetry.sdk.OpenTelemetrySdk
import io.opentelemetry.sdk.resources.Resource
import io.opentelemetry.sdk.trace.SdkTracerProvider
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor
import io.opentelemetry.semconv.resource.attributes.ResourceAttributes

class MyApplication : Application() {
    companion object {
        private lateinit var openTelemetry: OpenTelemetry

        fun getTracer(): Tracer {
            return openTelemetry.getTracer("android-app", "1.0.0")
        }
    }

    override fun onCreate() {
        super.onCreate()
        setupOpenTelemetry()
    }

    private fun setupOpenTelemetry() {
        // Resourceé…ç½®
        val resource = Resource.getDefault().toBuilder()
            .put(ResourceAttributes.SERVICE_NAME, "android-app")
            .put(ResourceAttributes.SERVICE_VERSION, "1.0.0")
            .put("device.model", android.os.Build.MODEL)
            .put("os.type", "android")
            .put("os.version", android.os.Build.VERSION.RELEASE)
            .build()

        // OTLP Exporteré…ç½®
        val otlpExporter = OtlpGrpcSpanExporter.builder()
            .setEndpoint("https://your-collector.example.com:4317")
            .addHeader("Authorization", "Bearer your-token")
            .setTimeout(10, java.util.concurrent.TimeUnit.SECONDS)
            .build()

        // TracerProvideré…ç½®
        val tracerProvider = SdkTracerProvider.builder()
            .setResource(resource)
            .addSpanProcessor(
                BatchSpanProcessor.builder(otlpExporter)
                    .setScheduleDelay(5, java.util.concurrent.TimeUnit.SECONDS)
                    .build()
            )
            .build()

        // OpenTelemetry SDKåˆå§‹åŒ–
        openTelemetry = OpenTelemetrySdk.builder()
            .setTracerProvider(tracerProvider)
            .buildAndRegisterGlobal()
    }
}
```

### 4.3 è‡ªåŠ¨Instrumentation

**OkHttpè‡ªåŠ¨è¿½è¸ª**ï¼š

```kotlin
import io.opentelemetry.instrumentation.okhttp.v3_0.OkHttpTelemetry
import okhttp3.OkHttpClient

// åˆ›å»ºå¸¦instrumentationçš„OkHttpClient
val okHttpTelemetry = OkHttpTelemetry.builder(openTelemetry)
    .setCapturedRequestHeaders(listOf("User-Agent", "Content-Type"))
    .setCapturedResponseHeaders(listOf("Content-Type"))
    .build()

val client = OkHttpClient.Builder()
    .addInterceptor(okHttpTelemetry.newInterceptor())
    .build()
```

**Activityç”Ÿå‘½å‘¨æœŸè¿½è¸ª**ï¼š

```kotlin
import android.app.Activity
import android.app.Application
import android.os.Bundle
import io.opentelemetry.api.trace.Span
import io.opentelemetry.api.trace.SpanKind

class ActivityLifecycleTracker : Application.ActivityLifecycleCallbacks {
    private val spanMap = mutableMapOf<Activity, Span>()

    override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
        val tracer = MyApplication.getTracer()
        val span = tracer.spanBuilder("screen.${activity.localClassName}")
            .setSpanKind(SpanKind.CLIENT)
            .setAttribute("screen.name", activity.localClassName)
            .setAttribute("screen.class", activity::class.java.name)
            .startSpan()

        spanMap[activity] = span
    }

    override fun onActivityStarted(activity: Activity) {
        spanMap[activity]?.addEvent("screen.started")
    }

    override fun onActivityResumed(activity: Activity) {
        spanMap[activity]?.addEvent("screen.resumed")
    }

    override fun onActivityPaused(activity: Activity) {
        spanMap[activity]?.addEvent("screen.paused")
    }

    override fun onActivityDestroyed(activity: Activity) {
        spanMap[activity]?.end()
        spanMap.remove(activity)
    }

    // å…¶ä»–ç”Ÿå‘½å‘¨æœŸå›è°ƒ...
    override fun onActivityStopped(activity: Activity) {}
    override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}
}

// åœ¨Applicationä¸­æ³¨å†Œ
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        registerActivityLifecycleCallbacks(ActivityLifecycleTracker())
    }
}
```

### 4.4 æ‰‹åŠ¨Instrumentation

**ç½‘ç»œè¯·æ±‚è¿½è¸ª**ï¼š

```kotlin
import io.opentelemetry.api.trace.SpanKind
import io.opentelemetry.api.trace.StatusCode
import io.opentelemetry.semconv.trace.attributes.SemanticAttributes

suspend fun fetchData(url: String): Result<String> {
    val tracer = MyApplication.getTracer()
    val span = tracer.spanBuilder("http.request")
        .setSpanKind(SpanKind.CLIENT)
        .setAttribute(SemanticAttributes.HTTP_METHOD, "GET")
        .setAttribute(SemanticAttributes.HTTP_URL, url)
        .startSpan()

    return try {
        val result = performHttpRequest(url)

        span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, 200)
        span.setStatus(StatusCode.OK)

        Result.success(result)
    } catch (e: Exception) {
        span.recordException(e)
        span.setStatus(StatusCode.ERROR, e.message ?: "Unknown error")

        Result.failure(e)
    } finally {
        span.end()
    }
}
```

### 4.5 Androidç‰¹å®šæŒ‡æ ‡

**å†…å­˜ä¸CPUç›‘æ§**ï¼š

```kotlin
import android.app.ActivityManager
import android.content.Context
import android.os.Debug

class SystemMetricsCollector(private val context: Context) {
    private val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager

    fun collectMemoryMetrics() {
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)

        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024.0 / 1024.0

        // è®°å½•æŒ‡æ ‡
        val meter = OpenTelemetry.getGlobalMeterProvider().get("android-app")
        val memoryGauge = meter.gaugeBuilder("app.memory.used_mb")
            .build()

        memoryGauge.record(usedMemory)
    }

    fun collectCpuMetrics() {
        val cpuUsage = Debug.threadCpuTimeNanos() / 1000000.0

        val meter = OpenTelemetry.getGlobalMeterProvider().get("android-app")
        val cpuGauge = meter.gaugeBuilder("app.cpu.usage_ms")
            .build()

        cpuGauge.record(cpuUsage)
    }
}
```

---

## 5. ç§»åŠ¨ç«¯è¯­ä¹‰çº¦å®š

### 5.1 è®¾å¤‡å±æ€§

```text
device.manufacturer:    è®¾å¤‡åˆ¶é€ å•† (Apple/Samsung/Google)
device.model:           è®¾å¤‡å‹å· (iPhone 14/Pixel 7)
device.id:              è®¾å¤‡å”¯ä¸€æ ‡è¯† (åŒ¿ååŒ–)
```

### 5.2 åº”ç”¨å±æ€§

```text
app.version:            åº”ç”¨ç‰ˆæœ¬ (1.0.0)
app.build:              æ„å»ºå· (100)
app.session.id:         ä¼šè¯ID (UUID)
app.state:              åº”ç”¨çŠ¶æ€ (foreground/background)
```

### 5.3 ç½‘ç»œå±æ€§

```text
network.type:           ç½‘ç»œç±»å‹ (wifi/cellular/unknown)
network.generation:     ç½‘ç»œä¸–ä»£ (4G/5G)
network.carrier:        è¿è¥å•†
```

---

## 6. æ€§èƒ½ç›‘æ§

### 6.1 åº”ç”¨å¯åŠ¨æ—¶é—´

**iOSå¯åŠ¨æ—¶é—´è¿½è¸ª**ï¼š

```swift
// AppDelegate.swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
) -> Bool {
    let startTime = ProcessInfo.processInfo.systemUptime

    let tracer = TelemetryManager.shared.getTracer()
    let span = tracer.spanBuilder(spanName: "app.cold_start")
        .setStartTime(time: Date(timeIntervalSinceNow: -startTime))
        .setAttribute(key: "start.type", value: "cold")
        .startSpan()

    // åˆå§‹åŒ–é€»è¾‘...

    span.end()
    return true
}
```

### 6.2 å±å¹•æ¸²æŸ“æ€§èƒ½

**iOSå¸§ç‡ç›‘æ§**ï¼š

```swift
import QuartzCore

class FrameRateMonitor {
    private var displayLink: CADisplayLink?
    private var lastTimestamp: CFTimeInterval = 0
    private var fps: Double = 0

    func startMonitoring() {
        displayLink = CADisplayLink(target: self, selector: #selector(update))
        displayLink?.add(to: .main, forMode: .common)
    }

    @objc private func update(displayLink: CADisplayLink) {
        if lastTimestamp == 0 {
            lastTimestamp = displayLink.timestamp
            return
        }

        let delta = displayLink.timestamp - lastTimestamp
        fps = 1.0 / delta
        lastTimestamp = displayLink.timestamp

        // è®°å½•FPSæŒ‡æ ‡
        let meter = OpenTelemetry.instance.meterProvider.get(instrumentationName: "ios-app")
        let fpsGauge = meter.createDoubleObservableGauge(name: "app.fps")
        fpsGauge.observe(value: fps, attributes: [:])
    }
}
```

### 6.3 ç½‘ç»œæ€§èƒ½

**ç½‘ç»œå»¶è¿Ÿè¿½è¸ª**ï¼ˆå·²åœ¨ä¸Šæ–‡OkHttp/URLSessionè‡ªåŠ¨instrumentationä¸­å®ç°ï¼‰

### 6.4 å†…å­˜ä¸ç”µæ± 

**ç”µæ± çŠ¶æ€ç›‘æ§**ï¼ˆiOSï¼‰ï¼š

```swift
import UIKit

func monitorBatteryStatus() {
    UIDevice.current.isBatteryMonitoringEnabled = true

    NotificationCenter.default.addObserver(
        forName: UIDevice.batteryLevelDidChangeNotification,
        object: nil,
        queue: .main
    ) { _ in
        let level = UIDevice.current.batteryLevel
        let state = UIDevice.current.batteryState

        // è®°å½•ç”µæ± æŒ‡æ ‡
        let meter = OpenTelemetry.instance.meterProvider.get(instrumentationName: "ios-app")
        let batteryGauge = meter.createDoubleObservableGauge(name: "device.battery.level")
        batteryGauge.observe(value: Double(level), attributes: [
            "battery.state": AttributeValue.string(state.description)
        ])
    }
}
```

---

## 7. å´©æºƒä¸é”™è¯¯è¿½è¸ª

### 7.1 iOSå´©æºƒè¿½è¸ª

```swift
import Foundation

class CrashHandler {
    static func setup() {
        NSSetUncaughtExceptionHandler { exception in
            let tracer = TelemetryManager.shared.getTracer()
            let span = tracer.spanBuilder(spanName: "app.crash")
                .setSpanKind(spanKind: .internal)
                .setAttribute(key: "exception.type", value: exception.name.rawValue)
                .setAttribute(key: "exception.message", value: exception.reason ?? "")
                .setAttribute(key: "exception.stacktrace",
                            value: exception.callStackSymbols.joined(separator: "\n"))
                .startSpan()

            span.setStatus(status: .error(description: "Application crashed"))
            span.end()

            // å¼ºåˆ¶åˆ·æ–°é¥æµ‹æ•°æ®
            TelemetryManager.shared.flush()
        }
    }
}
```

### 7.2 Androidå´©æºƒè¿½è¸ª

```kotlin
class CrashHandler : Thread.UncaughtExceptionHandler {
    private val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()

    override fun uncaughtException(thread: Thread, throwable: Throwable) {
        val tracer = MyApplication.getTracer()
        val span = tracer.spanBuilder("app.crash")
            .setSpanKind(SpanKind.INTERNAL)
            .setAttribute("exception.type", throwable::class.java.name)
            .setAttribute("exception.message", throwable.message ?: "")
            .setAttribute("exception.stacktrace", throwable.stackTraceToString())
            .setAttribute("thread.name", thread.name)
            .startSpan()

        span.setStatus(StatusCode.ERROR, "Application crashed")
        span.end()

        // é»˜è®¤å¤„ç†
        defaultHandler?.uncaughtException(thread, throwable)
    }
}

// åœ¨Applicationä¸­è®¾ç½®
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        Thread.setDefaultUncaughtExceptionHandler(CrashHandler())
    }
}
```

---

## 8. ç”¨æˆ·ä½“éªŒç›‘æ§

### 8.1 ç”¨æˆ·ä¼šè¯è¿½è¸ª

**iOSä¼šè¯ç®¡ç†**ï¼š

```swift
class SessionManager {
    static let shared = SessionManager()
    private var sessionId: String?
    private var sessionStartTime: Date?

    func startSession() {
        sessionId = UUID().uuidString
        sessionStartTime = Date()

        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "user.session")
            .setAttribute(key: "session.id", value: sessionId!)
            .startSpan()

        // Session spanä¿æŒæ´»è·ƒç›´åˆ°åº”ç”¨å…³é—­
    }

    func getCurrentSessionId() -> String? {
        return sessionId
    }
}
```

### 8.2 ç”¨æˆ·äº¤äº’è¿½è¸ª

**Androidç‚¹å‡»äº‹ä»¶è¿½è¸ª**ï¼š

```kotlin
import android.view.View

fun trackButtonClick(view: View, actionName: String) {
    val tracer = MyApplication.getTracer()
    val span = tracer.spanBuilder("user.interaction.$actionName")
        .setSpanKind(SpanKind.CLIENT)
        .setAttribute("ui.element.id", view.id.toString())
        .setAttribute("ui.element.type", "button")
        .setAttribute("session.id", SessionManager.getSessionId())
        .startSpan()

    span.end()
}
```

---

## 9. æ•°æ®é‡‡æ ·ä¸ä¼˜åŒ–

### 9.1 é‡‡æ ·ç­–ç•¥

**åŸºäºç”µæ± ä¸ç½‘ç»œçš„åŠ¨æ€é‡‡æ ·**ï¼š

```kotlin
class AdaptiveSampler : Sampler {
    override fun shouldSample(
        parentContext: Context,
        traceId: String,
        name: String,
        spanKind: SpanKind,
        attributes: Attributes,
        parentLinks: List<LinkData>
    ): SamplingResult {
        val batteryLevel = getBatteryLevel()
        val networkType = getNetworkType()

        // ä½ç”µé‡æ—¶é™ä½é‡‡æ ·ç‡
        val samplingProbability = when {
            batteryLevel < 20 -> 0.1  // 10%
            batteryLevel < 50 -> 0.5  // 50%
            networkType == "wifi" -> 1.0  // 100%
            networkType == "cellular" -> 0.7  // 70%
            else -> 0.5
        }

        return if (Math.random() < samplingProbability) {
            SamplingResult.recordAndSample()
        } else {
            SamplingResult.drop()
        }
    }
}
```

### 9.2 ç¦»çº¿ç¼“å­˜

**ç¦»çº¿æ•°æ®æŒä¹…åŒ–**ï¼š

```swift
class OfflineCache {
    private let fileManager = FileManager.default
    private let cacheDirectory: URL

    init() {
        cacheDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask)[0]
            .appendingPathComponent("telemetry")

        try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
    }

    func saveSpan(_ span: SpanData) {
        // å°†spanæ•°æ®åºåˆ—åŒ–å¹¶ä¿å­˜åˆ°æœ¬åœ°
        let encoder = JSONEncoder()
        if let data = try? encoder.encode(span) {
            let filename = UUID().uuidString + ".span"
            let fileURL = cacheDirectory.appendingPathComponent(filename)
            try? data.write(to: fileURL)
        }
    }

    func flushWhenOnline() {
        guard isNetworkAvailable() else { return }

        // è¯»å–å¹¶å‘é€æ‰€æœ‰ç¼“å­˜çš„span
        let files = try? fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: nil)
        files?.forEach { fileURL in
            if let data = try? Data(contentsOf: fileURL),
               let span = try? JSONDecoder().decode(SpanData.self, from: data) {
                // å‘é€span
                sendSpan(span)
                // åˆ é™¤æ–‡ä»¶
                try? fileManager.removeItem(at: fileURL)
            }
        }
    }
}
```

### 9.3 ç”µæ± ä¼˜åŒ–

**æœ€ä½³å®è·µ**ï¼š

```text
âœ… ä½¿ç”¨æ‰¹å¤„ç†å‡å°‘ç½‘ç»œè¯·æ±‚
âœ… åœ¨WiFiä¸‹ä¼˜å…ˆå‘é€æ•°æ®
âœ… ä½ç”µé‡æ—¶é™ä½é‡‡æ ·ç‡
âœ… åˆå¹¶å¤šä¸ªå°è¯·æ±‚ä¸ºä¸€ä¸ªå¤§è¯·æ±‚
âœ… ä½¿ç”¨åå°ä»»åŠ¡å‘é€æ•°æ®
âœ… é¿å…é¢‘ç¹å”¤é†’è®¾å¤‡
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 éšç§ä¿æŠ¤

**æ•°æ®è„±æ•**ï¼š

```swift
// è„±æ•ç”¨æˆ·ä¿¡æ¯
func sanitizeUserData(_ userId: String) -> String {
    // ä½¿ç”¨SHA256å“ˆå¸Œ
    let data = userId.data(using: .utf8)!
    let hash = SHA256.hash(data: data)
    return hash.compactMap { String(format: "%02x", $0) }.joined()
}

// è®¾ç½®spanå±æ€§æ—¶ä½¿ç”¨è„±æ•
span.setAttribute(key: "user.id", value: sanitizeUserData(actualUserId))
```

### 10.2 æ€§èƒ½å½±å“æœ€å°åŒ–

**å¼‚æ­¥å¤„ç†**ï¼š

```kotlin
// å¼‚æ­¥å‘é€é¥æµ‹æ•°æ®
CoroutineScope(Dispatchers.IO).launch {
    try {
        sendTelemetryData(span)
    } catch (e: Exception) {
        // é™é»˜å¤±è´¥ï¼Œä¸å½±å“ä¸»æµç¨‹
        Log.e("Telemetry", "Failed to send data", e)
    }
}
```

### 10.3 æ•°æ®ä¼ è¾“ä¼˜åŒ–

**å‹ç¼©é…ç½®**ï¼š

```yaml
# Collectoré…ç½®
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
        # å¯ç”¨å‹ç¼©
        max_recv_msg_size_mib: 4

exporters:
  otlp:
    endpoint: backend:4317
    compression: gzip  # ä½¿ç”¨gzipå‹ç¼©
```

---

## 11. å®Œæ•´ç¤ºä¾‹

### 11.1 iOSå®Œæ•´ç¤ºä¾‹

```swift
// AppDelegate.swift
import UIKit
import OpenTelemetryApi
import OpenTelemetrySdk

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // åˆå§‹åŒ–OpenTelemetry
        TelemetryManager.shared

        // è®¾ç½®å´©æºƒå¤„ç†
        CrashHandler.setup()

        // å¼€å§‹ä¼šè¯
        SessionManager.shared.startSession()

        // ç›‘æ§å¸§ç‡
        FrameRateMonitor().startMonitoring()

        // è¿½è¸ªå¯åŠ¨æ—¶é—´
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "app.launch")
            .setAttribute(key: "launch.type", value: "cold")
            .startSpan()

        // åº”ç”¨åˆå§‹åŒ–é€»è¾‘...

        span.end()
        return true
    }
}

// ViewController.swift
class ProductListViewController: BaseViewController {
    override var screenName: String {
        return "product_list"
    }

    @IBAction func productTapped(_ sender: UIButton) {
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "user.action.product_tap")
            .setAttribute(key: "product.id", value: sender.tag)
            .setAttribute(key: "session.id", value: SessionManager.shared.getCurrentSessionId() ?? "")
            .startSpan()

        // åŠ è½½äº§å“è¯¦æƒ…
        loadProductDetail(productId: sender.tag)

        span.end()
    }

    private func loadProductDetail(productId: Int) {
        let tracer = TelemetryManager.shared.getTracer()
        let span = tracer.spanBuilder(spanName: "api.product.detail")
            .setSpanKind(spanKind: .client)
            .setAttribute(key: "product.id", value: productId)
            .startSpan()

        let url = URL(string: "https://api.example.com/products/\(productId)")!

        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error {
                span.recordException(exception: error)
                span.setStatus(status: .error(description: error.localizedDescription))
            } else if let httpResponse = response as? HTTPURLResponse {
                span.setAttribute(key: "http.status_code", value: httpResponse.statusCode)
                span.setStatus(status: .ok)
            }

            span.end()
        }.resume()
    }
}
```

### 11.2 Androidå®Œæ•´ç¤ºä¾‹

```kotlin
// MyApplication.kt
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()

        // åˆå§‹åŒ–OpenTelemetry
        setupOpenTelemetry()

        // è®¾ç½®å´©æºƒå¤„ç†
        Thread.setDefaultUncaughtExceptionHandler(CrashHandler())

        // æ³¨å†ŒActivityç”Ÿå‘½å‘¨æœŸå›è°ƒ
        registerActivityLifecycleCallbacks(ActivityLifecycleTracker())

        // å¼€å§‹ä¼šè¯
        SessionManager.startSession()

        // å®šæœŸæ”¶é›†ç³»ç»ŸæŒ‡æ ‡
        scheduleMetricsCollection()
    }

    private fun scheduleMetricsCollection() {
        val executor = Executors.newScheduledThreadPool(1)
        val metricsCollector = SystemMetricsCollector(this)

        executor.scheduleAtFixedRate({
            metricsCollector.collectMemoryMetrics()
            metricsCollector.collectCpuMetrics()
        }, 0, 30, TimeUnit.SECONDS)
    }
}

// ProductListActivity.kt
class ProductListActivity : AppCompatActivity() {
    private lateinit var tracer: Tracer

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_product_list)

        tracer = MyApplication.getTracer()

        // è®¾ç½®ç‚¹å‡»ç›‘å¬
        productButton.setOnClickListener { view ->
            trackButtonClick(view, "product_tap")
            loadProductDetail(productId = 123)
        }
    }

    private fun loadProductDetail(productId: Int) {
        val span = tracer.spanBuilder("api.product.detail")
            .setSpanKind(SpanKind.CLIENT)
            .setAttribute("product.id", productId.toLong())
            .setAttribute("session.id", SessionManager.getSessionId())
            .startSpan()

        lifecycleScope.launch {
            try {
                val response = apiService.getProductDetail(productId)

                span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, 200)
                span.setStatus(StatusCode.OK)

                // æ›´æ–°UI
                updateUI(response)
            } catch (e: Exception) {
                span.recordException(e)
                span.setStatus(StatusCode.ERROR, e.message ?: "Unknown error")

                // æ˜¾ç¤ºé”™è¯¯
                showError(e.message)
            } finally {
                span.end()
            }
        }
    }
}
```

---

## 12. å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- **OpenTelemetry Swift**: <https://github.com/open-telemetry/opentelemetry-swift>
- **OpenTelemetry Android**: <https://github.com/open-telemetry/opentelemetry-android>
- **Mobile Semantic Conventions**: <https://opentelemetry.io/docs/specs/semconv/mobile/>

### SDKæ–‡æ¡£

- **Swift API**: <https://opentelemetry.io/docs/instrumentation/swift/>
- **Android API**: <https://opentelemetry.io/docs/instrumentation/android/>
- **Mobile Best Practices**: <https://opentelemetry.io/docs/instrumentation/mobile/best-practices/>

---

**æ–‡æ¡£ç»´æŠ¤**: OTLPæ·±åº¦æ¢³ç†é¡¹ç›®ç»„
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**è´¨é‡ç­‰çº§**: â­â­â­â­â­
