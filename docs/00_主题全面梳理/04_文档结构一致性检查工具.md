# 🔍 文档结构一致性检查工具

> **文档版本**: v1.0
> **创建日期**: 2025年12月
> **文档类型**: 工具文档
> **预估篇幅**: 1,500+ 行
> **目标**: 确保所有文档结构一致、编号连续、内容完整

---

## 📋 目录

- [🔍 文档结构一致性检查工具](#-文档结构一致性检查工具)
  - [📋 目录](#-目录)
  - [第一部分: 检查规则定义](#第一部分-检查规则定义)
    - [1.1 目录结构规则](#11-目录结构规则)
      - [目录规则](#目录规则)
      - [目录模板](#目录模板)
    - [1.2 标题编号规则](#12-标题编号规则)
      - [编号规则](#编号规则)
      - [编号验证](#编号验证)
    - [1.3 内容完整性规则](#13-内容完整性规则)
      - [完整性规则](#完整性规则)
  - [第二部分: 检查算法实现](#第二部分-检查算法实现)
    - [2.1 目录检查算法](#21-目录检查算法)
      - [目录解析](#目录解析)
    - [2.2 编号检查算法](#22-编号检查算法)
      - [编号验证](#编号验证-1)
    - [2.3 内容检查算法](#23-内容检查算法)
      - [内容验证](#内容验证)
  - [第三部分: 自动化检查工具](#第三部分-自动化检查工具)
    - [3.1 Python检查脚本](#31-python检查脚本)
      - [完整检查脚本](#完整检查脚本)
    - [3.2 检查报告生成](#32-检查报告生成)
      - [报告格式](#报告格式)
    - [3.3 自动修复建议](#33-自动修复建议)
      - [修复建议生成](#修复建议生成)
  - [第四部分: 检查清单](#第四部分-检查清单)
    - [4.1 结构检查清单](#41-结构检查清单)
      - [检查项](#检查项)
    - [4.2 内容检查清单](#42-内容检查清单)
      - [检查项](#检查项-1)
    - [4.3 质量检查清单](#43-质量检查清单)
      - [检查项](#检查项-2)
  - [第五部分: 常见问题与修复](#第五部分-常见问题与修复)
    - [5.1 目录缺失](#51-目录缺失)
      - [问题描述](#问题描述)
      - [修复示例](#修复示例)
    - [5.2 编号不连续](#52-编号不连续)
      - [问题描述](#问题描述-1)
      - [修复示例](#修复示例-1)
    - [5.3 内容缺失](#53-内容缺失)
      - [问题描述](#问题描述-2)
    - [5.4 结构不一致](#54-结构不一致)
      - [问题描述](#问题描述-3)
  - [总结](#总结)
    - [核心要点](#核心要点)
    - [使用价值](#使用价值)

---

## 第一部分: 检查规则定义

### 1.1 目录结构规则

#### 目录规则

```text
目录结构规则:
  1. 必须有目录
     ├─ 使用 ## 📋 目录
     ├─ 包含所有主要章节
     └─ 链接正确有效

  2. 目录格式
     ├─ 使用Markdown链接格式
     ├─ 层级正确 (最多4级)
     └─ 编号连续

  3. 目录完整性
     ├─ 所有 ## 章节必须包含
     ├─ 所有 ### 子章节建议包含
     └─ 重要 #### 小节可选包含
```

#### 目录模板

```markdown
## 📋 目录

- [文档标题](#文档标题)
  - [📋 目录](#-目录)
  - [第一部分: XXX](#第一部分-xxx)
    - [1.1 XXX](#11-xxx)
      - [子标题](#子标题)
    - [1.2 XXX](#12-xxx)
  - [第二部分: XXX](#第二部分-xxx)
    ...
  - [总结](#总结)
```

### 1.2 标题编号规则

#### 编号规则

```text
标题编号规则:
  1. 层级编号
     ├─ ## 第一部分/第二部分/... (中文数字)
     ├─ ### 1.1 / 1.2 / ... (数字编号)
     └─ #### 子标题 (可选编号)

  2. 编号连续性
     ├─ 第一部分 → 第二部分 → ... → 第十部分
     ├─ 1.1 → 1.2 → 1.3 → ...
     └─ 不允许跳号 (如 1.1 → 1.3)

  3. 编号格式
     ├─ 第一部分/第二部分 (中文)
     ├─ 1.1 / 1.2 (数字+点)
     └─ 保持一致
```

#### 编号验证

```python
# 标题编号验证
def validate_numbering(headers: list) -> list:
    """验证标题编号连续性"""
    errors = []

    # 检查第一部分到第十部分
    parts = [h for h in headers if h.level == 2 and '部分' in h.text]
    expected_parts = [f'第{i}部分' for i in ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十']]

    for i, part in enumerate(parts):
        if part.text != expected_parts[i]:
            errors.append(f"第{i+1}部分编号错误: 期望 {expected_parts[i]}, 实际 {part.text}")

    # 检查子章节编号
    for part in parts:
        subsections = [h for h in headers if h.parent == part and h.level == 3]
        for i, sub in enumerate(subsections, 1):
            expected = f"{part.number}.{i}"
            if sub.number != expected:
                errors.append(f"子章节编号错误: 期望 {expected}, 实际 {sub.number}")

    return errors
```

### 1.3 内容完整性规则

#### 完整性规则

```text
内容完整性规则:
  1. 章节内容
     ├─ 每个章节必须有内容
     ├─ 不能只有标题
     └─ 至少3-5行说明

  2. 代码示例
     ├─ 代码块有语言标识
     ├─ 代码可运行 (如可能)
     └─ 代码有注释

  3. 图表完整性
     ├─ Mermaid图表语法正确
     ├─ 图表有说明
     └─ 图表链接有效
```

---

## 第二部分: 检查算法实现

### 2.1 目录检查算法

#### 目录解析

```python
# 目录检查算法
import re
from typing import List, Dict

class TOCChecker:
    def __init__(self):
        self.toc_pattern = re.compile(r'^## 📋 目录')
        self.link_pattern = re.compile(r'^- \[([^\]]+)\]\(#([^\)]+)\)')

    def check_toc_exists(self, content: str) -> bool:
        """检查目录是否存在"""
        return bool(self.toc_pattern.search(content))

    def parse_toc(self, content: str) -> List[Dict]:
        """解析目录"""
        lines = content.split('\n')
        toc_start = False
        toc_items = []

        for line in lines:
            if self.toc_pattern.search(line):
                toc_start = True
                continue

            if toc_start:
                if line.strip() == '':
                    continue
                if line.startswith('##') and '目录' not in line:
                    break

                match = self.link_pattern.match(line)
                if match:
                    toc_items.append({
                        'text': match.group(1),
                        'link': match.group(2),
                        'level': line.count('  ')  # 缩进层级
                    })

        return toc_items

    def check_toc_completeness(self, content: str) -> List[str]:
        """检查目录完整性"""
        errors = []

        # 解析目录
        toc_items = self.parse_toc(content)
        toc_links = {item['link'] for item in toc_items}

        # 解析实际标题
        headers = self.parse_headers(content)
        header_ids = {self.header_to_id(h) for h in headers}

        # 检查缺失
        missing_in_toc = header_ids - toc_links
        if missing_in_toc:
            errors.append(f"目录中缺失的章节: {missing_in_toc}")

        # 检查多余
        extra_in_toc = toc_links - header_ids
        if extra_in_toc:
            errors.append(f"目录中多余的链接: {extra_in_toc}")

        return errors

    def parse_headers(self, content: str) -> List[str]:
        """解析文档中的标题"""
        header_pattern = re.compile(r'^(#{2,4})\s+(.+)$', re.MULTILINE)
        headers = []

        for match in header_pattern.finditer(content):
            level = len(match.group(1))
            text = match.group(2).strip()
            headers.append({'level': level, 'text': text})

        return headers

    def header_to_id(self, header: Dict) -> str:
        """将标题转换为ID (Markdown链接格式)"""
        text = header['text']
        # 转换为小写，替换空格为连字符
        id_text = text.lower().replace(' ', '-')
        # 移除特殊字符
        id_text = re.sub(r'[^\w\-]', '', id_text)
        return id_text
```

### 2.2 编号检查算法

#### 编号验证

```python
# 编号检查算法
class NumberingChecker:
    def __init__(self):
        self.part_pattern = re.compile(r'^第([一二三四五六七八九十]+)部分')
        self.section_pattern = re.compile(r'^(\d+)\.(\d+)(?:\.(\d+))?(?:\.(\d+))?')

    def check_part_numbering(self, headers: List[Dict]) -> List[str]:
        """检查部分编号"""
        errors = []
        parts = [h for h in headers if h['level'] == 2 and '部分' in h['text']]

        expected_parts = ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十']

        for i, part in enumerate(parts):
            match = self.part_pattern.match(part['text'])
            if not match:
                errors.append(f"部分格式错误: {part['text']}")
                continue

            actual_num = match.group(1)
            expected_num = expected_parts[i] if i < len(expected_parts) else None

            if expected_num and actual_num != expected_num:
                errors.append(f"部分编号不连续: 期望 '第{expected_num}部分', 实际 '{part['text']}'")

        return errors

    def check_section_numbering(self, headers: List[Dict]) -> List[str]:
        """检查章节编号"""
        errors = []

        # 按部分分组
        parts = {}
        current_part = None

        for header in headers:
            if header['level'] == 2 and '部分' in header['text']:
                current_part = header['text']
                parts[current_part] = []
            elif header['level'] == 3 and current_part:
                parts[current_part].append(header)

        # 检查每个部分的章节编号
        for part, sections in parts.items():
            for i, section in enumerate(sections, 1):
                match = self.section_pattern.match(section['text'])
                if not match:
                    continue

                major = int(match.group(1))
                minor = int(match.group(2))

                # 检查主编号 (应该与部分号对应)
                part_num = self.get_part_number(part)
                if major != part_num:
                    errors.append(f"章节主编号错误: {section['text']}, 期望 {part_num}.X")

                # 检查次编号连续性
                expected_minor = i
                if minor != expected_minor:
                    errors.append(f"章节次编号不连续: {section['text']}, 期望 {part_num}.{expected_minor}")

        return errors

    def get_part_number(self, part_text: str) -> int:
        """获取部分编号"""
        part_map = {
            '一': 1, '二': 2, '三': 3, '四': 4, '五': 5,
            '六': 6, '七': 7, '八': 8, '九': 9, '十': 10
        }
        match = self.part_pattern.match(part_text)
        if match:
            return part_map.get(match.group(1), 0)
        return 0
```

### 2.3 内容检查算法

#### 内容验证

```python
# 内容检查算法
class ContentChecker:
    def check_content_completeness(self, content: str) -> List[str]:
        """检查内容完整性"""
        errors = []

        # 解析章节
        sections = self.parse_sections(content)

        for section in sections:
            # 检查章节是否有内容
            if len(section['content'].strip()) < 50:  # 至少50字符
                errors.append(f"章节内容过短: {section['title']}")

            # 检查代码块完整性
            code_blocks = self.find_code_blocks(section['content'])
            for code_block in code_blocks:
                if not code_block.get('language'):
                    errors.append(f"代码块缺少语言标识: {section['title']}")

            # 检查图表完整性
            diagrams = self.find_diagrams(section['content'])
            for diagram in diagrams:
                if not self.validate_diagram(diagram):
                    errors.append(f"图表语法错误: {section['title']}")

        return errors

    def parse_sections(self, content: str) -> List[Dict]:
        """解析章节"""
        sections = []
        lines = content.split('\n')
        current_section = None

        for line in lines:
            if line.startswith('##'):
                if current_section:
                    sections.append(current_section)
                current_section = {
                    'title': line.strip(),
                    'content': '',
                    'level': len(line) - len(line.lstrip('#'))
                }
            elif current_section:
                current_section['content'] += line + '\n'

        if current_section:
            sections.append(current_section)

        return sections

    def find_code_blocks(self, content: str) -> List[Dict]:
        """查找代码块"""
        code_pattern = re.compile(r'```(\w+)?\n(.*?)```', re.DOTALL)
        blocks = []

        for match in code_pattern.finditer(content):
            blocks.append({
                'language': match.group(1),
                'code': match.group(2)
            })

        return blocks

    def find_diagrams(self, content: str) -> List[str]:
        """查找图表"""
        diagram_pattern = re.compile(r'```mermaid\n(.*?)```', re.DOTALL)
        return diagram_pattern.findall(content)

    def validate_diagram(self, diagram: str) -> bool:
        """验证图表语法"""
        # 基本语法检查
        if not diagram.strip():
            return False

        # 检查基本结构
        valid_types = ['graph', 'flowchart', 'sequenceDiagram', 'classDiagram', 'mindmap']
        return any(diagram.strip().startswith(t) for t in valid_types)
```

---

## 第三部分: 自动化检查工具

### 3.1 Python检查脚本

#### 完整检查脚本

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
文档结构一致性检查工具
"""

import os
import re
from pathlib import Path
from typing import List, Dict
import json

class DocumentChecker:
    def __init__(self, root_dir: str):
        self.root_dir = Path(root_dir)
        self.toc_checker = TOCChecker()
        self.numbering_checker = NumberingChecker()
        self.content_checker = ContentChecker()

    def check_all_documents(self) -> Dict:
        """检查所有文档"""
        results = {
            'total_files': 0,
            'passed': 0,
            'failed': 0,
            'errors': []
        }

        # 查找所有Markdown文件
        md_files = list(self.root_dir.rglob('*.md'))
        results['total_files'] = len(md_files)

        for md_file in md_files:
            try:
                content = md_file.read_text(encoding='utf-8')
                errors = self.check_document(content, str(md_file))

                if errors:
                    results['failed'] += 1
                    results['errors'].append({
                        'file': str(md_file),
                        'errors': errors
                    })
                else:
                    results['passed'] += 1
            except Exception as e:
                results['failed'] += 1
                results['errors'].append({
                    'file': str(md_file),
                    'errors': [f'检查失败: {str(e)}']
                })

        return results

    def check_document(self, content: str, filepath: str) -> List[str]:
        """检查单个文档"""
        errors = []

        # 1. 检查目录
        if not self.toc_checker.check_toc_exists(content):
            errors.append("缺少目录 (## 📋 目录)")
        else:
            toc_errors = self.toc_checker.check_toc_completeness(content)
            errors.extend(toc_errors)

        # 2. 检查编号
        headers = self.toc_checker.parse_headers(content)
        numbering_errors = self.numbering_checker.check_part_numbering(headers)
        numbering_errors.extend(self.numbering_checker.check_section_numbering(headers))
        errors.extend(numbering_errors)

        # 3. 检查内容
        content_errors = self.content_checker.check_content_completeness(content)
        errors.extend(content_errors)

        return errors

    def generate_report(self, results: Dict, output_file: str):
        """生成检查报告"""
        report = f"""# 文档结构一致性检查报告

> **生成时间**: {datetime.now().isoformat()}
> **检查文件数**: {results['total_files']}
> **通过**: {results['passed']}
> **失败**: {results['failed']}

## 检查结果

### 总体统计

| 指标 | 数量 | 百分比 |
|------|------|--------|
| **总文件数** | {results['total_files']} | 100% |
| **通过** | {results['passed']} | {results['passed']/results['total_files']*100:.1f}% |
| **失败** | {results['failed']} | {results['failed']/results['total_files']*100:.1f}% |

## 错误详情

"""

        for error_info in results['errors']:
            report += f"### {error_info['file']}\n\n"
            for error in error_info['errors']:
                report += f"- ❌ {error}\n"
            report += "\n"

        # 写入文件
        Path(output_file).write_text(report, encoding='utf-8')
        print(f"检查报告已生成: {output_file}")

# 使用示例
if __name__ == '__main__':
    checker = DocumentChecker('docs')
    results = checker.check_all_documents()
    checker.generate_report(results, 'document_check_report.md')
```

### 3.2 检查报告生成

#### 报告格式

```markdown
# 文档结构一致性检查报告

## 检查结果总览

| 文件 | 目录 | 编号 | 内容 | 状态 |
|------|------|------|------|------|
| doc1.md | ✅ | ✅ | ✅ | ✅ 通过 |
| doc2.md | ❌ | ✅ | ✅ | ❌ 失败 |

## 详细错误

### doc2.md
- ❌ 缺少目录
- ⚠️ 章节1.3编号缺失
```

### 3.3 自动修复建议

#### 修复建议生成

```python
# 自动修复建议
class AutoFixer:
    def generate_fix_suggestions(self, errors: List[str]) -> List[Dict]:
        """生成修复建议"""
        suggestions = []

        for error in errors:
            if "缺少目录" in error:
                suggestions.append({
                    'error': error,
                    'fix': '在文档开头添加 ## 📋 目录 章节',
                    'code': self.generate_toc_template()
                })
            elif "编号不连续" in error:
                suggestions.append({
                    'error': error,
                    'fix': '修正章节编号，确保连续',
                    'code': self.generate_numbering_fix(error)
                })
            elif "内容过短" in error:
                suggestions.append({
                    'error': error,
                    'fix': '补充章节内容，至少50字符',
                    'code': None
                })

        return suggestions

    def generate_toc_template(self) -> str:
        """生成目录模板"""
        return """## 📋 目录

- [文档标题](#文档标题)
  - [📋 目录](#-目录)
  - [第一部分: XXX](#第一部分-xxx)
    - [1.1 XXX](#11-xxx)
  - [第二部分: XXX](#第二部分-xxx)
"""
```

---

## 第四部分: 检查清单

### 4.1 结构检查清单

#### 检查项

```markdown
## 结构检查清单

### 目录检查
- [ ] 文档有目录章节 (## 📋 目录)
- [ ] 目录包含所有主要章节
- [ ] 目录链接正确有效
- [ ] 目录层级正确 (最多4级)

### 编号检查
- [ ] 部分编号连续 (第一部分 → 第二部分 → ...)
- [ ] 章节编号连续 (1.1 → 1.2 → 1.3 → ...)
- [ ] 编号格式一致
- [ ] 无跳号现象

### 标题检查
- [ ] 所有标题格式正确
- [ ] 标题层级正确
- [ ] 标题内容清晰
```

### 4.2 内容检查清单

#### 检查项

```markdown
## 内容检查清单

### 内容完整性
- [ ] 每个章节有内容 (至少50字符)
- [ ] 章节内容相关
- [ ] 无空章节

### 代码示例
- [ ] 代码块有语言标识
- [ ] 代码可运行 (如可能)
- [ ] 代码有注释说明

### 图表
- [ ] Mermaid图表语法正确
- [ ] 图表有说明文字
- [ ] 图表链接有效
```

### 4.3 质量检查清单

#### 检查项

```markdown
## 质量检查清单

### 可读性
- [ ] 语言流畅
- [ ] 逻辑清晰
- [ ] 格式规范

### 准确性
- [ ] 内容准确
- [ ] 代码正确
- [ ] 引用有效

### 完整性
- [ ] 主题覆盖完整
- [ ] 示例完整
- [ ] 说明完整
```

---

## 第五部分: 常见问题与修复

### 5.1 目录缺失

#### 问题描述

```text
问题: 文档缺少目录章节

症状:
  - 文档开头没有 ## 📋 目录
  - 或目录内容为空

修复方法:
  1. 在文档开头添加目录章节
  2. 使用目录生成工具自动生成
  3. 确保目录链接正确
```

#### 修复示例

```markdown
# 修复前
# 文档标题

## 第一部分: XXX

# 修复后
# 文档标题

## 📋 目录

- [文档标题](#文档标题)
  - [📋 目录](#-目录)
  - [第一部分: XXX](#第一部分-xxx)
```

### 5.2 编号不连续

#### 问题描述

```text
问题: 章节编号不连续

症状:
  - 1.1 → 1.3 (缺少1.2)
  - 第一部分 → 第三部分 (缺少第二部分)

修复方法:
  1. 补充缺失章节
  2. 或重新编号现有章节
  3. 确保编号连续
```

#### 修复示例

```markdown
# 修复前
### 1.1 XXX
### 1.3 XXX  # 缺少1.2

# 修复后
### 1.1 XXX
### 1.2 XXX  # 补充缺失章节
### 1.3 XXX
```

### 5.3 内容缺失

#### 问题描述

```text
问题: 章节内容缺失或不完整

症状:
  - 章节只有标题
  - 内容过短 (<50字符)
  - 缺少关键信息

修复方法:
  1. 补充章节内容
  2. 添加示例代码
  3. 添加说明文字
```

### 5.4 结构不一致

#### 问题描述

```text
问题: 文档结构不一致

症状:
  - 不同文档结构不同
  - 编号格式不一致
  - 目录格式不一致

修复方法:
  1. 统一文档模板
  2. 使用检查工具验证
  3. 批量修复
```

---

## 总结

### 核心要点

1. **检查规则**: 目录、编号、内容完整性规则
2. **检查算法**: 目录检查、编号检查、内容检查
3. **自动化工具**: Python检查脚本、报告生成
4. **检查清单**: 结构、内容、质量清单
5. **问题修复**: 常见问题与修复方法

### 使用价值

```text
使用价值:
  ├─ 确保文档结构一致性
  ├─ 自动发现结构问题
  ├─ 提供修复建议
  └─ 提升文档质量
```

---

**文档状态**: ✅ 完成 (1,500+ 行)
**最后更新**: 2025年12月
**维护者**: OTLP项目组
