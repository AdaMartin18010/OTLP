# ğŸ“Š æ¦‚ç‡è®ºåœ¨OTLPä¸­çš„åº”ç”¨

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´12æœˆ
> **æ–‡æ¡£ç±»å‹**: ç†è®ºåŸºç¡€
> **é¢„ä¼°ç¯‡å¹…**: 1,500+ è¡Œ
> **ä¸»é¢˜ID**: T1.1.4
> **çŠ¶æ€**: P0 ä¼˜å…ˆçº§

---

## ğŸ“‹ ç›®å½•

- [ğŸ“Š æ¦‚ç‡è®ºåœ¨OTLPä¸­çš„åº”ç”¨](#-æ¦‚ç‡è®ºåœ¨otlpä¸­çš„åº”ç”¨)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†: æ¦‚ç‡è®ºåŸºç¡€](#ç¬¬ä¸€éƒ¨åˆ†-æ¦‚ç‡è®ºåŸºç¡€)
    - [1.1 æ¦‚ç‡ç©ºé—´](#11-æ¦‚ç‡ç©ºé—´)
      - [æ¦‚ç‡ç©ºé—´å®šä¹‰](#æ¦‚ç‡ç©ºé—´å®šä¹‰)
      - [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰)
    - [1.2 éšæœºå˜é‡](#12-éšæœºå˜é‡)
      - [éšæœºå˜é‡å®šä¹‰](#éšæœºå˜é‡å®šä¹‰)
      - [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰-1)
    - [1.3 æ¦‚ç‡åˆ†å¸ƒ](#13-æ¦‚ç‡åˆ†å¸ƒ)
      - [å¸¸è§åˆ†å¸ƒ](#å¸¸è§åˆ†å¸ƒ)
      - [åˆ†å¸ƒåº”ç”¨](#åˆ†å¸ƒåº”ç”¨)
  - [ç¬¬äºŒéƒ¨åˆ†: é‡‡æ ·ç†è®º](#ç¬¬äºŒéƒ¨åˆ†-é‡‡æ ·ç†è®º)
    - [2.1 é‡‡æ ·æ–¹æ³•](#21-é‡‡æ ·æ–¹æ³•)
      - [é‡‡æ ·æ–¹æ³•åˆ†ç±»](#é‡‡æ ·æ–¹æ³•åˆ†ç±»)
    - [2.2 é‡‡æ ·åˆ†å¸ƒ](#22-é‡‡æ ·åˆ†å¸ƒ)
      - [é‡‡æ ·åˆ†å¸ƒç†è®º](#é‡‡æ ·åˆ†å¸ƒç†è®º)
      - [å½¢å¼åŒ–å®šä¹‰](#å½¢å¼åŒ–å®šä¹‰-2)
    - [2.3 é‡‡æ ·è¯¯å·®](#23-é‡‡æ ·è¯¯å·®)
      - [è¯¯å·®åˆ†æ](#è¯¯å·®åˆ†æ)
  - [ç¬¬ä¸‰éƒ¨åˆ†: é‡‡æ ·ç­–ç•¥å»ºæ¨¡](#ç¬¬ä¸‰éƒ¨åˆ†-é‡‡æ ·ç­–ç•¥å»ºæ¨¡)
    - [3.1 éšæœºé‡‡æ ·æ¨¡å‹](#31-éšæœºé‡‡æ ·æ¨¡å‹)
      - [éšæœºé‡‡æ ·](#éšæœºé‡‡æ ·)
      - [æ•°å­¦æ€§è´¨](#æ•°å­¦æ€§è´¨)
    - [3.2 å¤´éƒ¨é‡‡æ ·æ¨¡å‹](#32-å¤´éƒ¨é‡‡æ ·æ¨¡å‹)
      - [å¤´éƒ¨é‡‡æ ·](#å¤´éƒ¨é‡‡æ ·)
    - [3.3 å°¾éƒ¨é‡‡æ ·æ¨¡å‹](#33-å°¾éƒ¨é‡‡æ ·æ¨¡å‹)
      - [å°¾éƒ¨é‡‡æ ·](#å°¾éƒ¨é‡‡æ ·)
    - [3.4 æ™ºèƒ½é‡‡æ ·æ¨¡å‹](#34-æ™ºèƒ½é‡‡æ ·æ¨¡å‹)
      - [æ™ºèƒ½é‡‡æ ·](#æ™ºèƒ½é‡‡æ ·)
  - [ç¬¬å››éƒ¨åˆ†: æ€§èƒ½åˆ†æä¸­çš„æ¦‚ç‡](#ç¬¬å››éƒ¨åˆ†-æ€§èƒ½åˆ†æä¸­çš„æ¦‚ç‡)
    - [4.1 å»¶è¿Ÿåˆ†å¸ƒ](#41-å»¶è¿Ÿåˆ†å¸ƒ)
      - [å»¶è¿Ÿåˆ†å¸ƒæ¨¡å‹](#å»¶è¿Ÿåˆ†å¸ƒæ¨¡å‹)
    - [4.2 ååé‡åˆ†å¸ƒ](#42-ååé‡åˆ†å¸ƒ)
      - [ååé‡æ¨¡å‹](#ååé‡æ¨¡å‹)
    - [4.3 é”™è¯¯ç‡ä¼°è®¡](#43-é”™è¯¯ç‡ä¼°è®¡)
      - [é”™è¯¯ç‡æ¨¡å‹](#é”™è¯¯ç‡æ¨¡å‹)
  - [ç¬¬äº”éƒ¨åˆ†: ç»Ÿè®¡æ¨æ–­](#ç¬¬äº”éƒ¨åˆ†-ç»Ÿè®¡æ¨æ–­)
    - [5.1 å‚æ•°ä¼°è®¡](#51-å‚æ•°ä¼°è®¡)
      - [ç‚¹ä¼°è®¡](#ç‚¹ä¼°è®¡)
    - [5.2 å‡è®¾æ£€éªŒ](#52-å‡è®¾æ£€éªŒ)
      - [å‡è®¾æ£€éªŒ](#å‡è®¾æ£€éªŒ)
    - [5.3 ç½®ä¿¡åŒºé—´](#53-ç½®ä¿¡åŒºé—´)
      - [ç½®ä¿¡åŒºé—´è®¡ç®—](#ç½®ä¿¡åŒºé—´è®¡ç®—)
  - [æ€»ç»“](#æ€»ç»“)
    - [æ ¸å¿ƒè¦ç‚¹](#æ ¸å¿ƒè¦ç‚¹)
    - [åº”ç”¨ä»·å€¼](#åº”ç”¨ä»·å€¼)

---

## ç¬¬ä¸€éƒ¨åˆ†: æ¦‚ç‡è®ºåŸºç¡€

### 1.1 æ¦‚ç‡ç©ºé—´

#### æ¦‚ç‡ç©ºé—´å®šä¹‰

```text
æ¦‚ç‡ç©ºé—´ (Î©, F, P):
  â”œâ”€ Î©: æ ·æœ¬ç©ºé—´ (æ‰€æœ‰å¯èƒ½ç»“æœ)
  â”œâ”€ F: äº‹ä»¶åŸŸ (äº‹ä»¶é›†åˆ)
  â””â”€ P: æ¦‚ç‡æµ‹åº¦ (æ¦‚ç‡å‡½æ•°)

åœ¨OTLPä¸­çš„åº”ç”¨:
  â”œâ”€ Î©: æ‰€æœ‰å¯èƒ½çš„Spané›†åˆ
  â”œâ”€ F: Spanäº‹ä»¶é›†åˆ
  â””â”€ P: Spanè¢«é‡‡æ ·çš„æ¦‚ç‡
```

#### å½¢å¼åŒ–å®šä¹‰

```haskell
-- æ¦‚ç‡ç©ºé—´å®šä¹‰
data ProbabilitySpace a = ProbabilitySpace
  { sampleSpace :: Set a
  , eventSpace  :: Set (Set a)
  , probability :: Set a -> Float
  }

-- OTLPé‡‡æ ·æ¦‚ç‡ç©ºé—´
type OtlpSampleSpace = ProbabilitySpace Span

otlpProbabilitySpace :: OtlpSampleSpace
otlpProbabilitySpace = ProbabilitySpace
  { sampleSpace = allSpans
  , eventSpace  = powerSet allSpans
  , probability = samplingProbability
  }
```

### 1.2 éšæœºå˜é‡

#### éšæœºå˜é‡å®šä¹‰

```text
éšæœºå˜é‡ X: Î© â†’ â„
  - å°†æ ·æœ¬ç©ºé—´æ˜ å°„åˆ°å®æ•°
  - è¡¨ç¤ºå¯è§‚æµ‹çš„éšæœºç°è±¡

åœ¨OTLPä¸­çš„åº”ç”¨:
  â”œâ”€ Xâ‚: Spanå»¶è¿Ÿ (æ¯«ç§’)
  â”œâ”€ Xâ‚‚: Spanå¤§å° (å­—èŠ‚)
  â”œâ”€ Xâ‚ƒ: Spané”™è¯¯æ ‡å¿— (0/1)
  â””â”€ Xâ‚„: é‡‡æ ·å†³ç­– (0/1)
```

#### å½¢å¼åŒ–å®šä¹‰

```haskell
-- éšæœºå˜é‡å®šä¹‰
type RandomVariable a = a -> Float

-- OTLPéšæœºå˜é‡
spanLatency :: RandomVariable Span
spanLatency span = fromIntegral (spanDuration span)

spanSize :: RandomVariable Span
spanSize span = fromIntegral (spanByteSize span)

spanError :: RandomVariable Span
spanError span = if spanHasError span then 1.0 else 0.0
```

### 1.3 æ¦‚ç‡åˆ†å¸ƒ

#### å¸¸è§åˆ†å¸ƒ

```text
å¸¸è§æ¦‚ç‡åˆ†å¸ƒ:
  â”œâ”€ ç¦»æ•£åˆ†å¸ƒ
  â”‚   â”œâ”€ ä¼¯åŠªåˆ©åˆ†å¸ƒ (Bernoulli)
  â”‚   â”œâ”€ äºŒé¡¹åˆ†å¸ƒ (Binomial)
  â”‚   â””â”€ æ³Šæ¾åˆ†å¸ƒ (Poisson)
  â”‚
  â”œâ”€ è¿ç»­åˆ†å¸ƒ
  â”‚   â”œâ”€ æ­£æ€åˆ†å¸ƒ (Normal)
  â”‚   â”œâ”€ æŒ‡æ•°åˆ†å¸ƒ (Exponential)
  â”‚   â””â”€ ä¼½é©¬åˆ†å¸ƒ (Gamma)
  â”‚
  â””â”€ æ··åˆåˆ†å¸ƒ
      â”œâ”€ æ··åˆæ­£æ€
      â””â”€ æ··åˆæŒ‡æ•°
```

#### åˆ†å¸ƒåº”ç”¨

```haskell
-- æ¦‚ç‡åˆ†å¸ƒå®šä¹‰
data ProbabilityDistribution a = Distribution
  { pdf :: a -> Float  -- æ¦‚ç‡å¯†åº¦å‡½æ•°
  , cdf :: a -> Float  -- ç´¯ç§¯åˆ†å¸ƒå‡½æ•°
  , mean :: Float
  , variance :: Float
  }

-- Spanå»¶è¿Ÿåˆ†å¸ƒ (æŒ‡æ•°åˆ†å¸ƒ)
spanLatencyDistribution :: ProbabilityDistribution Float
spanLatencyDistribution = ExponentialDistribution
  { lambda = 0.001  -- å¹³å‡å»¶è¿Ÿ1000ms
  }

-- é‡‡æ ·å†³ç­–åˆ†å¸ƒ (ä¼¯åŠªåˆ©åˆ†å¸ƒ)
samplingDecisionDistribution :: Float -> ProbabilityDistribution Bool
samplingDecisionDistribution p = BernoulliDistribution
  { probability = p
  }
```

---

## ç¬¬äºŒéƒ¨åˆ†: é‡‡æ ·ç†è®º

### 2.1 é‡‡æ ·æ–¹æ³•

#### é‡‡æ ·æ–¹æ³•åˆ†ç±»

```text
é‡‡æ ·æ–¹æ³•:
  1. ç®€å•éšæœºé‡‡æ · (Simple Random Sampling)
     - æ¯ä¸ªSpanç­‰æ¦‚ç‡è¢«é‡‡æ ·
     - æ¦‚ç‡: P(X=1) = p

  2. åˆ†å±‚é‡‡æ · (Stratified Sampling)
     - æŒ‰å±‚é‡‡æ ·ï¼Œæ¯å±‚ç‹¬ç«‹é‡‡æ ·
     - æ¦‚ç‡: P(X=1|Layer=i) = páµ¢

  3. ç³»ç»Ÿé‡‡æ · (Systematic Sampling)
     - æŒ‰å›ºå®šé—´éš”é‡‡æ ·
     - æ¦‚ç‡: P(X=1) = 1/k (kä¸ºé—´éš”)

  4. è‡ªé€‚åº”é‡‡æ · (Adaptive Sampling)
     - æ ¹æ®ç‰¹å¾åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡
     - æ¦‚ç‡: P(X=1|Features) = f(Features)
```

### 2.2 é‡‡æ ·åˆ†å¸ƒ

#### é‡‡æ ·åˆ†å¸ƒç†è®º

```text
é‡‡æ ·åˆ†å¸ƒ:
  è®¾æ€»ä½“åˆ†å¸ƒä¸º F(x), æ ·æœ¬å¤§å°ä¸º n
  æ ·æœ¬å‡å€¼ XÌ„ çš„åˆ†å¸ƒ:
    - æœŸæœ›: E[XÌ„] = Î¼
    - æ–¹å·®: Var[XÌ„] = ÏƒÂ²/n
    - å½“nâ†’âˆæ—¶, XÌ„ ~ N(Î¼, ÏƒÂ²/n) (ä¸­å¿ƒæé™å®šç†)
```

#### å½¢å¼åŒ–å®šä¹‰

```haskell
-- é‡‡æ ·åˆ†å¸ƒ
data SamplingDistribution = SamplingDistribution
  { populationDistribution :: ProbabilityDistribution Float
  , sampleSize :: Int
  , sampleMeanDistribution :: ProbabilityDistribution Float
  }

-- ä¸­å¿ƒæé™å®šç†åº”ç”¨
centralLimitTheorem :: SamplingDistribution -> ProbabilityDistribution Float
centralLimitTheorem dist =
  let popMean = mean (populationDistribution dist)
      popVar = variance (populationDistribution dist)
      n = sampleSize dist
  in NormalDistribution
    { mean = popMean
    , variance = popVar / fromIntegral n
    }
```

### 2.3 é‡‡æ ·è¯¯å·®

#### è¯¯å·®åˆ†æ

```text
é‡‡æ ·è¯¯å·®:
  1. æ ‡å‡†è¯¯å·® (Standard Error)
     SE = Ïƒ/âˆšn

  2. ç›¸å¯¹è¯¯å·® (Relative Error)
     RE = SE/Î¼

  3. ç½®ä¿¡åŒºé—´
     CI = [XÌ„ - zÂ·SE, XÌ„ + zÂ·SE]
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: é‡‡æ ·ç­–ç•¥å»ºæ¨¡

### 3.1 éšæœºé‡‡æ ·æ¨¡å‹

#### éšæœºé‡‡æ ·

```haskell
-- éšæœºé‡‡æ ·æ¨¡å‹
data RandomSampling = RandomSampling
  { samplingRate :: Float  -- é‡‡æ ·ç‡ p âˆˆ [0, 1]
  }

instance SamplingStrategy RandomSampling where
  shouldSample :: RandomSampling -> Span -> Bool
  shouldSample strategy span =
    let randomValue = randomFloat (0.0, 1.0)
    in randomValue < strategy.samplingRate

-- é‡‡æ ·æ¦‚ç‡
samplingProbability :: RandomSampling -> Float
samplingProbability strategy = strategy.samplingRate
```

#### æ•°å­¦æ€§è´¨

```text
éšæœºé‡‡æ ·æ•°å­¦æ€§è´¨:
  â”œâ”€ æœŸæœ›é‡‡æ ·æ•°: E[N] = pÂ·N
  â”œâ”€ æ–¹å·®: Var[N] = p(1-p)Â·N
  â””â”€ é‡‡æ ·åˆ†å¸ƒ: N ~ Binomial(N, p)
```

### 3.2 å¤´éƒ¨é‡‡æ ·æ¨¡å‹

#### å¤´éƒ¨é‡‡æ ·

```haskell
-- å¤´éƒ¨é‡‡æ ·æ¨¡å‹
data HeadSampling = HeadSampling
  { samplingRate :: Float
  , traceIdHash :: TraceID -> Int
  }

instance SamplingStrategy HeadSampling where
  shouldSample :: HeadSampling -> Span -> Bool
  shouldSample strategy span =
    let hash = strategy.traceIdHash (spanTraceId span)
        threshold = floor (strategy.samplingRate * maxHashValue)
    in hash < threshold

-- é‡‡æ ·æ¦‚ç‡
samplingProbability :: HeadSampling -> Float
samplingProbability strategy = strategy.samplingRate
```

### 3.3 å°¾éƒ¨é‡‡æ ·æ¨¡å‹

#### å°¾éƒ¨é‡‡æ ·

```haskell
-- å°¾éƒ¨é‡‡æ ·æ¨¡å‹
data TailSampling = TailSampling
  { baseRate :: Float
  , errorRate :: Float  -- é”™è¯¯Spané‡‡æ ·ç‡
  , slowRate :: Float   -- æ…¢Spané‡‡æ ·ç‡
  }

instance SamplingStrategy TailSampling where
  shouldSample :: TailSampling -> Span -> Bool
  shouldSample strategy span
    | spanHasError span = randomFloat (0, 1) < strategy.errorRate
    | spanIsSlow span = randomFloat (0, 1) < strategy.slowRate
    | otherwise = randomFloat (0, 1) < strategy.baseRate

-- é‡‡æ ·æ¦‚ç‡ (æ¡ä»¶æ¦‚ç‡)
samplingProbability :: TailSampling -> Span -> Float
samplingProbability strategy span
  | spanHasError span = strategy.errorRate
  | spanIsSlow span = strategy.slowRate
  | otherwise = strategy.baseRate
```

### 3.4 æ™ºèƒ½é‡‡æ ·æ¨¡å‹

#### æ™ºèƒ½é‡‡æ ·

```haskell
-- æ™ºèƒ½é‡‡æ ·æ¨¡å‹
data IntelligentSampling = IntelligentSampling
  { baseRate :: Float
  , rules :: [SamplingRule]
  }

data SamplingRule = SamplingRule
  { condition :: Span -> Bool
  , rate :: Float
  , priority :: Int
  }

instance SamplingStrategy IntelligentSampling where
  shouldSample :: IntelligentSampling -> Span -> Bool
  shouldSample strategy span =
    let applicableRules = filter (\r -> r.condition span) strategy.rules
        sortedRules = sortBy (comparing priority) applicableRules
        finalRate = case sortedRules of
          [] -> strategy.baseRate
          (r:_) -> r.rate
    in randomFloat (0, 1) < finalRate
```

---

## ç¬¬å››éƒ¨åˆ†: æ€§èƒ½åˆ†æä¸­çš„æ¦‚ç‡

### 4.1 å»¶è¿Ÿåˆ†å¸ƒ

#### å»¶è¿Ÿåˆ†å¸ƒæ¨¡å‹

```haskell
-- å»¶è¿Ÿåˆ†å¸ƒ
data LatencyDistribution = LatencyDistribution
  { p50 :: Float
  , p95 :: Float
  , p99 :: Float
  , distribution :: ProbabilityDistribution Float
  }

-- å»¶è¿Ÿåˆ†å¸ƒä¼°è®¡
estimateLatencyDistribution :: [Span] -> LatencyDistribution
estimateLatencyDistribution spans =
  let latencies = map spanLatency spans
      sorted = sort latencies
      n = length sorted
      p50Value = sorted !! (n `div` 2)
      p95Value = sorted !! (n * 95 `div` 100)
      p99Value = sorted !! (n * 99 `div` 100)
      dist = fitDistribution latencies
  in LatencyDistribution
    { p50 = p50Value
    , p95 = p95Value
    , p99 = p99Value
    , distribution = dist
    }
```

### 4.2 ååé‡åˆ†å¸ƒ

#### ååé‡æ¨¡å‹

```haskell
-- ååé‡åˆ†å¸ƒ
data ThroughputDistribution = ThroughputDistribution
  { meanThroughput :: Float
  , variance :: Float
  , distribution :: ProbabilityDistribution Float
  }

-- ååé‡ä¼°è®¡
estimateThroughput :: [TimeWindow] -> ThroughputDistribution
estimateThroughput windows =
  let throughputs = map windowThroughput windows
      mean = average throughputs
      var = variance throughputs
      dist = fitDistribution throughputs
  in ThroughputDistribution
    { meanThroughput = mean
    , variance = var
    , distribution = dist
    }
```

### 4.3 é”™è¯¯ç‡ä¼°è®¡

#### é”™è¯¯ç‡æ¨¡å‹

```haskell
-- é”™è¯¯ç‡ä¼°è®¡
data ErrorRateEstimate = ErrorRateEstimate
  { errorRate :: Float
  , confidenceInterval :: (Float, Float)
  , sampleSize :: Int
  }

-- é”™è¯¯ç‡è®¡ç®—
estimateErrorRate :: [Span] -> Float -> ErrorRateEstimate
estimateErrorRate spans confidenceLevel =
  let total = length spans
      errors = length (filter spanHasError spans)
      rate = fromIntegral errors / fromIntegral total
      se = sqrt (rate * (1 - rate) / fromIntegral total)
      z = zScore confidenceLevel
      ci = (rate - z * se, rate + z * se)
  in ErrorRateEstimate
    { errorRate = rate
    , confidenceInterval = ci
    , sampleSize = total
    }
```

---

## ç¬¬äº”éƒ¨åˆ†: ç»Ÿè®¡æ¨æ–­

### 5.1 å‚æ•°ä¼°è®¡

#### ç‚¹ä¼°è®¡

```haskell
-- å‚æ•°ä¼°è®¡
data ParameterEstimate a = ParameterEstimate
  { estimator :: [a] -> Float
  , estimate :: Float
  , bias :: Float
  , variance :: Float
  }

-- å‡å€¼ä¼°è®¡ (æ— åä¼°è®¡)
meanEstimator :: ParameterEstimate Float
meanEstimator = ParameterEstimate
  { estimator = \xs -> sum xs / fromIntegral (length xs)
  , estimate = 0  -- å¾…è®¡ç®—
  , bias = 0  -- æ— å
  , variance = 0  -- å¾…è®¡ç®—
  }
```

### 5.2 å‡è®¾æ£€éªŒ

#### å‡è®¾æ£€éªŒ

```haskell
-- å‡è®¾æ£€éªŒ
data HypothesisTest = HypothesisTest
  { nullHypothesis :: String
  , alternativeHypothesis :: String
  , testStatistic :: [Float] -> Float
  , pValue :: Float
  , significanceLevel :: Float
  , rejectNull :: Bool
  }

-- tæ£€éªŒç¤ºä¾‹
tTest :: [Float] -> Float -> HypothesisTest
tTest sample hypothesizedMean =
  let n = length sample
      sampleMean = average sample
      sampleStd = stdDev sample
      tStat = (sampleMean - hypothesizedMean) / (sampleStd / sqrt (fromIntegral n))
      pVal = tDistributionPValue tStat (n - 1)
      reject = pVal < 0.05
  in HypothesisTest
    { nullHypothesis = "Î¼ = " ++ show hypothesizedMean
    , alternativeHypothesis = "Î¼ â‰  " ++ show hypothesizedMean
    , testStatistic = const tStat
    , pValue = pVal
    , significanceLevel = 0.05
    , rejectNull = reject
    }
```

### 5.3 ç½®ä¿¡åŒºé—´

#### ç½®ä¿¡åŒºé—´è®¡ç®—

```haskell
-- ç½®ä¿¡åŒºé—´
data ConfidenceInterval = ConfidenceInterval
  { lowerBound :: Float
  , upperBound :: Float
  , confidenceLevel :: Float
  , method :: String
  }

-- å‡å€¼ç½®ä¿¡åŒºé—´
meanConfidenceInterval :: [Float] -> Float -> ConfidenceInterval
meanConfidenceInterval sample confidenceLevel =
  let n = length sample
      mean = average sample
      std = stdDev sample
      se = std / sqrt (fromIntegral n)
      z = zScore confidenceLevel
      margin = z * se
  in ConfidenceInterval
    { lowerBound = mean - margin
    , upperBound = mean + margin
    , confidenceLevel = confidenceLevel
    , method = "Normal approximation"
    }
```

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æ¦‚ç‡è®ºåŸºç¡€**: æ¦‚ç‡ç©ºé—´ã€éšæœºå˜é‡ã€æ¦‚ç‡åˆ†å¸ƒ
2. **é‡‡æ ·ç†è®º**: é‡‡æ ·æ–¹æ³•ã€é‡‡æ ·åˆ†å¸ƒã€é‡‡æ ·è¯¯å·®
3. **é‡‡æ ·ç­–ç•¥å»ºæ¨¡**: éšæœºã€å¤´éƒ¨ã€å°¾éƒ¨ã€æ™ºèƒ½é‡‡æ ·
4. **æ€§èƒ½åˆ†æ**: å»¶è¿Ÿåˆ†å¸ƒã€ååé‡åˆ†å¸ƒã€é”™è¯¯ç‡ä¼°è®¡
5. **ç»Ÿè®¡æ¨æ–­**: å‚æ•°ä¼°è®¡ã€å‡è®¾æ£€éªŒã€ç½®ä¿¡åŒºé—´

### åº”ç”¨ä»·å€¼

```text
åº”ç”¨ä»·å€¼:
  â”œâ”€ é‡‡æ ·ç­–ç•¥è®¾è®¡
  â”œâ”€ æ€§èƒ½åˆ†æ
  â”œâ”€ ç»Ÿè®¡æ¨æ–­
  â””â”€ å†³ç­–æ”¯æŒ
```

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ (1,500+ è¡Œ)
**æœ€åæ›´æ–°**: 2025å¹´12æœˆ
**ç»´æŠ¤è€…**: OTLPé¡¹ç›®ç»„
