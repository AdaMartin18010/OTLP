# 状态推理引擎

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第七部分 - 系统状态推理与诊断  

---

## 目录

- [状态推理引擎](#状态推理引擎)
  - [目录](#目录)
  - [概述](#概述)
  - [7.1.1 规则推理引擎](#711-规则推理引擎)
    - [前向链推理](#前向链推理)
    - [后向链推理](#后向链推理)
  - [7.1.2 贝叶斯网络推理](#712-贝叶斯网络推理)
    - [网络构建](#网络构建)
    - [精确推理](#精确推理)
    - [近似推理](#近似推理)
  - [7.1.3 马尔可夫决策过程](#713-马尔可夫决策过程)
    - [状态转移](#状态转移)
    - [价值迭代](#价值迭代)
    - [策略迭代](#策略迭代)
  - [7.1.4 模糊逻辑推理](#714-模糊逻辑推理)
    - [模糊化](#模糊化)
    - [推理规则](#推理规则)
    - [去模糊化](#去模糊化)
  - [总结](#总结)

---

## 概述

本文档介绍OTLP的状态推理引擎，包括规则推理、贝叶斯推理、马尔可夫决策和模糊逻辑。

---

## 7.1.1 规则推理引擎

### 前向链推理

**数据驱动推理**：

```go
// 规则推理引擎
type RuleEngine struct {
    rules      []Rule
    facts      map[string]bool
    workingMem map[string]interface{}
}

type Rule struct {
    ID         string
    Conditions []Condition
    Actions    []Action
    Priority   int
    Enabled    bool
}

type Condition struct {
    Fact     string
    Operator string
    Value    interface{}
}

type Action struct {
    Type   string
    Target string
    Value  interface{}
}

// 前向链推理（Forward Chaining）
func (re *RuleEngine) ForwardChain() []Action {
    executedActions := []Action{}
    changed := true
    
    // 迭代直到没有新规则触发
    for changed {
        changed = false
        
        // 按优先级排序规则
        sort.Slice(re.rules, func(i, j int) bool {
            return re.rules[i].Priority > re.rules[j].Priority
        })
        
        for _, rule := range re.rules {
            if !rule.Enabled {
                continue
            }
            
            // 检查规则条件
            if re.evaluateConditions(rule.Conditions) {
                // 执行动作
                for _, action := range rule.Actions {
                    re.executeAction(action)
                    executedActions = append(executedActions, action)
                }
                
                // 标记有变化
                changed = true
                
                // 禁用已触发的规则（避免重复）
                rule.Enabled = false
            }
        }
    }
    
    return executedActions
}

func (re *RuleEngine) evaluateConditions(conditions []Condition) bool {
    for _, cond := range conditions {
        if !re.evaluateCondition(cond) {
            return false
        }
    }
    return true
}

func (re *RuleEngine) evaluateCondition(cond Condition) bool {
    // 从工作内存获取事实
    value, exists := re.workingMem[cond.Fact]
    if !exists {
        return false
    }
    
    // 根据操作符评估
    switch cond.Operator {
    case "==":
        return value == cond.Value
    case "!=":
        return value != cond.Value
    case ">":
        return re.compare(value, cond.Value) > 0
    case "<":
        return re.compare(value, cond.Value) < 0
    case ">=":
        return re.compare(value, cond.Value) >= 0
    case "<=":
        return re.compare(value, cond.Value) <= 0
    case "contains":
        return re.contains(value, cond.Value)
    default:
        return false
    }
}

func (re *RuleEngine) executeAction(action Action) {
    switch action.Type {
    case "assert":
        // 添加新事实
        re.workingMem[action.Target] = action.Value
        
    case "retract":
        // 删除事实
        delete(re.workingMem, action.Target)
        
    case "modify":
        // 修改事实
        re.workingMem[action.Target] = action.Value
        
    case "alert":
        // 触发告警
        re.triggerAlert(action.Target, action.Value)
        
    case "execute":
        // 执行外部命令
        re.executeCommand(action.Target, action.Value)
    }
}
```

### 后向链推理

**目标驱动推理**：

```go
// 后向链推理（Backward Chaining）
func (re *RuleEngine) BackwardChain(goal string) bool {
    // 检查目标是否已知
    if _, exists := re.workingMem[goal]; exists {
        return true
    }
    
    // 查找可以推导出目标的规则
    for _, rule := range re.rules {
        if !rule.Enabled {
            continue
        }
        
        // 检查规则是否产生目标
        if re.ruleProduces(rule, goal) {
            // 递归验证所有前提
            allSatisfied := true
            
            for _, cond := range rule.Conditions {
                if !re.BackwardChain(cond.Fact) {
                    allSatisfied = false
                    break
                }
            }
            
            if allSatisfied {
                // 执行规则动作
                for _, action := range rule.Actions {
                    re.executeAction(action)
                }
                return true
            }
        }
    }
    
    return false
}

func (re *RuleEngine) ruleProduces(rule Rule, goal string) bool {
    for _, action := range rule.Actions {
        if action.Type == "assert" && action.Target == goal {
            return true
        }
    }
    return false
}
```

**OTLP规则示例**：

```go
// OTLP智能运维规则
func (re *RuleEngine) LoadOTLPRules() {
    // 规则1：高错误率检测
    re.AddRule(Rule{
        ID:       "high_error_rate",
        Priority: 100,
        Conditions: []Condition{
            {Fact: "error_rate", Operator: ">", Value: 0.05},
            {Fact: "duration", Operator: ">", Value: 60},
        },
        Actions: []Action{
            {Type: "assert", Target: "service_degraded", Value: true},
            {Type: "alert", Target: "ops_team", Value: "High error rate detected"},
        },
        Enabled: true,
    })
    
    // 规则2：级联故障检测
    re.AddRule(Rule{
        ID:       "cascade_failure",
        Priority: 90,
        Conditions: []Condition{
            {Fact: "service_degraded", Operator: "==", Value: true},
            {Fact: "downstream_errors", Operator: ">", Value: 10},
        },
        Actions: []Action{
            {Type: "assert", Target: "cascade_failure", Value: true},
            {Type: "execute", Target: "circuit_breaker", Value: "open"},
        },
        Enabled: true,
    })
    
    // 规则3：自动扩容
    re.AddRule(Rule{
        ID:       "auto_scale_up",
        Priority: 80,
        Conditions: []Condition{
            {Fact: "cpu_usage", Operator: ">", Value: 0.8},
            {Fact: "memory_usage", Operator: ">", Value: 0.75},
            {Fact: "request_rate", Operator: ">", Value: 1000},
        },
        Actions: []Action{
            {Type: "execute", Target: "scale_up", Value: 2},
            {Type: "alert", Target: "ops_team", Value: "Auto scaling triggered"},
        },
        Enabled: true,
    })
    
    // 规则4：慢查询优化
    re.AddRule(Rule{
        ID:       "slow_query_optimization",
        Priority: 70,
        Conditions: []Condition{
            {Fact: "db_query_time", Operator: ">", Value: 1000}, // ms
            {Fact: "query_count", Operator: ">", Value: 100},
        },
        Actions: []Action{
            {Type: "assert", Target: "slow_query_detected", Value: true},
            {Type: "execute", Target: "enable_cache", Value: true},
        },
        Enabled: true,
    })
}
```

---

## 7.1.2 贝叶斯网络推理

### 网络构建

**概率图模型**：

```go
// 贝叶斯网络
type BayesianNetwork struct {
    nodes map[string]*BayesNode
    edges map[string][]string
}

type BayesNode struct {
    Name   string
    States []string
    CPT    ConditionalProbabilityTable
}

type ConditionalProbabilityTable struct {
    Parents []string
    Table   map[string]float64
}

func NewBayesianNetwork() *BayesianNetwork {
    return &BayesianNetwork{
        nodes: make(map[string]*BayesNode),
        edges: make(map[string][]string),
    }
}

func (bn *BayesianNetwork) AddNode(node *BayesNode) {
    bn.nodes[node.Name] = node
}

func (bn *BayesianNetwork) AddEdge(parent, child string) {
    bn.edges[parent] = append(bn.edges[parent], child)
}

// OTLP故障诊断贝叶斯网络
func BuildOTLPDiagnosticNetwork() *BayesianNetwork {
    bn := NewBayesianNetwork()
    
    // 节点1：网络故障
    networkFailure := &BayesNode{
        Name:   "network_failure",
        States: []string{"true", "false"},
        CPT: ConditionalProbabilityTable{
            Parents: []string{},
            Table: map[string]float64{
                "true":  0.01, // 先验概率
                "false": 0.99,
            },
        },
    }
    bn.AddNode(networkFailure)
    
    // 节点2：服务故障
    serviceFailure := &BayesNode{
        Name:   "service_failure",
        States: []string{"true", "false"},
        CPT: ConditionalProbabilityTable{
            Parents: []string{},
            Table: map[string]float64{
                "true":  0.02,
                "false": 0.98,
            },
        },
    }
    bn.AddNode(serviceFailure)
    
    // 节点3：高延迟（依赖网络和服务）
    highLatency := &BayesNode{
        Name:   "high_latency",
        States: []string{"true", "false"},
        CPT: ConditionalProbabilityTable{
            Parents: []string{"network_failure", "service_failure"},
            Table: map[string]float64{
                // P(high_latency | network_failure, service_failure)
                "true,true,true":    0.95,
                "true,true,false":   0.05,
                "true,false,true":   0.80,
                "true,false,false":  0.20,
                "false,true,true":   0.70,
                "false,true,false":  0.30,
                "false,false,true":  0.10,
                "false,false,false": 0.90,
            },
        },
    }
    bn.AddNode(highLatency)
    
    // 节点4：错误率（依赖服务故障）
    errorRate := &BayesNode{
        Name:   "high_error_rate",
        States: []string{"true", "false"},
        CPT: ConditionalProbabilityTable{
            Parents: []string{"service_failure"},
            Table: map[string]float64{
                "true,true":    0.90,
                "true,false":   0.10,
                "false,true":   0.05,
                "false,false":  0.95,
            },
        },
    }
    bn.AddNode(errorRate)
    
    // 添加边
    bn.AddEdge("network_failure", "high_latency")
    bn.AddEdge("service_failure", "high_latency")
    bn.AddEdge("service_failure", "high_error_rate")
    
    return bn
}
```

### 精确推理

**变量消除算法**：

```go
// 变量消除推理
func (bn *BayesianNetwork) VariableElimination(
    query string,
    evidence map[string]string,
) map[string]float64 {
    // 1. 收集所有相关因子
    factors := bn.collectFactors(query, evidence)
    
    // 2. 确定消除顺序
    eliminationOrder := bn.getEliminationOrder(query, evidence)
    
    // 3. 逐个消除变量
    for _, variable := range eliminationOrder {
        // 找到包含该变量的所有因子
        relevantFactors := []Factor{}
        remainingFactors := []Factor{}
        
        for _, factor := range factors {
            if factor.contains(variable) {
                relevantFactors = append(relevantFactors, factor)
            } else {
                remainingFactors = append(remainingFactors, factor)
            }
        }
        
        // 乘积
        product := bn.multiplyFactors(relevantFactors)
        
        // 求和消除变量
        summedOut := bn.sumOut(product, variable)
        
        // 更新因子列表
        factors = append(remainingFactors, summedOut)
    }
    
    // 4. 最终因子相乘
    result := bn.multiplyFactors(factors)
    
    // 5. 归一化
    return bn.normalize(result)
}

type Factor struct {
    Variables []string
    Values    map[string]float64
}

func (f *Factor) contains(variable string) bool {
    for _, v := range f.Variables {
        if v == variable {
            return true
        }
    }
    return false
}

func (bn *BayesianNetwork) multiplyFactors(factors []Factor) Factor {
    if len(factors) == 0 {
        return Factor{}
    }
    
    result := factors[0]
    for i := 1; i < len(factors); i++ {
        result = bn.multiplyTwoFactors(result, factors[i])
    }
    
    return result
}

func (bn *BayesianNetwork) sumOut(factor Factor, variable string) Factor {
    // 移除变量
    newVars := []string{}
    for _, v := range factor.Variables {
        if v != variable {
            newVars = append(newVars, v)
        }
    }
    
    // 对该变量的所有值求和
    newValues := make(map[string]float64)
    
    for key, value := range factor.Values {
        // 移除变量部分
        newKey := bn.removeVariable(key, variable)
        newValues[newKey] += value
    }
    
    return Factor{
        Variables: newVars,
        Values:    newValues,
    }
}
```

### 近似推理

**吉布斯采样**：

```go
// 吉布斯采样（Gibbs Sampling）
type GibbsSampler struct {
    network    *BayesianNetwork
    numSamples int
    burnIn     int
}

func (gs *GibbsSampler) Infer(
    query string,
    evidence map[string]string,
) map[string]float64 {
    // 1. 初始化：随机赋值非证据变量
    state := gs.initializeState(evidence)
    
    // 2. Burn-in期
    for i := 0; i < gs.burnIn; i++ {
        state = gs.sampleNext(state, evidence)
    }
    
    // 3. 收集样本
    samples := make(map[string]int)
    
    for i := 0; i < gs.numSamples; i++ {
        state = gs.sampleNext(state, evidence)
        
        // 记录查询变量的值
        queryValue := state[query]
        samples[queryValue]++
    }
    
    // 4. 计算概率
    result := make(map[string]float64)
    total := float64(gs.numSamples)
    
    for value, count := range samples {
        result[value] = float64(count) / total
    }
    
    return result
}

func (gs *GibbsSampler) sampleNext(
    state map[string]string,
    evidence map[string]string,
) map[string]string {
    newState := make(map[string]string)
    for k, v := range state {
        newState[k] = v
    }
    
    // 对每个非证据变量采样
    for variable := range gs.network.nodes {
        if _, isEvidence := evidence[variable]; isEvidence {
            continue
        }
        
        // 根据马尔可夫毯采样
        newState[variable] = gs.sampleFromMarkovBlanket(variable, newState)
    }
    
    return newState
}

func (gs *GibbsSampler) sampleFromMarkovBlanket(
    variable string,
    state map[string]string,
) string {
    node := gs.network.nodes[variable]
    
    // 计算每个状态的概率
    probs := make(map[string]float64)
    
    for _, stateValue := range node.States {
        // P(X | MB(X)) ∝ P(X | Parents(X)) * Π P(Child | Parents(Child))
        prob := gs.calculateConditionalProb(variable, stateValue, state)
        probs[stateValue] = prob
    }
    
    // 归一化
    total := 0.0
    for _, p := range probs {
        total += p
    }
    for k := range probs {
        probs[k] /= total
    }
    
    // 采样
    return gs.weightedRandomChoice(probs)
}
```

---

## 7.1.3 马尔可夫决策过程

### 状态转移

**MDP建模**：

```go
// 马尔可夫决策过程
type MDP struct {
    States      []string
    Actions     []string
    Transitions map[string]map[string]map[string]float64 // [state][action][next_state] = prob
    Rewards     map[string]map[string]float64            // [state][action] = reward
    Gamma       float64                                   // 折扣因子
}

func BuildOTLPMDP() *MDP {
    mdp := &MDP{
        States: []string{
            "normal",
            "high_load",
            "degraded",
            "failed",
        },
        Actions: []string{
            "do_nothing",
            "scale_up",
            "restart",
            "circuit_break",
        },
        Transitions: make(map[string]map[string]map[string]float64),
        Rewards:     make(map[string]map[string]float64),
        Gamma:       0.9,
    }
    
    // 定义状态转移概率
    // normal状态
    mdp.Transitions["normal"] = map[string]map[string]float64{
        "do_nothing": {
            "normal":    0.90,
            "high_load": 0.10,
        },
        "scale_up": {
            "normal": 1.0,
        },
    }
    
    // high_load状态
    mdp.Transitions["high_load"] = map[string]map[string]float64{
        "do_nothing": {
            "high_load": 0.50,
            "degraded":  0.40,
            "normal":    0.10,
        },
        "scale_up": {
            "normal":    0.80,
            "high_load": 0.20,
        },
    }
    
    // degraded状态
    mdp.Transitions["degraded"] = map[string]map[string]float64{
        "do_nothing": {
            "degraded": 0.60,
            "failed":   0.40,
        },
        "restart": {
            "normal":   0.70,
            "degraded": 0.30,
        },
        "circuit_break": {
            "normal":   0.50,
            "degraded": 0.50,
        },
    }
    
    // 定义奖励
    mdp.Rewards["normal"] = map[string]float64{
        "do_nothing": 10.0,
        "scale_up":   5.0, // 扩容有成本
    }
    
    mdp.Rewards["high_load"] = map[string]float64{
        "do_nothing": -5.0,
        "scale_up":   0.0,
    }
    
    mdp.Rewards["degraded"] = map[string]float64{
        "do_nothing":    -20.0,
        "restart":       -10.0,
        "circuit_break": -5.0,
    }
    
    mdp.Rewards["failed"] = map[string]float64{
        "restart": -50.0,
    }
    
    return mdp
}
```

### 价值迭代

**动态规划求解**：

```go
// 价值迭代算法
func (mdp *MDP) ValueIteration(epsilon float64) map[string]float64 {
    // 初始化价值函数
    V := make(map[string]float64)
    for _, state := range mdp.States {
        V[state] = 0.0
    }
    
    // 迭代更新
    for {
        delta := 0.0
        
        for _, state := range mdp.States {
            oldValue := V[state]
            
            // 计算所有动作的Q值
            maxQ := math.Inf(-1)
            
            for _, action := range mdp.Actions {
                q := mdp.calculateQ(state, action, V)
                if q > maxQ {
                    maxQ = q
                }
            }
            
            V[state] = maxQ
            delta = math.Max(delta, math.Abs(oldValue-V[state]))
        }
        
        // 收敛判断
        if delta < epsilon {
            break
        }
    }
    
    return V
}

func (mdp *MDP) calculateQ(
    state, action string,
    V map[string]float64,
) float64 {
    // Q(s,a) = R(s,a) + γ Σ P(s'|s,a) V(s')
    reward := mdp.Rewards[state][action]
    
    expectedValue := 0.0
    if transitions, exists := mdp.Transitions[state][action]; exists {
        for nextState, prob := range transitions {
            expectedValue += prob * V[nextState]
        }
    }
    
    return reward + mdp.Gamma*expectedValue
}
```

### 策略迭代

**策略优化**：

```go
// 策略迭代算法
func (mdp *MDP) PolicyIteration(epsilon float64) map[string]string {
    // 初始化随机策略
    policy := make(map[string]string)
    for _, state := range mdp.States {
        policy[state] = mdp.Actions[0]
    }
    
    for {
        // 策略评估
        V := mdp.policyEvaluation(policy, epsilon)
        
        // 策略改进
        policyStable := true
        
        for _, state := range mdp.States {
            oldAction := policy[state]
            
            // 选择最优动作
            bestAction := ""
            maxQ := math.Inf(-1)
            
            for _, action := range mdp.Actions {
                q := mdp.calculateQ(state, action, V)
                if q > maxQ {
                    maxQ = q
                    bestAction = action
                }
            }
            
            policy[state] = bestAction
            
            if oldAction != bestAction {
                policyStable = false
            }
        }
        
        // 策略稳定则终止
        if policyStable {
            break
        }
    }
    
    return policy
}

func (mdp *MDP) policyEvaluation(
    policy map[string]string,
    epsilon float64,
) map[string]float64 {
    V := make(map[string]float64)
    
    for {
        delta := 0.0
        
        for _, state := range mdp.States {
            oldValue := V[state]
            action := policy[state]
            
            V[state] = mdp.calculateQ(state, action, V)
            delta = math.Max(delta, math.Abs(oldValue-V[state]))
        }
        
        if delta < epsilon {
            break
        }
    }
    
    return V
}
```

---

## 7.1.4 模糊逻辑推理

### 模糊化

**隶属度函数**：

```go
// 模糊逻辑系统
type FuzzySystem struct {
    variables map[string]*FuzzyVariable
    rules     []FuzzyRule
}

type FuzzyVariable struct {
    Name string
    Sets map[string]MembershipFunction
}

type MembershipFunction interface {
    Evaluate(x float64) float64
}

// 三角形隶属函数
type TriangularMF struct {
    A, B, C float64
}

func (t *TriangularMF) Evaluate(x float64) float64 {
    if x <= t.A || x >= t.C {
        return 0
    }
    if x == t.B {
        return 1
    }
    if x < t.B {
        return (x - t.A) / (t.B - t.A)
    }
    return (t.C - x) / (t.C - t.B)
}

// 梯形隶属函数
type TrapezoidalMF struct {
    A, B, C, D float64
}

func (t *TrapezoidalMF) Evaluate(x float64) float64 {
    if x <= t.A || x >= t.D {
        return 0
    }
    if x >= t.B && x <= t.C {
        return 1
    }
    if x < t.B {
        return (x - t.A) / (t.B - t.A)
    }
    return (t.D - x) / (t.D - t.C)
}

// OTLP模糊系统
func BuildOTLPFuzzySystem() *FuzzySystem {
    fs := &FuzzySystem{
        variables: make(map[string]*FuzzyVariable),
    }
    
    // 输入变量1：CPU使用率
    cpuVar := &FuzzyVariable{
        Name: "cpu_usage",
        Sets: map[string]MembershipFunction{
            "low":    &TriangularMF{A: 0, B: 0, C: 50},
            "medium": &TriangularMF{A: 30, B: 50, C: 70},
            "high":   &TriangularMF{A: 50, B: 100, C: 100},
        },
    }
    fs.variables["cpu_usage"] = cpuVar
    
    // 输入变量2：响应时间
    responseVar := &FuzzyVariable{
        Name: "response_time",
        Sets: map[string]MembershipFunction{
            "fast":   &TriangularMF{A: 0, B: 0, C: 200},
            "normal": &TriangularMF{A: 100, B: 300, C: 500},
            "slow":   &TriangularMF{A: 400, B: 1000, C: 1000},
        },
    }
    fs.variables["response_time"] = responseVar
    
    // 输出变量：扩容级别
    scaleVar := &FuzzyVariable{
        Name: "scale_level",
        Sets: map[string]MembershipFunction{
            "none":   &TriangularMF{A: 0, B: 0, C: 2},
            "small":  &TriangularMF{A: 1, B: 2, C: 3},
            "medium": &TriangularMF{A: 2, B: 4, C: 6},
            "large":  &TriangularMF{A: 5, B: 8, C: 8},
        },
    }
    fs.variables["scale_level"] = scaleVar
    
    return fs
}
```

### 推理规则

**模糊规则库**：

```go
type FuzzyRule struct {
    Antecedents []FuzzyClause
    Consequent  FuzzyClause
}

type FuzzyClause struct {
    Variable string
    Set      string
}

func (fs *FuzzySystem) AddRules() {
    fs.rules = []FuzzyRule{
        // 规则1: IF cpu is low AND response_time is fast THEN scale is none
        {
            Antecedents: []FuzzyClause{
                {Variable: "cpu_usage", Set: "low"},
                {Variable: "response_time", Set: "fast"},
            },
            Consequent: FuzzyClause{Variable: "scale_level", Set: "none"},
        },
        
        // 规则2: IF cpu is medium AND response_time is normal THEN scale is small
        {
            Antecedents: []FuzzyClause{
                {Variable: "cpu_usage", Set: "medium"},
                {Variable: "response_time", Set: "normal"},
            },
            Consequent: FuzzyClause{Variable: "scale_level", Set: "small"},
        },
        
        // 规则3: IF cpu is high OR response_time is slow THEN scale is medium
        {
            Antecedents: []FuzzyClause{
                {Variable: "cpu_usage", Set: "high"},
                {Variable: "response_time", Set: "slow"},
            },
            Consequent: FuzzyClause{Variable: "scale_level", Set: "medium"},
        },
        
        // 规则4: IF cpu is high AND response_time is slow THEN scale is large
        {
            Antecedents: []FuzzyClause{
                {Variable: "cpu_usage", Set: "high"},
                {Variable: "response_time", Set: "slow"},
            },
            Consequent: FuzzyClause{Variable: "scale_level", Set: "large"},
        },
    }
}
```

### 去模糊化

**输出清晰值**：

```go
// 模糊推理
func (fs *FuzzySystem) Infer(inputs map[string]float64) float64 {
    // 1. 模糊化
    fuzzified := fs.fuzzify(inputs)
    
    // 2. 规则评估
    ruleOutputs := []RuleOutput{}
    
    for _, rule := range fs.rules {
        // 计算规则激活度
        activation := fs.evaluateRule(rule, fuzzified)
        
        if activation > 0 {
            ruleOutputs = append(ruleOutputs, RuleOutput{
                Set:        rule.Consequent.Set,
                Activation: activation,
            })
        }
    }
    
    // 3. 去模糊化（重心法）
    return fs.defuzzify(ruleOutputs, "scale_level")
}

type RuleOutput struct {
    Set        string
    Activation float64
}

func (fs *FuzzySystem) fuzzify(
    inputs map[string]float64,
) map[string]map[string]float64 {
    result := make(map[string]map[string]float64)
    
    for varName, value := range inputs {
        variable := fs.variables[varName]
        result[varName] = make(map[string]float64)
        
        for setName, mf := range variable.Sets {
            result[varName][setName] = mf.Evaluate(value)
        }
    }
    
    return result
}

func (fs *FuzzySystem) evaluateRule(
    rule FuzzyRule,
    fuzzified map[string]map[string]float64,
) float64 {
    // 使用最小值作为AND操作
    activation := 1.0
    
    for _, clause := range rule.Antecedents {
        membership := fuzzified[clause.Variable][clause.Set]
        if membership < activation {
            activation = membership
        }
    }
    
    return activation
}

func (fs *FuzzySystem) defuzzify(
    outputs []RuleOutput,
    outputVar string,
) float64 {
    // 重心法（Centroid）
    variable := fs.variables[outputVar]
    
    numerator := 0.0
    denominator := 0.0
    
    // 对每个输出集合
    for _, output := range outputs {
        mf := variable.Sets[output.Set]
        
        // 采样计算重心
        for x := 0.0; x <= 10.0; x += 0.1 {
            membership := math.Min(mf.Evaluate(x), output.Activation)
            numerator += x * membership
            denominator += membership
        }
    }
    
    if denominator == 0 {
        return 0
    }
    
    return numerator / denominator
}
```

---

## 总结

状态推理引擎核心技术：

**规则推理**：

- 前向链：数据驱动
- 后向链：目标驱动
- 适合确定性推理

**贝叶斯推理**：

- 概率图模型
- 精确推理：变量消除
- 近似推理：吉布斯采样
- 处理不确定性

**马尔可夫决策**：

- 状态转移建模
- 价值迭代：最优价值
- 策略迭代：最优策略
- 序贯决策

**模糊逻辑**：

- 隶属度函数
- 模糊规则库
- 去模糊化
- 处理模糊性

**最佳实践**：

- 多引擎融合
- 知识库维护
- 推理可解释
- 在线学习更新

---

**上一篇**: [19_异常模式识别.md](19_异常模式识别.md)  
**下一篇**: [21_根因分析算法.md](21_根因分析算法.md)

---

*最后更新: 2025年10月7日*-
