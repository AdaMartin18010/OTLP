# 协议一致性证明

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第八部分 - 形式化模型集成  

---

## 目录

- [协议一致性证明](#协议一致性证明)
  - [目录](#目录)
  - [概述](#概述)
  - [8.2.1 分布式一致性模型](#821-分布式一致性模型)
    - [强一致性](#强一致性)
    - [最终一致性](#最终一致性)
    - [因果一致性](#因果一致性)
  - [8.2.2 OTLP协议一致性](#822-otlp协议一致性)
    - [Span顺序一致性](#span顺序一致性)
    - [Trace完整性](#trace完整性)
    - [时间戳一致性](#时间戳一致性)
  - [8.2.3 一致性证明方法](#823-一致性证明方法)
    - [Lamport时钟证明](#lamport时钟证明)
    - [Vector时钟证明](#vector时钟证明)
    - [Happens-Before关系](#happens-before关系)
  - [8.2.4 实现验证](#824-实现验证)
    - [一致性检查器](#一致性检查器)
    - [违规检测](#违规检测)
    - [修复策略](#修复策略)
  - [总结](#总结)

---

## 概述

本文档介绍OTLP协议的一致性证明，包括分布式一致性模型、协议特性和验证方法。

---

## 8.2.1 分布式一致性模型

### 强一致性

**线性一致性（Linearizability）**：

```go
// 线性一致性验证器
type LinearizabilityChecker struct {
    operations []Operation
    history    *History
}

type Operation struct {
    Type      string // "read", "write"
    Key       string
    Value     interface{}
    StartTime time.Time
    EndTime   time.Time
    ClientID  string
}

type History struct {
    Operations []Operation
    Ordering   []int // 线性化顺序
}

func (lc *LinearizabilityChecker) Check() bool {
    // 尝试找到一个线性化顺序
    permutations := lc.generatePermutations()
    
    for _, perm := range permutations {
        if lc.isValidLinearization(perm) {
            lc.history.Ordering = perm
            return true
        }
    }
    
    return false
}

func (lc *LinearizabilityChecker) isValidLinearization(
    ordering []int,
) bool {
    // 1. 检查实时顺序约束
    for i := 0; i < len(ordering); i++ {
        for j := i + 1; j < len(ordering); j++ {
            op1 := lc.operations[ordering[i]]
            op2 := lc.operations[ordering[j]]
            
            // 如果op1在op2开始前完成，顺序必须保持
            if op1.EndTime.Before(op2.StartTime) {
                // OK: 顺序正确
            } else if op2.EndTime.Before(op1.StartTime) {
                // 违反实时顺序
                return false
            }
        }
    }
    
    // 2. 检查读写一致性
    state := make(map[string]interface{})
    
    for _, idx := range ordering {
        op := lc.operations[idx]
        
        switch op.Type {
        case "write":
            state[op.Key] = op.Value
            
        case "read":
            expectedValue := state[op.Key]
            if !reflect.DeepEqual(expectedValue, op.Value) {
                return false
            }
        }
    }
    
    return true
}
```

### 最终一致性

**最终一致性模型**：

```go
// 最终一致性验证器
type EventualConsistencyChecker struct {
    replicas       map[string]*Replica
    updateHistory  []Update
    convergenceTime time.Duration
}

type Replica struct {
    ID    string
    State map[string]interface{}
    Clock VectorClock
}

type Update struct {
    Key       string
    Value     interface{}
    Timestamp time.Time
    ReplicaID string
}

type VectorClock map[string]int

func (ecc *EventualConsistencyChecker) Check() bool {
    // 应用所有更新
    for _, update := range ecc.updateHistory {
        replica := ecc.replicas[update.ReplicaID]
        replica.State[update.Key] = update.Value
        replica.Clock[update.ReplicaID]++
    }
    
    // 模拟传播
    ecc.propagateUpdates()
    
    // 检查最终状态一致性
    return ecc.checkConvergence()
}

func (ecc *EventualConsistencyChecker) propagateUpdates() {
    // 模拟gossip协议传播
    maxRounds := 100
    
    for round := 0; round < maxRounds; round++ {
        changed := false
        
        // 每个副本与随机副本交换状态
        for _, replica1 := range ecc.replicas {
            for _, replica2 := range ecc.replicas {
                if replica1.ID == replica2.ID {
                    continue
                }
                
                // 合并状态
                if ecc.mergeStates(replica1, replica2) {
                    changed = true
                }
            }
        }
        
        if !changed {
            break
        }
    }
}

func (ecc *EventualConsistencyChecker) mergeStates(
    r1, r2 *Replica,
) bool {
    changed := false
    
    // 使用向量时钟解决冲突
    for key, value2 := range r2.State {
        value1, exists := r1.State[key]
        
        if !exists {
            r1.State[key] = value2
            changed = true
        } else if ecc.compareVectorClocks(r2.Clock, r1.Clock) > 0 {
            r1.State[key] = value2
            changed = true
        }
    }
    
    // 更新向量时钟
    for id, count := range r2.Clock {
        if count > r1.Clock[id] {
            r1.Clock[id] = count
            changed = true
        }
    }
    
    return changed
}

func (ecc *EventualConsistencyChecker) checkConvergence() bool {
    // 检查所有副本状态是否一致
    var referenceState map[string]interface{}
    
    for _, replica := range ecc.replicas {
        if referenceState == nil {
            referenceState = replica.State
        } else {
            if !reflect.DeepEqual(referenceState, replica.State) {
                return false
            }
        }
    }
    
    return true
}
```

### 因果一致性

**因果一致性验证**：

```go
// 因果一致性检查器
type CausalConsistencyChecker struct {
    operations []CausalOperation
    causalGraph *CausalGraph
}

type CausalOperation struct {
    ID            string
    Type          string
    Key           string
    Value         interface{}
    Dependencies  []string // 依赖的操作ID
    VectorClock   VectorClock
}

type CausalGraph struct {
    Nodes map[string]*CausalOperation
    Edges map[string][]string
}

func (ccc *CausalConsistencyChecker) Check() bool {
    // 构建因果图
    ccc.buildCausalGraph()
    
    // 检查因果顺序
    return ccc.verifyCausalOrder()
}

func (ccc *CausalConsistencyChecker) buildCausalGraph() {
    ccc.causalGraph = &CausalGraph{
        Nodes: make(map[string]*CausalOperation),
        Edges: make(map[string][]string),
    }
    
    for i := range ccc.operations {
        op := &ccc.operations[i]
        ccc.causalGraph.Nodes[op.ID] = op
        
        // 添加依赖边
        for _, depID := range op.Dependencies {
            ccc.causalGraph.Edges[depID] = append(
                ccc.causalGraph.Edges[depID],
                op.ID,
            )
        }
    }
}

func (ccc *CausalConsistencyChecker) verifyCausalOrder() bool {
    // 拓扑排序验证
    visited := make(map[string]bool)
    recStack := make(map[string]bool)
    
    for opID := range ccc.causalGraph.Nodes {
        if !visited[opID] {
            if ccc.hasCycle(opID, visited, recStack) {
                fmt.Println("Causal cycle detected")
                return false
            }
        }
    }
    
    // 检查向量时钟一致性
    return ccc.checkVectorClockConsistency()
}

func (ccc *CausalConsistencyChecker) hasCycle(
    opID string,
    visited, recStack map[string]bool,
) bool {
    visited[opID] = true
    recStack[opID] = true
    
    for _, nextID := range ccc.causalGraph.Edges[opID] {
        if !visited[nextID] {
            if ccc.hasCycle(nextID, visited, recStack) {
                return true
            }
        } else if recStack[nextID] {
            return true
        }
    }
    
    recStack[opID] = false
    return false
}

func (ccc *CausalConsistencyChecker) checkVectorClockConsistency() bool {
    for _, op := range ccc.operations {
        for _, depID := range op.Dependencies {
            depOp := ccc.causalGraph.Nodes[depID]
            
            // 依赖操作的向量时钟必须小于当前操作
            if !ccc.vectorClockLessThan(depOp.VectorClock, op.VectorClock) {
                fmt.Printf(
                    "Vector clock inconsistency: %s -> %s\n",
                    depID,
                    op.ID,
                )
                return false
            }
        }
    }
    
    return true
}

func (ccc *CausalConsistencyChecker) vectorClockLessThan(
    vc1, vc2 VectorClock,
) bool {
    for id, count1 := range vc1 {
        count2 := vc2[id]
        if count1 > count2 {
            return false
        }
    }
    return true
}
```

---

## 8.2.2 OTLP协议一致性

### Span顺序一致性

**Span顺序验证**：

```go
// OTLP Span顺序一致性检查器
type SpanOrderChecker struct {
    spans []OTLPSpan
}

type OTLPSpan struct {
    SpanID       string
    TraceID      string
    ParentSpanID string
    StartTime    time.Time
    EndTime      time.Time
    Events       []SpanEvent
}

type SpanEvent struct {
    Name      string
    Timestamp time.Time
}

func (soc *SpanOrderChecker) CheckOrderConsistency() []Violation {
    violations := []Violation{}
    
    // 按TraceID分组
    traceSpans := soc.groupByTrace()
    
    for traceID, spans := range traceSpans {
        // 检查父子关系时间顺序
        violations = append(
            violations,
            soc.checkParentChildOrder(traceID, spans)...,
        )
        
        // 检查事件顺序
        violations = append(
            violations,
            soc.checkEventOrder(traceID, spans)...,
        )
    }
    
    return violations
}

type Violation struct {
    Type        string
    TraceID     string
    SpanID      string
    Description string
}

func (soc *SpanOrderChecker) checkParentChildOrder(
    traceID string,
    spans []OTLPSpan,
) []Violation {
    violations := []Violation{}
    spanMap := make(map[string]*OTLPSpan)
    
    for i := range spans {
        spanMap[spans[i].SpanID] = &spans[i]
    }
    
    for _, span := range spans {
        if span.ParentSpanID == "" {
            continue
        }
        
        parent := spanMap[span.ParentSpanID]
        if parent == nil {
            violations = append(violations, Violation{
                Type:        "missing_parent",
                TraceID:     traceID,
                SpanID:      span.SpanID,
                Description: fmt.Sprintf("Parent span %s not found", span.ParentSpanID),
            })
            continue
        }
        
        // 父Span必须在子Span之前开始
        if parent.StartTime.After(span.StartTime) {
            violations = append(violations, Violation{
                Type:        "parent_after_child",
                TraceID:     traceID,
                SpanID:      span.SpanID,
                Description: "Parent span starts after child span",
            })
        }
        
        // 父Span必须在子Span之后结束
        if parent.EndTime.Before(span.EndTime) {
            violations = append(violations, Violation{
                Type:        "parent_before_child",
                TraceID:     traceID,
                SpanID:      span.SpanID,
                Description: "Parent span ends before child span",
            })
        }
    }
    
    return violations
}

func (soc *SpanOrderChecker) checkEventOrder(
    traceID string,
    spans []OTLPSpan,
) []Violation {
    violations := []Violation{}
    
    for _, span := range spans {
        // 事件必须在Span时间范围内
        for _, event := range span.Events {
            if event.Timestamp.Before(span.StartTime) ||
                event.Timestamp.After(span.EndTime) {
                violations = append(violations, Violation{
                    Type:    "event_out_of_span",
                    TraceID: traceID,
                    SpanID:  span.SpanID,
                    Description: fmt.Sprintf(
                        "Event %s timestamp out of span range",
                        event.Name,
                    ),
                })
            }
        }
        
        // 事件必须按时间顺序
        for i := 1; i < len(span.Events); i++ {
            if span.Events[i].Timestamp.Before(span.Events[i-1].Timestamp) {
                violations = append(violations, Violation{
                    Type:        "event_order_violation",
                    TraceID:     traceID,
                    SpanID:      span.SpanID,
                    Description: "Events not in chronological order",
                })
                break
            }
        }
    }
    
    return violations
}
```

### Trace完整性

**Trace完整性验证**：

```go
// Trace完整性检查器
type TraceCompletenessChecker struct {
    traces map[string]*Trace
}

type Trace struct {
    TraceID string
    Spans   []*OTLPSpan
    RootSpan *OTLPSpan
}

func (tcc *TraceCompletenessChecker) CheckCompleteness() []CompletenessIssue {
    issues := []CompletenessIssue{}
    
    for traceID, trace := range tcc.traces {
        // 检查根Span
        if trace.RootSpan == nil {
            issues = append(issues, CompletenessIssue{
                TraceID: traceID,
                Type:    "missing_root",
                Severity: "high",
                Description: "No root span found",
            })
        }
        
        // 检查Span连通性
        if !tcc.isConnected(trace) {
            issues = append(issues, CompletenessIssue{
                TraceID: traceID,
                Type:    "disconnected_spans",
                Severity: "high",
                Description: "Trace contains disconnected spans",
            })
        }
        
        // 检查孤儿Span
        orphans := tcc.findOrphans(trace)
        if len(orphans) > 0 {
            issues = append(issues, CompletenessIssue{
                TraceID: traceID,
                Type:    "orphan_spans",
                Severity: "medium",
                Description: fmt.Sprintf("%d orphan spans found", len(orphans)),
                Details:     orphans,
            })
        }
    }
    
    return issues
}

type CompletenessIssue struct {
    TraceID     string
    Type        string
    Severity    string
    Description string
    Details     interface{}
}

func (tcc *TraceCompletenessChecker) isConnected(trace *Trace) bool {
    if trace.RootSpan == nil {
        return false
    }
    
    // BFS从根节点遍历
    visited := make(map[string]bool)
    queue := []*OTLPSpan{trace.RootSpan}
    visited[trace.RootSpan.SpanID] = true
    
    spanMap := make(map[string]*OTLPSpan)
    for _, span := range trace.Spans {
        spanMap[span.SpanID] = span
    }
    
    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]
        
        // 查找子Span
        for _, span := range trace.Spans {
            if span.ParentSpanID == current.SpanID && !visited[span.SpanID] {
                visited[span.SpanID] = true
                queue = append(queue, span)
            }
        }
    }
    
    // 检查是否所有Span都被访问
    return len(visited) == len(trace.Spans)
}

func (tcc *TraceCompletenessChecker) findOrphans(trace *Trace) []string {
    orphans := []string{}
    spanMap := make(map[string]bool)
    
    for _, span := range trace.Spans {
        spanMap[span.SpanID] = true
    }
    
    for _, span := range trace.Spans {
        if span.ParentSpanID != "" && !spanMap[span.ParentSpanID] {
            orphans = append(orphans, span.SpanID)
        }
    }
    
    return orphans
}
```

### 时间戳一致性

**时间戳一致性验证**：

```go
// 时间戳一致性检查器
type TimestampConsistencyChecker struct {
    clockSkewThreshold time.Duration
}

func (tcc *TimestampConsistencyChecker) CheckTimestamps(
    spans []OTLPSpan,
) []TimestampIssue {
    issues := []TimestampIssue{}
    
    for _, span := range spans {
        // 检查Span时间范围
        if span.EndTime.Before(span.StartTime) {
            issues = append(issues, TimestampIssue{
                SpanID:      span.SpanID,
                Type:        "invalid_duration",
                Description: "End time before start time",
            })
        }
        
        // 检查时钟偏移
        if tcc.detectClockSkew(span) {
            issues = append(issues, TimestampIssue{
                SpanID:      span.SpanID,
                Type:        "clock_skew",
                Description: "Possible clock skew detected",
            })
        }
    }
    
    return issues
}

type TimestampIssue struct {
    SpanID      string
    Type        string
    Description string
}

func (tcc *TimestampConsistencyChecker) detectClockSkew(
    span OTLPSpan,
) bool {
    // 检查事件时间戳是否异常
    for i := 1; i < len(span.Events); i++ {
        diff := span.Events[i].Timestamp.Sub(span.Events[i-1].Timestamp)
        
        // 负时间差或过大的跳跃可能表示时钟偏移
        if diff < 0 || diff > tcc.clockSkewThreshold {
            return true
        }
    }
    
    return false
}
```

---

## 8.2.3 一致性证明方法

### Lamport时钟证明

**Lamport逻辑时钟**：

```go
// Lamport时钟实现
type LamportClock struct {
    timestamp int
    mu        sync.Mutex
}

func (lc *LamportClock) Tick() int {
    lc.mu.Lock()
    defer lc.mu.Unlock()
    
    lc.timestamp++
    return lc.timestamp
}

func (lc *LamportClock) Update(received int) int {
    lc.mu.Lock()
    defer lc.mu.Unlock()
    
    if received > lc.timestamp {
        lc.timestamp = received
    }
    lc.timestamp++
    
    return lc.timestamp
}

// Lamport时钟一致性验证
type LamportConsistencyProver struct{}

func (lcp *LamportConsistencyProver) ProveHappensBefore(
    events []Event,
) bool {
    // 验证Lamport时钟的happens-before关系
    for i := 0; i < len(events); i++ {
        for j := i + 1; j < len(events); j++ {
            e1, e2 := events[i], events[j]
            
            // 如果e1 -> e2 (happens-before)
            if lcp.happensBefore(e1, e2) {
                // 则 L(e1) < L(e2)
                if e1.LamportTime >= e2.LamportTime {
                    fmt.Printf(
                        "Lamport clock violation: %s -> %s but L(%d) >= L(%d)\n",
                        e1.ID,
                        e2.ID,
                        e1.LamportTime,
                        e2.LamportTime,
                    )
                    return false
                }
            }
        }
    }
    
    return true
}

type Event struct {
    ID          string
    ProcessID   string
    LamportTime int
    VectorTime  VectorClock
    CausedBy    []string
}

func (lcp *LamportConsistencyProver) happensBefore(e1, e2 Event) bool {
    // 同一进程内的顺序
    if e1.ProcessID == e2.ProcessID {
        return e1.LamportTime < e2.LamportTime
    }
    
    // 消息传递关系
    for _, causeID := range e2.CausedBy {
        if causeID == e1.ID {
            return true
        }
    }
    
    return false
}
```

### Vector时钟证明

**Vector时钟实现**：

```go
// Vector时钟实现
type VectorClockImpl struct {
    processID string
    clock     VectorClock
    mu        sync.Mutex
}

func NewVectorClock(processID string, numProcesses int) *VectorClockImpl {
    return &VectorClockImpl{
        processID: processID,
        clock:     make(VectorClock),
    }
}

func (vc *VectorClockImpl) Tick() VectorClock {
    vc.mu.Lock()
    defer vc.mu.Unlock()
    
    vc.clock[vc.processID]++
    return vc.copyClock()
}

func (vc *VectorClockImpl) Update(received VectorClock) VectorClock {
    vc.mu.Lock()
    defer vc.mu.Unlock()
    
    // 取每个进程的最大值
    for pid, timestamp := range received {
        if timestamp > vc.clock[pid] {
            vc.clock[pid] = timestamp
        }
    }
    
    // 自增本进程时钟
    vc.clock[vc.processID]++
    
    return vc.copyClock()
}

func (vc *VectorClockImpl) copyClock() VectorClock {
    copy := make(VectorClock)
    for k, v := range vc.clock {
        copy[k] = v
    }
    return copy
}

// Vector时钟一致性证明
type VectorClockProver struct{}

func (vcp *VectorClockProver) ProveCausalConsistency(
    events []Event,
) bool {
    for i := 0; i < len(events); i++ {
        for j := 0; j < len(events); j++ {
            if i == j {
                continue
            }
            
            e1, e2 := events[i], events[j]
            
            // e1 -> e2 当且仅当 VC(e1) < VC(e2)
            happensBefore := vcp.happensBefore(e1, e2)
            vectorLess := vcp.vectorClockLess(e1.VectorTime, e2.VectorTime)
            
            if happensBefore != vectorLess {
                fmt.Printf(
                    "Vector clock inconsistency: %s and %s\n",
                    e1.ID,
                    e2.ID,
                )
                return false
            }
        }
    }
    
    return true
}

func (vcp *VectorClockProver) vectorClockLess(vc1, vc2 VectorClock) bool {
    lessOrEqual := true
    strictlyLess := false
    
    // 获取所有进程ID
    allProcesses := make(map[string]bool)
    for pid := range vc1 {
        allProcesses[pid] = true
    }
    for pid := range vc2 {
        allProcesses[pid] = true
    }
    
    for pid := range allProcesses {
        t1 := vc1[pid]
        t2 := vc2[pid]
        
        if t1 > t2 {
            lessOrEqual = false
            break
        }
        if t1 < t2 {
            strictlyLess = true
        }
    }
    
    return lessOrEqual && strictlyLess
}

func (vcp *VectorClockProver) happensBefore(e1, e2 Event) bool {
    // 检查因果关系
    visited := make(map[string]bool)
    return vcp.reachable(e1.ID, e2.ID, e1, visited)
}

func (vcp *VectorClockProver) reachable(
    from, to string,
    current Event,
    visited map[string]bool,
) bool {
    if from == to {
        return true
    }
    
    if visited[current.ID] {
        return false
    }
    visited[current.ID] = true
    
    for _, causeID := range current.CausedBy {
        if causeID == to {
            return true
        }
        // 递归检查（简化：需要事件图）
    }
    
    return false
}
```

### Happens-Before关系

**Happens-Before关系证明**：

```go
// Happens-Before关系分析器
type HappensBeforeAnalyzer struct {
    events []Event
    graph  *HBGraph
}

type HBGraph struct {
    Nodes map[string]*Event
    Edges map[string][]string
}

func (hba *HappensBeforeAnalyzer) BuildGraph() {
    hba.graph = &HBGraph{
        Nodes: make(map[string]*Event),
        Edges: make(map[string][]string),
    }
    
    for i := range hba.events {
        event := &hba.events[i]
        hba.graph.Nodes[event.ID] = event
    }
    
    // 构建happens-before边
    for _, event := range hba.events {
        // 1. 同进程内的顺序
        for _, other := range hba.events {
            if event.ProcessID == other.ProcessID &&
                event.LamportTime < other.LamportTime {
                hba.graph.Edges[event.ID] = append(
                    hba.graph.Edges[event.ID],
                    other.ID,
                )
            }
        }
        
        // 2. 消息传递关系
        for _, causeID := range event.CausedBy {
            hba.graph.Edges[causeID] = append(
                hba.graph.Edges[causeID],
                event.ID,
            )
        }
    }
}

func (hba *HappensBeforeAnalyzer) CheckTransitivity() bool {
    // 检查传递性：如果 a -> b 且 b -> c，则 a -> c
    for a := range hba.graph.Nodes {
        for _, b := range hba.graph.Edges[a] {
            for _, c := range hba.graph.Edges[b] {
                // 检查是否存在 a -> c
                if !hba.hasEdge(a, c) {
                    // 添加传递边
                    hba.graph.Edges[a] = append(hba.graph.Edges[a], c)
                }
            }
        }
    }
    
    return true
}

func (hba *HappensBeforeAnalyzer) hasEdge(from, to string) bool {
    for _, edge := range hba.graph.Edges[from] {
        if edge == to {
            return true
        }
    }
    return false
}

func (hba *HappensBeforeAnalyzer) CheckAntiSymmetry() bool {
    // 检查反对称性：如果 a -> b，则不能有 b -> a
    for a, edges := range hba.graph.Edges {
        for _, b := range edges {
            if hba.hasEdge(b, a) {
                fmt.Printf("Anti-symmetry violated: %s <-> %s\n", a, b)
                return false
            }
        }
    }
    
    return true
}
```

---

## 8.2.4 实现验证

### 一致性检查器

**综合一致性检查**：

```go
// OTLP一致性检查器
type OTLPConsistencyChecker struct {
    spanOrderChecker      *SpanOrderChecker
    completenessChecker   *TraceCompletenessChecker
    timestampChecker      *TimestampConsistencyChecker
    causalChecker         *CausalConsistencyChecker
}

func (occ *OTLPConsistencyChecker) CheckAll(
    spans []OTLPSpan,
) *ConsistencyReport {
    report := &ConsistencyReport{
        Timestamp: time.Now(),
        Checks:    []CheckResult{},
    }
    
    // 1. Span顺序检查
    orderViolations := occ.spanOrderChecker.CheckOrderConsistency()
    report.Checks = append(report.Checks, CheckResult{
        Name:       "Span Order",
        Passed:     len(orderViolations) == 0,
        Violations: len(orderViolations),
        Details:    orderViolations,
    })
    
    // 2. Trace完整性检查
    completenessIssues := occ.completenessChecker.CheckCompleteness()
    report.Checks = append(report.Checks, CheckResult{
        Name:       "Trace Completeness",
        Passed:     len(completenessIssues) == 0,
        Violations: len(completenessIssues),
        Details:    completenessIssues,
    })
    
    // 3. 时间戳一致性检查
    timestampIssues := occ.timestampChecker.CheckTimestamps(spans)
    report.Checks = append(report.Checks, CheckResult{
        Name:       "Timestamp Consistency",
        Passed:     len(timestampIssues) == 0,
        Violations: len(timestampIssues),
        Details:    timestampIssues,
    })
    
    // 4. 因果一致性检查
    causalOK := occ.causalChecker.Check()
    report.Checks = append(report.Checks, CheckResult{
        Name:   "Causal Consistency",
        Passed: causalOK,
    })
    
    return report
}

type ConsistencyReport struct {
    Timestamp time.Time
    Checks    []CheckResult
}

type CheckResult struct {
    Name       string
    Passed     bool
    Violations int
    Details    interface{}
}
```

### 违规检测

**实时违规检测**：

```go
// 实时一致性监控器
type ConsistencyMonitor struct {
    checker       *OTLPConsistencyChecker
    alertChannel  chan Alert
    violationLog  []Violation
}

func (cm *ConsistencyMonitor) MonitorStream(
    spanStream <-chan OTLPSpan,
) {
    buffer := []OTLPSpan{}
    ticker := time.NewTicker(5 * time.Second)
    
    for {
        select {
        case span := <-spanStream:
            buffer = append(buffer, span)
            
            // 立即检查单个Span
            if violations := cm.quickCheck(span); len(violations) > 0 {
                cm.handleViolations(violations)
            }
            
        case <-ticker.C:
            // 批量检查
            if len(buffer) > 0 {
                report := cm.checker.CheckAll(buffer)
                cm.processReport(report)
                buffer = []OTLPSpan{}
            }
        }
    }
}

type Alert struct {
    Severity    string
    Type        string
    Description string
    Timestamp   time.Time
}

func (cm *ConsistencyMonitor) quickCheck(span OTLPSpan) []Violation {
    violations := []Violation{}
    
    // 快速检查
    if span.EndTime.Before(span.StartTime) {
        violations = append(violations, Violation{
            Type:        "invalid_duration",
            SpanID:      span.SpanID,
            Description: "End time before start time",
        })
    }
    
    return violations
}

func (cm *ConsistencyMonitor) handleViolations(violations []Violation) {
    for _, v := range violations {
        cm.violationLog = append(cm.violationLog, v)
        
        alert := Alert{
            Severity:    cm.getSeverity(v.Type),
            Type:        v.Type,
            Description: v.Description,
            Timestamp:   time.Now(),
        }
        
        select {
        case cm.alertChannel <- alert:
        default:
            // Channel满，记录日志
            fmt.Printf("Alert channel full, dropped alert: %+v\n", alert)
        }
    }
}
```

### 修复策略

**自动修复机制**：

```go
// 一致性修复器
type ConsistencyRepairer struct{}

func (cr *ConsistencyRepairer) RepairTrace(
    trace *Trace,
    issues []CompletenessIssue,
) *Trace {
    repairedTrace := &Trace{
        TraceID: trace.TraceID,
        Spans:   make([]*OTLPSpan, len(trace.Spans)),
    }
    
    copy(repairedTrace.Spans, trace.Spans)
    
    for _, issue := range issues {
        switch issue.Type {
        case "orphan_spans":
            cr.repairOrphans(repairedTrace, issue)
            
        case "invalid_duration":
            cr.repairDuration(repairedTrace, issue)
            
        case "clock_skew":
            cr.repairClockSkew(repairedTrace, issue)
        }
    }
    
    return repairedTrace
}

func (cr *ConsistencyRepairer) repairOrphans(
    trace *Trace,
    issue CompletenessIssue,
) {
    orphanIDs := issue.Details.([]string)
    
    for _, orphanID := range orphanIDs {
        // 尝试找到最可能的父Span
        for _, span := range trace.Spans {
            if span.SpanID == orphanID {
                // 基于时间和上下文推断父Span
                parentID := cr.inferParent(span, trace)
                if parentID != "" {
                    span.ParentSpanID = parentID
                    fmt.Printf("Repaired orphan span %s, parent: %s\n",
                        orphanID, parentID)
                }
                break
            }
        }
    }
}

func (cr *ConsistencyRepairer) inferParent(
    span *OTLPSpan,
    trace *Trace,
) string {
    var bestCandidate string
    var minTimeDiff time.Duration = time.Hour
    
    for _, candidate := range trace.Spans {
        if candidate.SpanID == span.SpanID {
            continue
        }
        
        // 父Span应该包含子Span的时间范围
        if candidate.StartTime.Before(span.StartTime) &&
            candidate.EndTime.After(span.EndTime) {
            
            timeDiff := span.StartTime.Sub(candidate.StartTime)
            if timeDiff < minTimeDiff {
                minTimeDiff = timeDiff
                bestCandidate = candidate.SpanID
            }
        }
    }
    
    return bestCandidate
}

func (cr *ConsistencyRepairer) repairDuration(
    trace *Trace,
    issue CompletenessIssue,
) {
    // 修复无效的时间范围
    for _, span := range trace.Spans {
        if span.EndTime.Before(span.StartTime) {
            // 交换开始和结束时间
            span.StartTime, span.EndTime = span.EndTime, span.StartTime
            fmt.Printf("Repaired duration for span %s\n", span.SpanID)
        }
    }
}

func (cr *ConsistencyRepairer) repairClockSkew(
    trace *Trace,
    issue CompletenessIssue,
) {
    // 使用NTP同步或时间戳调整
    // 这里简化为基于相对顺序的调整
    for i := 1; i < len(trace.Spans); i++ {
        prev := trace.Spans[i-1]
        curr := trace.Spans[i]
        
        if curr.StartTime.Before(prev.EndTime) {
            // 调整当前Span的时间戳
            offset := prev.EndTime.Sub(curr.StartTime) + time.Millisecond
            curr.StartTime = curr.StartTime.Add(offset)
            curr.EndTime = curr.EndTime.Add(offset)
        }
    }
}
```

---

## 总结

协议一致性证明核心技术：

**一致性模型**：

- 线性一致性
- 最终一致性
- 因果一致性
- 顺序一致性

**OTLP特性**：

- Span顺序一致性
- Trace完整性
- 时间戳一致性
- 事件顺序

**证明方法**：

- Lamport时钟
- Vector时钟
- Happens-Before
- 传递性/反对称性

**实现验证**：

- 综合检查器
- 实时监控
- 违规检测
- 自动修复

**最佳实践**：

- 分层验证
- 实时检测
- 自动修复
- 持续监控
- 日志审计

---

**上一篇**: [23_形式化验证框架.md](23_形式化验证框架.md)  
**下一篇**: [25_性能模型分析.md](25_性能模型分析.md)

---

*最后更新: 2025年10月7日*-
