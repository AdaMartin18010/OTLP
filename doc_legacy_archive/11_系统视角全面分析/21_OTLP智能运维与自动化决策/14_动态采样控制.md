# 动态采样控制

**文档版本**: 1.0.0  
**创建日期**: 2025年10月7日  
**所属**: 第五部分 - 控制与动态调整  

---

## 目录

- [动态采样控制](#动态采样控制)
  - [目录](#目录)
  - [概述](#概述)
  - [5.1.1 采样策略](#511-采样策略)
    - [Head-based采样](#head-based采样)
    - [Tail-based采样](#tail-based采样)
    - [混合采样](#混合采样)
  - [5.1.2 自适应采样算法](#512-自适应采样算法)
    - [基于负载的采样](#基于负载的采样)
    - [基于价值的采样](#基于价值的采样)
    - [机器学习采样](#机器学习采样)
  - [5.1.3 采样率动态调整](#513-采样率动态调整)
    - [PID控制器](#pid控制器)
    - [强化学习](#强化学习)
  - [5.1.4 采样效果评估](#514-采样效果评估)
    - [覆盖率分析](#覆盖率分析)
    - [代表性评估](#代表性评估)
  - [总结](#总结)

---

## 概述

本文档介绍OTLP的动态采样控制机制，包括多种采样策略、自适应算法和效果评估方法。

---

## 5.1.1 采样策略

### Head-based采样

**在Span创建时决定是否采样**：

```go
// Head-based采样器
type HeadBasedSampler struct {
    samplingRate float64
    mu           sync.RWMutex
}

func (hbs *HeadBasedSampler) ShouldSample(
    ctx context.Context,
    traceID TraceID,
    spanName string,
    spanKind SpanKind,
    attributes map[string]interface{},
) SamplingDecision {
    hbs.mu.RLock()
    rate := hbs.samplingRate
    hbs.mu.RUnlock()
    
    // 使用TraceID的哈希值确保同一Trace的所有Span决策一致
    hash := hashTraceID(traceID)
    threshold := uint64(rate * float64(math.MaxUint64))
    
    if hash < threshold {
        return SamplingDecision{
            Sample: true,
            Attributes: map[string]interface{}{
                "sampling.rate": rate,
            },
        }
    }
    
    return SamplingDecision{Sample: false}
}

// 概率采样
type ProbabilitySampler struct {
    probability float64
}

func (ps *ProbabilitySampler) ShouldSample(traceID TraceID) bool {
    return rand.Float64() < ps.probability
}

// 速率限制采样
type RateLimitingSampler struct {
    maxTracesPerSecond int
    limiter            *rate.Limiter
}

func NewRateLimitingSampler(maxTPS int) *RateLimitingSampler {
    return &RateLimitingSampler{
        maxTracesPerSecond: maxTPS,
        limiter:            rate.NewLimiter(rate.Limit(maxTPS), maxTPS),
    }
}

func (rls *RateLimitingSampler) ShouldSample(traceID TraceID) bool {
    return rls.limiter.Allow()
}
```

### Tail-based采样

**在Trace完成后决定是否保留**：

```go
// Tail-based采样器
type TailBasedSampler struct {
    traceBuffer  map[TraceID]*TraceBuffer
    bufferSize   int
    flushTimeout time.Duration
    policies     []SamplingPolicy
    mu           sync.RWMutex
}

type TraceBuffer struct {
    Spans     []*Span
    StartTime time.Time
    Complete  bool
}

type SamplingPolicy interface {
    Evaluate(trace *Trace) (bool, float64)  // (sample, score)
}

func (tbs *TailBasedSampler) AddSpan(span *Span) {
    tbs.mu.Lock()
    defer tbs.mu.Unlock()
    
    traceID := span.TraceID
    buffer, exists := tbs.traceBuffer[traceID]
    if !exists {
        buffer = &TraceBuffer{
            StartTime: time.Now(),
        }
        tbs.traceBuffer[traceID] = buffer
    }
    
    buffer.Spans = append(buffer.Spans, span)
    
    // 检查Trace是否完成
    if tbs.isTraceComplete(buffer) {
        buffer.Complete = true
        tbs.evaluateTrace(traceID, buffer)
    }
}

func (tbs *TailBasedSampler) evaluateTrace(traceID TraceID, buffer *TraceBuffer) {
    trace := &Trace{
        TraceID: traceID,
        Spans:   buffer.Spans,
    }
    
    // 应用所有策略
    shouldSample := false
    maxScore := 0.0
    
    for _, policy := range tbs.policies {
        sample, score := policy.Evaluate(trace)
        if sample {
            shouldSample = true
            if score > maxScore {
                maxScore = score
            }
        }
    }
    
    if shouldSample {
        // 发送Trace
        tbs.sendTrace(trace)
    }
    
    // 清理缓冲
    delete(tbs.traceBuffer, traceID)
}

// 错误采样策略
type ErrorSamplingPolicy struct{}

func (esp *ErrorSamplingPolicy) Evaluate(trace *Trace) (bool, float64) {
    for _, span := range trace.Spans {
        if span.Status.Code == StatusError {
            return true, 1.0  // 最高优先级
        }
    }
    return false, 0.0
}

// 慢请求采样策略
type LatencySamplingPolicy struct {
    threshold time.Duration
}

func (lsp *LatencySamplingPolicy) Evaluate(trace *Trace) (bool, float64) {
    duration := trace.Duration()
    if duration > lsp.threshold {
        // 越慢，分数越高
        score := float64(duration) / float64(lsp.threshold)
        return true, score
    }
    return false, 0.0
}

// 稀有路径采样策略
type RarePathSamplingPolicy struct {
    pathCounts map[string]int
    threshold  int
    mu         sync.RWMutex
}

func (rpsp *RarePathSamplingPolicy) Evaluate(trace *Trace) (bool, float64) {
    path := rpsp.getTracePath(trace)
    
    rpsp.mu.Lock()
    count := rpsp.pathCounts[path]
    rpsp.pathCounts[path]++
    rpsp.mu.Unlock()
    
    if count < rpsp.threshold {
        // 稀有路径，采样
        score := 1.0 - (float64(count) / float64(rpsp.threshold))
        return true, score
    }
    
    return false, 0.0
}

func (rpsp *RarePathSamplingPolicy) getTracePath(trace *Trace) string {
    // 构建路径签名
    operations := []string{}
    for _, span := range trace.Spans {
        operations = append(operations, span.OperationName)
    }
    sort.Strings(operations)
    return strings.Join(operations, "->")
}
```

### 混合采样

**结合Head-based和Tail-based的优势**：

```go
// 混合采样器
type HybridSampler struct {
    headSampler *HeadBasedSampler
    tailSampler *TailBasedSampler
    headRate    float64  // Head-based采样率
}

func (hs *HybridSampler) ShouldSample(span *Span) SamplingDecision {
    // 1. Head-based采样（快速决策）
    headDecision := hs.headSampler.ShouldSample(
        context.Background(),
        span.TraceID,
        span.OperationName,
        span.Kind,
        span.Attributes,
    )
    
    if headDecision.Sample {
        // 已被Head采样，直接通过
        return headDecision
    }
    
    // 2. 未被Head采样，加入Tail缓冲区
    hs.tailSampler.AddSpan(span)
    
    // 暂时不采样，等待Tail决策
    return SamplingDecision{
        Sample: false,
        Deferred: true,
    }
}
```

---

## 5.1.2 自适应采样算法

### 基于负载的采样

**根据系统负载动态调整采样率**：

```go
// 负载自适应采样器
type LoadAdaptiveSampler struct {
    targetLoad    float64  // 目标负载（0-1）
    currentLoad   float64
    samplingRate  float64
    adjustFactor  float64  // 调整因子
    mu            sync.RWMutex
}

func (las *LoadAdaptiveSampler) UpdateLoad(load float64) {
    las.mu.Lock()
    defer las.mu.Unlock()
    
    las.currentLoad = load
    
    // 负载过高，降低采样率
    if load > las.targetLoad {
        ratio := load / las.targetLoad
        las.samplingRate *= (1.0 / ratio) * las.adjustFactor
    } else {
        // 负载较低，提高采样率
        ratio := las.targetLoad / load
        las.samplingRate *= ratio * las.adjustFactor
    }
    
    // 限制范围 [0.01, 1.0]
    las.samplingRate = math.Max(0.01, math.Min(1.0, las.samplingRate))
}

func (las *LoadAdaptiveSampler) GetSamplingRate() float64 {
    las.mu.RLock()
    defer las.mu.RUnlock()
    return las.samplingRate
}

// 负载监控器
type LoadMonitor struct {
    sampler       *LoadAdaptiveSampler
    checkInterval time.Duration
}

func (lm *LoadMonitor) Start() {
    ticker := time.NewTicker(lm.checkInterval)
    defer ticker.Stop()
    
    for range ticker.C {
        // 获取系统指标
        cpuUsage := lm.getCPUUsage()
        memUsage := lm.getMemoryUsage()
        queueLen := lm.getQueueLength()
        
        // 计算综合负载
        load := (cpuUsage + memUsage) / 2.0
        if queueLen > 1000 {
            load = math.Min(1.0, load*1.5)
        }
        
        // 更新采样率
        lm.sampler.UpdateLoad(load)
    }
}
```

### 基于价值的采样

**优先采样高价值的Trace**：

```go
// 价值评估采样器
type ValueBasedSampler struct {
    scoreCalculator *TraceScoreCalculator
    threshold       float64
}

type TraceScoreCalculator struct {
    weights map[string]float64
}

func (tsc *TraceScoreCalculator) CalculateScore(trace *Trace) float64 {
    score := 0.0
    
    // 1. 错误权重
    if trace.HasError() {
        score += tsc.weights["error"]
    }
    
    // 2. 延迟权重
    duration := trace.Duration()
    if duration > 1*time.Second {
        latencyScore := math.Log10(float64(duration.Milliseconds()))
        score += latencyScore * tsc.weights["latency"]
    }
    
    // 3. 业务重要性权重
    if trace.IsBusinessCritical() {
        score += tsc.weights["business"]
    }
    
    // 4. 稀有度权重
    rarity := tsc.calculateRarity(trace)
    score += rarity * tsc.weights["rarity"]
    
    // 5. 用户影响权重
    if trace.AffectsUser() {
        score += tsc.weights["user_impact"]
    }
    
    return score
}

func (vbs *ValueBasedSampler) ShouldSample(trace *Trace) bool {
    score := vbs.scoreCalculator.CalculateScore(trace)
    
    // 使用概率采样，分数越高，采样概率越大
    probability := sigmoid(score - vbs.threshold)
    return rand.Float64() < probability
}

func sigmoid(x float64) float64 {
    return 1.0 / (1.0 + math.Exp(-x))
}
```

### 机器学习采样

**使用ML模型预测Trace价值**：

```go
// ML采样器
type MLSampler struct {
    model         *TraceClassifier
    featureExtractor *FeatureExtractor
    threshold     float64
}

type TraceClassifier struct {
    weights []float64
    bias    float64
}

type FeatureExtractor struct{}

func (fe *FeatureExtractor) Extract(trace *Trace) []float64 {
    features := make([]float64, 10)
    
    // 特征1: Span数量（归一化）
    features[0] = math.Log10(float64(len(trace.Spans) + 1))
    
    // 特征2: 总延迟（归一化）
    features[1] = math.Log10(float64(trace.Duration().Milliseconds() + 1))
    
    // 特征3: 错误率
    errorCount := 0
    for _, span := range trace.Spans {
        if span.Status.Code == StatusError {
            errorCount++
        }
    }
    features[2] = float64(errorCount) / float64(len(trace.Spans))
    
    // 特征4: 服务数量
    services := make(map[string]bool)
    for _, span := range trace.Spans {
        services[span.ServiceName] = true
    }
    features[3] = math.Log10(float64(len(services) + 1))
    
    // 特征5: 最大Span深度
    features[4] = float64(trace.MaxDepth())
    
    // 特征6-10: 其他特征...
    
    return features
}

func (tc *TraceClassifier) Predict(features []float64) float64 {
    // 简单的线性模型
    score := tc.bias
    for i, feature := range features {
        score += feature * tc.weights[i]
    }
    
    // Sigmoid激活
    return 1.0 / (1.0 + math.Exp(-score))
}

func (mls *MLSampler) ShouldSample(trace *Trace) bool {
    // 1. 提取特征
    features := mls.featureExtractor.Extract(trace)
    
    // 2. 模型预测
    score := mls.model.Predict(features)
    
    // 3. 决策
    return score > mls.threshold
}

// 在线学习更新
func (mls *MLSampler) Update(trace *Trace, label bool) {
    features := mls.featureExtractor.Extract(trace)
    prediction := mls.model.Predict(features)
    
    // 梯度下降更新
    learningRate := 0.01
    error := float64(0)
    if label {
        error = 1.0 - prediction
    } else {
        error = 0.0 - prediction
    }
    
    for i := range mls.model.weights {
        mls.model.weights[i] += learningRate * error * features[i]
    }
    mls.model.bias += learningRate * error
}
```

---

## 5.1.3 采样率动态调整

### PID控制器

**使用PID控制器平滑调整采样率**：

```go
// PID采样率控制器
type PIDSamplingController struct {
    targetThroughput float64  // 目标吞吐量（traces/s）
    
    // PID参数
    kp float64  // 比例系数
    ki float64  // 积分系数
    kd float64  // 微分系数
    
    // 状态
    integral      float64
    prevError     float64
    samplingRate  float64
    
    mu sync.Mutex
}

func NewPIDSamplingController(target float64) *PIDSamplingController {
    return &PIDSamplingController{
        targetThroughput: target,
        kp:               0.5,
        ki:               0.1,
        kd:               0.05,
        samplingRate:     1.0,
    }
}

func (psc *PIDSamplingController) Update(currentThroughput float64, dt time.Duration) {
    psc.mu.Lock()
    defer psc.mu.Unlock()
    
    // 1. 计算误差
    error := psc.targetThroughput - currentThroughput
    
    // 2. 积分项
    psc.integral += error * dt.Seconds()
    
    // 3. 微分项
    derivative := (error - psc.prevError) / dt.Seconds()
    
    // 4. PID输出
    output := psc.kp*error + psc.ki*psc.integral + psc.kd*derivative
    
    // 5. 更新采样率
    psc.samplingRate += output * 0.01  // 小步调整
    psc.samplingRate = math.Max(0.01, math.Min(1.0, psc.samplingRate))
    
    // 6. 保存当前误差
    psc.prevError = error
}

func (psc *PIDSamplingController) GetSamplingRate() float64 {
    psc.mu.Lock()
    defer psc.mu.Unlock()
    return psc.samplingRate
}
```

### 强化学习

**使用强化学习优化采样策略**：

```go
// Q-Learning采样控制器
type QLearningController struct {
    qTable       map[State]map[Action]float64
    alpha        float64  // 学习率
    gamma        float64  // 折扣因子
    epsilon      float64  // 探索率
    currentState State
    mu           sync.RWMutex
}

type State struct {
    LoadLevel      int  // 0-10
    ErrorRate      int  // 0-10
    LatencyLevel   int  // 0-10
}

type Action int

const (
    ActionDecrease Action = iota  // 降低采样率
    ActionMaintain                 // 保持
    ActionIncrease                 // 提高采样率
)

func (qlc *QLearningController) ChooseAction(state State) Action {
    qlc.mu.RLock()
    defer qlc.mu.RUnlock()
    
    // ε-贪婪策略
    if rand.Float64() < qlc.epsilon {
        // 探索：随机选择
        return Action(rand.Intn(3))
    }
    
    // 利用：选择Q值最大的动作
    actions := qlc.qTable[state]
    maxQ := math.Inf(-1)
    bestAction := ActionMaintain
    
    for action, q := range actions {
        if q > maxQ {
            maxQ = q
            bestAction = action
        }
    }
    
    return bestAction
}

func (qlc *QLearningController) Update(
    state State,
    action Action,
    reward float64,
    nextState State,
) {
    qlc.mu.Lock()
    defer qlc.mu.Unlock()
    
    // 获取当前Q值
    currentQ := qlc.qTable[state][action]
    
    // 获取下一状态的最大Q值
    maxNextQ := math.Inf(-1)
    for _, q := range qlc.qTable[nextState] {
        if q > maxNextQ {
            maxNextQ = q
        }
    }
    
    // Q-Learning更新公式
    newQ := currentQ + qlc.alpha*(reward+qlc.gamma*maxNextQ-currentQ)
    
    if qlc.qTable[state] == nil {
        qlc.qTable[state] = make(map[Action]float64)
    }
    qlc.qTable[state][action] = newQ
}

// 奖励函数
func (qlc *QLearningController) CalculateReward(
    samplingRate float64,
    metrics SystemMetrics,
) float64 {
    reward := 0.0
    
    // 1. 覆盖率奖励
    if metrics.ErrorCoverage > 0.95 {
        reward += 10.0
    }
    
    // 2. 资源惩罚
    if metrics.CPUUsage > 0.8 {
        reward -= 5.0
    }
    
    // 3. 数据量惩罚
    if metrics.DataVolume > metrics.TargetVolume {
        ratio := metrics.DataVolume / metrics.TargetVolume
        reward -= ratio * 3.0
    }
    
    // 4. 采样率惩罚（避免过度采样）
    if samplingRate > 0.5 {
        reward -= (samplingRate - 0.5) * 2.0
    }
    
    return reward
}
```

---

## 5.1.4 采样效果评估

### 覆盖率分析

**评估采样的覆盖程度**：

```go
// 覆盖率分析器
type CoverageAnalyzer struct {
    totalTraces   int64
    sampledTraces int64
    
    // 按维度统计
    serviceCoverage map[string]*CoverageStats
    pathCoverage    map[string]*CoverageStats
    errorCoverage   *CoverageStats
    
    mu sync.RWMutex
}

type CoverageStats struct {
    Total   int64
    Sampled int64
}

func (ca *CoverageAnalyzer) Record(trace *Trace, sampled bool) {
    ca.mu.Lock()
    defer ca.mu.Unlock()
    
    atomic.AddInt64(&ca.totalTraces, 1)
    if sampled {
        atomic.AddInt64(&ca.sampledTraces, 1)
    }
    
    // 服务覆盖率
    for _, span := range trace.Spans {
        service := span.ServiceName
        if ca.serviceCoverage[service] == nil {
            ca.serviceCoverage[service] = &CoverageStats{}
        }
        ca.serviceCoverage[service].Total++
        if sampled {
            ca.serviceCoverage[service].Sampled++
        }
    }
    
    // 错误覆盖率
    if trace.HasError() {
        ca.errorCoverage.Total++
        if sampled {
            ca.errorCoverage.Sampled++
        }
    }
}

func (ca *CoverageAnalyzer) GetReport() CoverageReport {
    ca.mu.RLock()
    defer ca.mu.RUnlock()
    
    report := CoverageReport{
        OverallRate: float64(ca.sampledTraces) / float64(ca.totalTraces),
        ErrorRate:   float64(ca.errorCoverage.Sampled) / float64(ca.errorCoverage.Total),
    }
    
    // 服务覆盖率
    report.ServiceRates = make(map[string]float64)
    for service, stats := range ca.serviceCoverage {
        report.ServiceRates[service] = float64(stats.Sampled) / float64(stats.Total)
    }
    
    return report
}
```

### 代表性评估

**评估采样数据的代表性**：

```go
// 代表性评估器
type RepresentativenessEvaluator struct {
    fullDistribution    *Distribution
    sampledDistribution *Distribution
}

type Distribution struct {
    latencyHistogram map[int]int  // 延迟分布
    errorRateByService map[string]float64
}

func (re *RepresentativenessEvaluator) Evaluate() RepresentativenessScore {
    score := RepresentativenessScore{}
    
    // 1. KL散度（衡量分布差异）
    score.KLDivergence = re.calculateKLDivergence()
    
    // 2. Wasserstein距离
    score.WassersteinDistance = re.calculateWasserstein()
    
    // 3. 相关系数
    score.Correlation = re.calculateCorrelation()
    
    return score
}

func (re *RepresentativenessEvaluator) calculateKLDivergence() float64 {
    kl := 0.0
    
    for bucket, fullCount := range re.fullDistribution.latencyHistogram {
        sampledCount := re.sampledDistribution.latencyHistogram[bucket]
        
        p := float64(fullCount) / float64(re.getTotalCount(re.fullDistribution))
        q := float64(sampledCount) / float64(re.getTotalCount(re.sampledDistribution))
        
        if p > 0 && q > 0 {
            kl += p * math.Log(p/q)
        }
    }
    
    return kl
}
```

---

## 总结

动态采样控制核心技术：

**采样策略**：

- Head-based：快速决策
- Tail-based：精确决策
- 混合：兼顾性能和准确性

**自适应算法**：

- 负载自适应：根据系统压力
- 价值评估：优先高价值Trace
- 机器学习：智能预测

**动态调整**：

- PID控制器：平滑调整
- 强化学习：自动优化
- 实时反馈：快速响应

**效果评估**：

- 覆盖率分析：全面性
- 代表性评估：准确性
- KL散度：分布一致性

**最佳实践**：

- 错误必采样
- 慢请求优先
- 稀有路径保留
- 负载自适应
- 持续评估优化

---

**上一篇**: [13_告警与通知机制.md](13_告警与通知机制.md)  
**下一篇**: [15_自适应资源管理.md](15_自适应资源管理.md)

---

*最后更新: 2025年10月7日*-
