# ğŸ”§ OTLPæ•…éšœæ’æŸ¥æŒ‡å—

> **æœ€åæ›´æ–°**: 2025-10-26  
> **æ¶µç›–åœºæ™¯**: 20+ä¸ªå¸¸è§é—®é¢˜  
> **éš¾åº¦çº§åˆ«**: â­â­â­â˜†â˜†

---

## ğŸ“‹ æ•…éšœåˆ†ç±»

- [1. æ•°æ®ä¸å¯è§](#1-æ•°æ®ä¸å¯è§)
- [2. æ•°æ®ä¸å®Œæ•´](#2-æ•°æ®ä¸å®Œæ•´)
- [3. æ€§èƒ½é—®é¢˜](#3-æ€§èƒ½é—®é¢˜)
- [4. Collectoré—®é¢˜](#4-collectoré—®é¢˜)
- [5. Backendé—®é¢˜](#5-backendé—®é¢˜)
- [6. ç½‘ç»œé—®é¢˜](#6-ç½‘ç»œé—®é¢˜)

---

## 1. æ•°æ®ä¸å¯è§

### é—®é¢˜1.1: å®Œå…¨çœ‹ä¸åˆ°è¿½è¸ªæ•°æ®

#### ç—‡çŠ¶

- Jaeger/Zipkin UIä¸­æ²¡æœ‰ä»»ä½•Trace
- åº”ç”¨çœ‹èµ·æ¥æ­£å¸¸è¿è¡Œ
- æ²¡æœ‰æ˜æ˜¾é”™è¯¯

#### æ’æŸ¥æ­¥éª¤

**Step 1: ç¡®è®¤SDKåˆå§‹åŒ–**

```bash
# æ£€æŸ¥åº”ç”¨æ—¥å¿—
# åº”è¯¥çœ‹åˆ°ç±»ä¼¼ä¿¡æ¯:
# "OpenTelemetry SDK initialized"
# "Tracing started"
```

```javascript
// ç¡®ä¿tracingåœ¨æœ€å¼€å§‹å¯¼å…¥
require('./tracing');  // â† å¿…é¡»ç¬¬ä¸€è¡Œ
const express = require('express');
// ... å…¶ä»–å¯¼å…¥

// âœ— é”™è¯¯é¡ºåº:
const express = require('express');
require('./tracing');  // â† å¤ªæ™šäº†ï¼
```

**Step 2: æ£€æŸ¥é‡‡æ ·é…ç½®**

```bash
# ä¸´æ—¶è®¾ç½®100%é‡‡æ ·
export OTEL_TRACES_SAMPLER=always_on
export OTEL_TRACES_SAMPLER_ARG=1.0

# é‡å¯åº”ç”¨
node app.js
```

**Step 3: ä½¿ç”¨Console Exporterè°ƒè¯•**

```javascript
// tracing.js
const { ConsoleSpanExporter } = require('@opentelemetry/sdk-trace-base');
const { SimpleSpanProcessor } = require('@opentelemetry/sdk-trace-base');

// ä¸´æ—¶ä½¿ç”¨æ§åˆ¶å°å¯¼å‡º
const exporter = new ConsoleSpanExporter();
const processor = new SimpleSpanProcessor(exporter);

const sdk = new NodeSDK({
  spanProcessor: processor,
  // ... å…¶ä»–é…ç½®
});

// ç°åœ¨æ¯ä¸ªSpanéƒ½ä¼šæ‰“å°åˆ°æ§åˆ¶å°
```

**Step 4: æ£€æŸ¥Exporteré…ç½®**

```bash
# æµ‹è¯•OTLP endpointæ˜¯å¦å¯è¾¾
curl -X POST http://localhost:4318/v1/traces \
  -H "Content-Type: application/json" \
  -d '{}'

# åº”è¯¥è¿”å›400 (Bad Request) æˆ–å…¶ä»–é"è¿æ¥æ‹’ç»"çš„é”™è¯¯
# å¦‚æœæ˜¯"Connection refused"ï¼Œè¯´æ˜endpointä¸å¯¹
```

**Step 5: æ£€æŸ¥Backend**

```bash
# ç¡®è®¤Jaegeræ­£åœ¨è¿è¡Œ
docker ps | grep jaeger
# æˆ–
curl http://localhost:16686/api/services

# ç¡®è®¤Jaeger Collectorç«¯å£å¼€æ”¾
netstat -tuln | grep 4318
```

#### å¸¸è§åŸå› å’Œè§£å†³æ–¹æ¡ˆ

| åŸå›  | ç—‡çŠ¶ | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| **SDKæœªæ­£ç¡®åˆå§‹åŒ–** | åº”ç”¨è¿è¡Œä½†æ— Span | æ£€æŸ¥importé¡ºåº |
| **é‡‡æ ·ç‡ä¸º0** | ä»£ç æ­£ç¡®ä½†æ— æ•°æ® | è®¾ç½®`always_on`é‡‡æ · |
| **Exporter endpointé”™è¯¯** | è¿æ¥å¤±è´¥é”™è¯¯ | æ£€æŸ¥URLå’Œç«¯å£ |
| **Backendæœªè¿è¡Œ** | å¯¼å‡ºæˆåŠŸä½†æŸ¥è¯¢æ— æ•°æ® | å¯åŠ¨Jaeger/Zipkin |
| **é˜²ç«å¢™é˜»æ­¢** | è¿æ¥è¶…æ—¶ | æ£€æŸ¥é˜²ç«å¢™è§„åˆ™ |

#### è§£å†³æ–¹æ¡ˆç¤ºä¾‹

```javascript
// âœ“ å®Œæ•´çš„tracing.jsé…ç½®
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');

// 1. åˆ›å»ºExporter
const exporter = new OTLPTraceExporter({
  url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',
  headers: {},
  timeoutMillis: 10000,
});

// 2. åˆ›å»ºResource
const resource = Resource.default().merge(
  new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'my-service',
    [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
  })
);

// 3. åˆ›å»ºSDK
const sdk = new NodeSDK({
  resource,
  traceExporter: exporter,
  instrumentations: [getNodeAutoInstrumentations()],
});

// 4. å¯åŠ¨SDK
console.log('Starting OpenTelemetry SDK...');
sdk.start();
console.log('OpenTelemetry SDK started successfully');

// 5. ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch((error) => console.log('Error terminating tracing', error))
    .finally(() => process.exit(0));
});

module.exports = sdk;
```

---

### é—®é¢˜1.2: åªçœ‹åˆ°éƒ¨åˆ†æœåŠ¡çš„æ•°æ®

#### ç—‡çŠ¶

- Service Aæœ‰æ•°æ®
- Service Bæ²¡æœ‰æ•°æ®
- ä¸¤ä¸ªæœåŠ¡éƒ½åº”è¯¥æœ‰è¿½è¸ª

#### æ’æŸ¥æ­¥éª¤

**Step 1: ç¡®è®¤Service Bçš„é…ç½®**

```bash
# åœ¨Service Bä¸­
# æ£€æŸ¥ç¯å¢ƒå˜é‡
env | grep OTEL

# åº”è¯¥çœ‹åˆ°:
# OTEL_SERVICE_NAME=service-b
# OTEL_EXPORTER_OTLP_ENDPOINT=http://...
```

**Step 2: æ£€æŸ¥Service Bçš„æ—¥å¿—**

```bash
# æŸ¥æ‰¾é”™è¯¯
tail -f service-b.log | grep -i "error\|fail\|exception"

# å¸¸è§é”™è¯¯:
# "Failed to export spans"
# "Connection refused"
# "Timeout"
```

**Step 3: æµ‹è¯•Service Båˆ°Collectorçš„è¿æ¥**

```bash
# ä»Service Bçš„å®¹å™¨/ä¸»æœº
curl -v http://collector:4318/v1/traces

# æˆ–æµ‹è¯•gRPC
grpcurl -plaintext collector:4317 list
```

**Step 4: æ£€æŸ¥ç½‘ç»œç­–ç•¥ (Kubernetes)**

```bash
# ç¡®è®¤Podå¯ä»¥è®¿é—®Collector
kubectl exec -it service-b-pod -- curl http://otel-collector:4318/v1/traces

# æ£€æŸ¥NetworkPolicy
kubectl get networkpolicies
kubectl describe networkpolicy <name>
```

#### è§£å†³æ–¹æ¡ˆ

**Kubernetesç¯å¢ƒ**:

```yaml
# ç¡®ä¿æ‰€æœ‰æœåŠ¡ä½¿ç”¨ç›¸åŒçš„Collectoråœ°å€
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-config
data:
  OTEL_EXPORTER_OTLP_ENDPOINT: "http://otel-collector.observability.svc.cluster.local:4318"

---
# åœ¨Deploymentä¸­å¼•ç”¨
apiVersion: apps/v1
kind: Deployment
metadata:
  name: service-b
spec:
  template:
    spec:
      containers:
      - name: app
        envFrom:
        - configMapRef:
            name: otel-config  # ç»Ÿä¸€é…ç½®
```

---

## 2. æ•°æ®ä¸å®Œæ•´

### é—®é¢˜2.1: Traceç¼ºå°‘éƒ¨åˆ†Span

#### ç—‡çŠ¶

```
é¢„æœŸ: Frontend â†’ Auth â†’ Database
å®é™…: Frontend â†’ Database (ç¼ºå°‘Auth Span)
```

#### åŸå› åˆ†æ

**1. Contextä¼ æ’­å¤±è´¥**

```typescript
// âœ— é—®é¢˜ä»£ç 
async function callAuthService() {
  // åˆ›å»ºäº†æ–°çš„Spanï¼Œä½†æ²¡æœ‰ä¼ é€’Context
  await fetch('http://auth-service/verify');
}

// âœ“ ä¿®å¤
async function callAuthService() {
  const headers = {};
  propagation.inject(context.active(), headers);  // æ³¨å…¥Context
  
  await fetch('http://auth-service/verify', { headers });
}
```

**2. å¼‚æ­¥æ“ä½œä¸¢å¤±Context**

```typescript
// âœ— é—®é¢˜: EventEmitterä¸¢å¤±Context
emitter.on('data', (data) => {
  const span = tracer.startSpan('process');  // æ²¡æœ‰parent!
  // ...
});

// âœ“ ä¿®å¤: ä¿å­˜å’Œæ¢å¤Context
const ctx = context.active();
emitter.on('data', (data) => {
  context.with(ctx, () => {
    const span = tracer.startSpan('process');  // æœ‰parent
    // ...
  });
});
```

**3. é‡‡æ ·ä¸ä¸€è‡´**

```
Service A: é‡‡æ · (100%)
Service B: ä¸é‡‡æ · (1% - è¿æ°”ä¸å¥½æ²¡é‡‡æ ·)
â†’ Traceä¸å®Œæ•´
```

**è§£å†³**: ä½¿ç”¨ParentBasedé‡‡æ ·

```javascript
const sampler = new ParentBasedSampler({
  root: new TraceIdRatioBasedSampler(0.01),  // æ ¹Span 1%
  remoteParentSampled: new AlwaysOnSampler(),    // å¦‚æœçˆ¶é‡‡æ ·ï¼Œåˆ™é‡‡æ ·
  remoteParentNotSampled: new AlwaysOffSampler() // å¦‚æœçˆ¶ä¸é‡‡æ ·ï¼Œåˆ™ä¸é‡‡æ ·
});
```

#### æ’æŸ¥å·¥å…·

**è¿½è¸ªContextä¼ æ’­**:

```typescript
// æ·»åŠ æ—¥å¿—æŸ¥çœ‹Context
const { trace } = require('@opentelemetry/api');

function logContext() {
  const span = trace.getSpan(context.active());
  if (span) {
    const ctx = span.spanContext();
    console.log('TraceID:', ctx.traceId);
    console.log('SpanID:', ctx.spanId);
    console.log('TraceFlags:', ctx.traceFlags);
  } else {
    console.log('No active span!');
  }
}

// åœ¨å…³é”®ä½ç½®è°ƒç”¨
app.get('/api/users', (req, res) => {
  logContext();  // æ£€æŸ¥å…¥å£
  
  await callAuthService();
  logContext();  // æ£€æŸ¥Authå
  
  await queryDatabase();
  logContext();  // æ£€æŸ¥DBå
});
```

---

### é—®é¢˜2.2: Spanç¼ºå°‘å±æ€§

#### ç—‡çŠ¶

- Spanå­˜åœ¨ä½†æ²¡æœ‰`http.status_code`
- ç¼ºå°‘ä¸šåŠ¡å±æ€§
- è‡ªåŠ¨åŸ‹ç‚¹çš„å±æ€§ä¸å…¨

#### åŸå› å’Œè§£å†³

**1. è‡ªåŠ¨åŸ‹ç‚¹æœªå®Œå…¨è¦†ç›–**

```javascript
// æŸäº›HTTPå®¢æˆ·ç«¯å¯èƒ½ä¸è¢«è‡ªåŠ¨åŸ‹ç‚¹æ”¯æŒ
const axios = require('axios');  // æ”¯æŒ
const got = require('got');      // å¯èƒ½ä¸æ”¯æŒ

// è§£å†³: æ‰‹åŠ¨æ·»åŠ 
const span = trace.getActiveSpan();
span?.setAttribute('http.status_code', response.status);
```

**2. å±æ€§åœ¨Spanç»“æŸåè®¾ç½®**

```typescript
// âœ— é”™è¯¯
const span = tracer.startSpan('operation');
span.end();  // Spanå·²ç»“æŸ
span.setAttribute('key', 'value');  // æ— æ•ˆï¼

// âœ“ æ­£ç¡®
const span = tracer.startSpan('operation');
span.setAttribute('key', 'value');  // åœ¨ç»“æŸå‰è®¾ç½®
span.end();
```

**3. å¼‚å¸¸å¯¼è‡´å±æ€§æœªè®¾ç½®**

```typescript
// âœ— é—®é¢˜
const span = tracer.startSpan('operation');
try {
  const result = await doWork();
  span.setAttribute('result', result);  // å¦‚æœå¼‚å¸¸ï¼Œä¸ä¼šæ‰§è¡Œ
} catch (error) {
  // ...
}
span.end();

// âœ“ ä¿®å¤
const span = tracer.startSpan('operation');
try {
  const result = await doWork();
  span.setAttribute('result', result);
  span.setAttribute('success', true);
} catch (error) {
  span.setAttribute('success', false);
  span.recordException(error);
} finally {
  span.end();
}
```

---

## 3. æ€§èƒ½é—®é¢˜

### é—®é¢˜3.1: åº”ç”¨å˜æ…¢äº†

#### ç—‡çŠ¶

- æ·»åŠ è¿½è¸ªåï¼Œå“åº”æ—¶é—´æ˜æ˜¾å¢åŠ 
- CPUä½¿ç”¨ç‡ä¸Šå‡
- å†…å­˜å ç”¨å¢åŠ 

#### æ’æŸ¥æ­¥éª¤

**Step 1: æµ‹é‡å¼€é”€**

```typescript
// æ·»åŠ æ€§èƒ½æµ‹é‡
const start = Date.now();

// ä½ çš„è¿½è¸ªä»£ç 
const span = tracer.startSpan('operation');
// ... ä¸šåŠ¡é€»è¾‘
span.end();

const overhead = Date.now() - start;
console.log('Tracing overhead:', overhead, 'ms');
```

**Step 2: æ£€æŸ¥é…ç½®**

```javascript
// âœ— æ€§èƒ½æ€æ‰‹é…ç½®
const processor = new SimpleSpanProcessor(exporter);  // åŒæ­¥å¯¼å‡ºï¼
const sampler = new AlwaysOnSampler();  // 100%é‡‡æ ·ï¼

// âœ“ ä¼˜åŒ–é…ç½®
const processor = new BatchSpanProcessor(exporter, {
  maxQueueSize: 2048,
  scheduledDelayMillis: 5000,  // 5ç§’æ‰¹é‡
  maxExportBatchSize: 512
});
const sampler = new TraceIdRatioBasedSampler(0.01);  // 1%é‡‡æ ·
```

**Step 3: è¯†åˆ«è¿‡åº¦åŸ‹ç‚¹**

```bash
# æŸ¥çœ‹Spanæ•°é‡
curl http://localhost:16686/api/traces/{trace-id}

# å¦‚æœä¸€ä¸ªTraceæœ‰>100ä¸ªSpanï¼Œå¯èƒ½è¿‡åº¦åŸ‹ç‚¹äº†
```

#### ä¼˜åŒ–æ–¹æ¡ˆ

**1. ä½¿ç”¨å¼‚æ­¥æ‰¹é‡å¯¼å‡º**

```javascript
const processor = new BatchSpanProcessor(exporter, {
  maxQueueSize: 2048,
  scheduledDelayMillis: 5000,
  maxExportBatchSize: 512,
  exportTimeoutMillis: 30000
});
```

**2. é™ä½é‡‡æ ·ç‡**

```bash
# ç”Ÿäº§ç¯å¢ƒ
export OTEL_TRACES_SAMPLER=parentbased_traceidratio
export OTEL_TRACES_SAMPLER_ARG=0.01  # 1%

# å¼€å‘ç¯å¢ƒ
export OTEL_TRACES_SAMPLER=always_on
```

**3. ç§»é™¤ä¸å¿…è¦çš„åŸ‹ç‚¹**

```javascript
// âœ— è¿‡åº¦åŸ‹ç‚¹
class UserService {
  @Trace  // ä¸è¦ç»™æ¯ä¸ªgetteråŠ Span
  getId() { return this.id; }
  
  @Trace  // ä¸è¦ç»™æ¯ä¸ªsetteråŠ Span
  setName(name) { this.name = name; }
}

// âœ“ åªç»™å…³é”®æ“ä½œåŸ‹ç‚¹
class UserService {
  @Trace  // å…³é”®ä¸šåŠ¡æ“ä½œ
  async createUser(data) {
    // ...
  }
}
```

**4. é™åˆ¶å±æ€§å¤§å°**

```typescript
// é™åˆ¶å±æ€§å€¼çš„å¤§å°
function setAttributeSafe(span, key, value) {
  const maxSize = 1000;
  if (typeof value === 'string' && value.length > maxSize) {
    span.setAttribute(key, value.substring(0, maxSize) + '...[truncated]');
  } else {
    span.setAttribute(key, value);
  }
}
```

---

### é—®é¢˜3.2: Collector OOM (å†…å­˜æº¢å‡º)

#### ç—‡çŠ¶

```
Collectoræ—¥å¿—:
  "Out of memory"
  "Cannot allocate memory"
  
Kubernetes:
  PodçŠ¶æ€: OOMKilled
  Restart count: ä¸æ–­å¢åŠ 
```

#### åŸå› 

**1. æµé‡çªå¢**

```
æ­£å¸¸: 1K TPS
çªå¢: 10K TPS (10x)
â†’ Collectorå†…å­˜é˜Ÿåˆ—è¢«å¡«æ»¡
```

**2. Backendæ…¢/ä¸å¯ç”¨**

```
Collector â†’ Backend (è¶…æ—¶)
â†’ æ•°æ®æ— æ³•å¯¼å‡º
â†’ å†…å­˜é˜Ÿåˆ—ç§¯å‹
â†’ OOM
```

**3. é…ç½®ä¸å½“**

```yaml
# âœ— å±é™©é…ç½®
memory_limiter:
  check_interval: 1s
  limit_mib: 4096  # 4GB - å¤ªå¤§äº†ï¼
```

#### è§£å†³æ–¹æ¡ˆ

**1. å¯ç”¨å†…å­˜é™åˆ¶å™¨**

```yaml
# collector-config.yaml
processors:
  memory_limiter:
    check_interval: 1s
    limit_percentage: 75  # ä½¿ç”¨75%æ—¶å¼€å§‹æ‹’ç»
    spike_limit_percentage: 25  # çŸ­æœŸå¯è¾¾100%

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [memory_limiter, batch]  # memory_limiterå¿…é¡»ç¬¬ä¸€ä¸ª
      exporters: [jaeger]
```

**2. è°ƒæ•´é˜Ÿåˆ—å¤§å°**

```yaml
exporters:
  jaeger:
    endpoint: jaeger:14250
    sending_queue:
      enabled: true
      num_consumers: 10
      queue_size: 1000  # ä¸è¦å¤ªå¤§
```

**3. å¢åŠ Collectorèµ„æº**

```yaml
# kubernetes
resources:
  requests:
    memory: "2Gi"
    cpu: "1000m"
  limits:
    memory: "4Gi"  # å¢åŠ åˆ°4GB
    cpu: "2000m"
```

**4. æ°´å¹³æ‰©å±•**

```bash
# å¢åŠ Collectorå‰¯æœ¬æ•°
kubectl scale deployment otel-collector --replicas=5
```

**5. å¯ç”¨é‡‡æ ·**

```yaml
processors:
  probabilistic_sampler:
    sampling_percentage: 10  # 10%é‡‡æ ·
```

---

## 4. Collectoré—®é¢˜

### é—®é¢˜4.1: Collectorå¯åŠ¨å¤±è´¥

#### ç—‡çŠ¶

```bash
docker logs otel-collector
# Error: failed to load configuration
# Error: failed to resolve receiver
```

#### å¸¸è§é”™è¯¯

**1. é…ç½®æ–‡ä»¶è¯­æ³•é”™è¯¯**

```yaml
# âœ— é”™è¯¯: ç¼©è¿›ä¸å¯¹
receivers:
otlp:  # åº”è¯¥ç¼©è¿›
  protocols:
    grpc:

# âœ“ æ­£ç¡®
receivers:
  otlp:
    protocols:
      grpc:
```

**2. ç¼ºå°‘å¿…éœ€å­—æ®µ**

```yaml
# âœ— é”™è¯¯: exportersä¸­å¼•ç”¨äº†ä¸å­˜åœ¨çš„jaeger
service:
  pipelines:
    traces:
      exporters: [jaeger]  # ä½†æ²¡æœ‰å®šä¹‰jaeger exporter

# âœ“ æ­£ç¡®: å…ˆå®šä¹‰exporter
exporters:
  jaeger:
    endpoint: jaeger:14250

service:
  pipelines:
    traces:
      exporters: [jaeger]
```

**3. ç«¯å£å†²çª**

```bash
# é”™è¯¯: Address already in use
# æ£€æŸ¥ç«¯å£å ç”¨
netstat -tuln | grep 4318
lsof -i :4318

# è§£å†³: æ›´æ”¹ç«¯å£æˆ–åœæ­¢å†²çªè¿›ç¨‹
```

#### éªŒè¯é…ç½®

```bash
# ä½¿ç”¨otelcoléªŒè¯é…ç½®
docker run --rm -v $(pwd)/config.yaml:/config.yaml \
  otel/opentelemetry-collector:latest \
  --config=/config.yaml \
  --dry-run

# æˆ–ä½¿ç”¨online validator
# https://opentelemetry.io/docs/collector/configuration/
```

---

### é—®é¢˜4.2: Collectorä¸¢å¼ƒæ•°æ®

#### ç—‡çŠ¶

```bash
# Collectoræ—¥å¿—
"Dropping data because sending_queue is full"
"Exporting failed. Dropping data"
```

#### åŸå› å’Œè§£å†³

**1. Backendå¤ªæ…¢**

```yaml
# å¢åŠ è¶…æ—¶æ—¶é—´
exporters:
  jaeger:
    endpoint: jaeger:14250
    timeout: 30s  # é»˜è®¤5sï¼Œå¢åŠ åˆ°30s
```

**2. é˜Ÿåˆ—å¤ªå°**

```yaml
# å¢åŠ é˜Ÿåˆ—å¤§å°
exporters:
  jaeger:
    endpoint: jaeger:14250
    sending_queue:
      queue_size: 5000  # é»˜è®¤1000ï¼Œå¢åŠ åˆ°5000
      num_consumers: 20  # å¢åŠ å¹¶å‘å¯¼å‡º
```

**3. é‡è¯•é…ç½®**

```yaml
exporters:
  jaeger:
    endpoint: jaeger:14250
    retry_on_failure:
      enabled: true
      initial_interval: 1s
      max_interval: 30s
      max_elapsed_time: 5m
```

#### ç›‘æ§æŒ‡æ ‡

```bash
# è®¿é—®Collector metrics endpoint
curl http://localhost:8888/metrics

# å…³é”®æŒ‡æ ‡:
# otelcol_processor_dropped_spans_total  - ä¸¢å¼ƒçš„Span
# otelcol_exporter_queue_size            - é˜Ÿåˆ—å¤§å°
# otelcol_exporter_send_failed_spans     - å‘é€å¤±è´¥
```

---

## 5. Backendé—®é¢˜

### é—®é¢˜5.1: JaegeræŸ¥è¯¢å¾ˆæ…¢

#### ç—‡çŠ¶

- æŸ¥è¯¢Traceè¶…è¿‡30ç§’
- UIåŠ è½½ç¼“æ…¢
- æ•°æ®åº“CPU 100%

#### ä¼˜åŒ–æ–¹æ¡ˆ

**1. æ·»åŠ ç´¢å¼• (Elasticsearch)**

```bash
# æ£€æŸ¥ç°æœ‰ç´¢å¼•
curl http://localhost:9200/jaeger-span-*/_settings

# æ·»åŠ ç´¢å¼•
curl -X PUT "http://localhost:9200/jaeger-span-*/_settings" -H 'Content-Type: application/json' -d'
{
  "index": {
    "number_of_replicas": 0,
    "refresh_interval": "30s"
  }
}
'
```

**2. é™åˆ¶æŸ¥è¯¢èŒƒå›´**

```
Jaeger UI:
  - Lookback: 1 hour (ä¸è¦é€‰"All time")
  - Limit Results: 20 (ä¸è¦é€‰500)
  - ä½¿ç”¨Min/Max Durationè¿‡æ»¤
```

**3. æ¸…ç†æ—§æ•°æ®**

```bash
# Elasticsearch
# åˆ é™¤7å¤©å‰çš„ç´¢å¼•
curator_cli --host localhost delete_indices \
  --filter_list '
  [
    {"filtertype":"age","source":"name","direction":"older","unit":"days","unit_count":7}
  ]
  '
```

**4. åˆ†ç‰‡ç­–ç•¥ (Elasticsearch)**

```bash
# ä¸ºjaegerç´¢å¼•è®¾ç½®åˆç†çš„åˆ†ç‰‡æ•°
# è§„åˆ™: æ¯ä¸ªåˆ†ç‰‡20-40GB
# ä¾‹å¦‚: 100GBæ•°æ® â†’ 3-5ä¸ªåˆ†ç‰‡
```

---

## 6. ç½‘ç»œé—®é¢˜

### é—®é¢˜6.1: è¿æ¥è¶…æ—¶

#### ç—‡çŠ¶

```
Error: connect ETIMEDOUT
Error: Request timeout
```

#### æ’æŸ¥æ­¥éª¤

**1. æµ‹è¯•è¿é€šæ€§**

```bash
# ping
ping collector-host

# telnet
telnet collector-host 4318

# curl
curl -v http://collector-host:4318/v1/traces
```

**2. æ£€æŸ¥DNS**

```bash
# è§£æåŸŸå
nslookup otel-collector.namespace.svc.cluster.local

# æ£€æŸ¥/etc/hosts
cat /etc/hosts | grep otel
```

**3. æ£€æŸ¥é˜²ç«å¢™**

```bash
# Linux
iptables -L -n | grep 4318
firewall-cmd --list-ports

# æ£€æŸ¥å®‰å…¨ç»„ (äº‘ç¯å¢ƒ)
# AWS, GCP, Azureæ§åˆ¶å°
```

**4. æ£€æŸ¥ç½‘ç»œç­–ç•¥ (Kubernetes)**

```bash
kubectl get networkpolicies
kubectl describe networkpolicy <name>

# æµ‹è¯•Podé—´è¿æ¥
kubectl exec -it app-pod -- curl http://otel-collector:4318/v1/traces
```

#### è§£å†³æ–¹æ¡ˆ

```yaml
# Kubernetes NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-to-collector
spec:
  podSelector:
    matchLabels:
      app: otel-collector
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector: {}  # å…è®¸åŒnamespaceæ‰€æœ‰Pod
    ports:
    - protocol: TCP
      port: 4318
    - protocol: TCP
      port: 4317
```

---

## ğŸ“Š æ•…éšœæ’æŸ¥æµç¨‹å›¾

```mermaid
graph TD
    A[å‘ç°é—®é¢˜] --> B{æ•°æ®å¯è§å—?}
    B -->|å¦| C[æ£€æŸ¥SDKåˆå§‹åŒ–]
    B -->|æ˜¯| D{æ•°æ®å®Œæ•´å—?}
    
    C --> E[æ£€æŸ¥é‡‡æ ·é…ç½®]
    E --> F[æ£€æŸ¥Exporteré…ç½®]
    F --> G[æ£€æŸ¥BackendçŠ¶æ€]
    
    D -->|å¦| H[æ£€æŸ¥Contextä¼ æ’­]
    D -->|æ˜¯| I{æ€§èƒ½æ­£å¸¸å—?}
    
    H --> J[æ£€æŸ¥é‡‡æ ·ä¸€è‡´æ€§]
    J --> K[æ£€æŸ¥å¼‚æ­¥å¤„ç†]
    
    I -->|å¦| L[æ£€æŸ¥é…ç½®]
    I -->|æ˜¯| M[é—®é¢˜è§£å†³]
    
    L --> N[ä¼˜åŒ–é‡‡æ ·ç‡]
    N --> O[ä¼˜åŒ–æ‰¹å¤„ç†]
    O --> M
    
    G --> M
    K --> M
```

---

## ğŸ› ï¸ è¯Šæ–­å·¥å…·ç®±

### 1. å¿«é€Ÿè¯Šæ–­è„šæœ¬

```bash
#!/bin/bash
# otel-diagnose.sh

echo "=== OpenTelemetry è¯Šæ–­ ==="

# 1. æ£€æŸ¥ç¯å¢ƒå˜é‡
echo "1. ç¯å¢ƒå˜é‡:"
env | grep OTEL

# 2. æ£€æŸ¥Collectorè¿é€šæ€§
echo "2. Collectorè¿é€šæ€§:"
curl -sf http://localhost:4318/v1/traces && echo "âœ“ OTLP HTTP OK" || echo "âœ— OTLP HTTP Failed"
grpcurl -plaintext localhost:4317 list && echo "âœ“ OTLP gRPC OK" || echo "âœ— OTLP gRPC Failed"

# 3. æ£€æŸ¥Backend
echo "3. BackendçŠ¶æ€:"
curl -sf http://localhost:16686/api/services && echo "âœ“ Jaeger OK" || echo "âœ— Jaeger Failed"

# 4. æ£€æŸ¥ç«¯å£
echo "4. ç«¯å£ç›‘å¬:"
netstat -tuln | grep -E "4317|4318|16686"

echo "=== è¯Šæ–­å®Œæˆ ==="
```

### 2. æ€§èƒ½åˆ†æå·¥å…·

```typescript
// performance-monitor.ts
class TracingPerformanceMonitor {
  private overhead: number[] = [];
  
  measure(fn: () => void): void {
    const start = Date.now();
    fn();
    const end = Date.now();
    this.overhead.push(end - start);
  }
  
  report(): void {
    if (this.overhead.length === 0) return;
    
    const avg = this.overhead.reduce((a, b) => a + b) / this.overhead.length;
    const max = Math.max(...this.overhead);
    const min = Math.min(...this.overhead);
    
    console.log('Tracing Performance:');
    console.log(`  Average: ${avg.toFixed(2)}ms`);
    console.log(`  Max: ${max}ms`);
    console.log(`  Min: ${min}ms`);
    console.log(`  Samples: ${this.overhead.length}`);
  }
}

// ä½¿ç”¨
const monitor = new TracingPerformanceMonitor();

app.use((req, res, next) => {
  monitor.measure(() => {
    // è¿½è¸ªä»£ç 
    const span = tracer.startSpan('request');
    // ...
    span.end();
  });
  
  next();
});

// å®šæœŸæŠ¥å‘Š
setInterval(() => monitor.report(), 60000);  // æ¯åˆ†é’Ÿ
```

---

## ğŸ“š ç›¸å…³èµ„æº

- [å¸¸è§é—®é¢˜FAQ](./â“_å¸¸è§é—®é¢˜FAQ.md)
- [å¿«é€Ÿå…¥é—¨æŒ‡å—](./ğŸš€_å¿«é€Ÿå…¥é—¨æŒ‡å—.md)
- [å®ç°æ¦‚å¿µ](./01_æ¦‚å¿µç´¢å¼•/03_å®ç°æ¦‚å¿µ.md)
- [OpenTelemetryå®˜æ–¹troubleshooting](https://opentelemetry.io/docs/troubleshooting/)

---

**ç»´æŠ¤**: OTLPé¡¹ç›®ç»„  
**æœ€åæ›´æ–°**: 2025-10-26  
**åé¦ˆ**: æ¬¢è¿æäº¤é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
