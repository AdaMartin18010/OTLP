# å½¢å¼åŒ–æ¦‚å¿µç´¢å¼•

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-26  
> **ç»´æŠ¤å›¢é˜Ÿ**: OTLPé¡¹ç›®ç»„  
> **é€‚ç”¨èŒƒå›´**: å½¢å¼åŒ–éªŒè¯ã€ç±»å‹ç³»ç»Ÿã€ä»£æ•°æ¡†æ¶

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›OTLPé¡¹ç›®ä¸­æ‰€æœ‰**å½¢å¼åŒ–ç†è®ºæ¦‚å¿µ**çš„ç»Ÿä¸€å®šä¹‰ã€æ•°å­¦è¡¨ç¤ºã€æ€§è´¨è¯æ˜å’Œåº”ç”¨å®ä¾‹ã€‚

### è¦†ç›–èŒƒå›´
- **ç±»å‹ç³»ç»Ÿ**: 15ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **æ“ä½œè¯­ä¹‰**: 12ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **ä»£æ•°æ¡†æ¶**: 18ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **å½¢å¼åŒ–è¯æ˜**: 10ä¸ªæ ¸å¿ƒæ¦‚å¿µ

### ä½¿ç”¨æŒ‡å—
- ğŸ” å¿«é€ŸæŸ¥æ‰¾ï¼šä½¿ç”¨Ctrl+Fæœç´¢æ¦‚å¿µåç§°
- ğŸ“– ç³»ç»Ÿå­¦ä¹ ï¼šæŒ‰ç« èŠ‚é¡ºåºé˜…è¯»
- ğŸ”— äº¤å‰å¼•ç”¨ï¼šç‚¹å‡»é“¾æ¥è·³è½¬ç›¸å…³æ¦‚å¿µ
- ğŸ’¡ å®è·µåº”ç”¨ï¼šå‚è€ƒæ¯ä¸ªæ¦‚å¿µçš„åº”ç”¨ç¤ºä¾‹

---

## 1. ç±»å‹ç³»ç»Ÿ (Type System)

### 1.1 ç±»å‹ (Type)

#### å®šä¹‰
**ç±»å‹**æ˜¯å¯¹å€¼çš„åˆ†ç±»ç³»ç»Ÿï¼Œå®šä¹‰äº†å€¼çš„ç»“æ„ã€æ“ä½œå’Œè¡Œä¸ºçº¦æŸã€‚

#### æ•°å­¦è¡¨ç¤º
```
Ï„ ::= Base              -- åŸºæœ¬ç±»å‹
    | Ï„â‚ â†’ Ï„â‚‚          -- å‡½æ•°ç±»å‹
    | Ï„â‚ Ã— Ï„â‚‚          -- ç§¯ç±»å‹
    | Ï„â‚ + Ï„â‚‚          -- å’Œç±»å‹
    | Î¼Î±.Ï„              -- é€’å½’ç±»å‹
    | âˆ€Î±.Ï„              -- å…¨ç§°ç±»å‹
```

#### å½¢å¼åŒ–å®šä¹‰
```
Type = {Ï„ | Ï„æ»¡è¶³è‰¯æ„æ€§æ¡ä»¶}
where è‰¯æ„æ€§æ¡ä»¶åŒ…æ‹¬:
  1. ç±»å‹å˜é‡ç»‘å®šæ­£ç¡®
  2. é€’å½’å®šä¹‰æœ‰é™å±•å¼€
  3. ç±»å‹æ„é€ ä¿æŒä¸€è‡´æ€§
```

#### æ ¸å¿ƒå±æ€§
- **è‰¯æ„æ€§** (Well-formedness): æ‰€æœ‰ç±»å‹è¡¨è¾¾å¼å¿…é¡»è¯­æ³•æ­£ç¡®
- **å¯åˆ¤å®šæ€§** (Decidability): ç±»å‹æ£€æŸ¥åœ¨æœ‰é™æ—¶é—´å†…ç»ˆæ­¢
- **å¥å£®æ€§** (Soundness): ç±»å‹å®‰å…¨ä¿è¯è¿è¡Œæ—¶ä¸å‡ºé”™
- **å®Œå¤‡æ€§** (Completeness): æ‰€æœ‰åˆæ³•ç¨‹åºéƒ½å¯ä»¥è¢«ç±»å‹åŒ–

#### ä¸å…¶ä»–æ¦‚å¿µçš„å…³ç³»
```mermaid
graph TD
    A[ç±»å‹ Type] --> B[ç±»å‹æ£€æŸ¥ Type Checking]
    A --> C[ç±»å‹æ¨å¯¼ Type Inference]
    A --> D[ç±»å‹å®‰å…¨ Type Safety]
    B --> E[é™æ€éªŒè¯]
    C --> F[è‡ªåŠ¨æ¨å¯¼]
    D --> G[è¿è¡Œæ—¶ä¿è¯]
```

#### åº”ç”¨ç¤ºä¾‹

**ç¤ºä¾‹1: Traceç±»å‹å®šä¹‰**
```typescript
// å®šä¹‰Traceç±»å‹
type Trace = {
  traceId: TraceID,        // è¿½è¸ªæ ‡è¯†ç¬¦
  spans: Array<Span>,      // Spanæ•°ç»„
  resource: Resource,      // èµ„æºä¿¡æ¯
  timestamp: Timestamp     // æ—¶é—´æˆ³
}

// ç±»å‹æ£€æŸ¥
function validateTrace(t: Trace): boolean {
  return (
    isValidTraceID(t.traceId) &&
    t.spans.every(isValidSpan) &&
    isValidResource(t.resource)
  );
}
```

**ç¤ºä¾‹2: å‡½æ•°ç±»å‹åº”ç”¨**
```
processSpan :: Span â†’ Result
  where Span = SpanID Ã— TraceID Ã— Timestamp
        Result = Either Error ProcessedSpan
```

#### åœ¨OTLPä¸­çš„åº”ç”¨
- **æ•°æ®æ¨¡å‹**: å®šä¹‰Traceã€Spanã€Metricã€Logçš„ç±»å‹
- **APIè®¾è®¡**: ç¡®ä¿æ¥å£ç±»å‹å®‰å…¨
- **åè®®éªŒè¯**: ä¿è¯æ•°æ®æ ¼å¼ä¸€è‡´æ€§
- **é”™è¯¯é¢„é˜²**: ç¼–è¯‘æœŸæ•è·ç±»å‹é”™è¯¯

#### å‚è€ƒæ–‡çŒ®
- [Types and Programming Languages](Pierce, 2002)
- [Advanced Topics in Types and Programming Languages](Pierce, 2004)
- [OTLP Type System Specification](../02_çŸ¥è¯†å›¾è°±/03_ç†è®ºåŸºç¡€çŸ¥è¯†å›¾è°±.md)

---

### 1.2 ç±»å‹æ£€æŸ¥ (Type Checking)

#### å®šä¹‰
**ç±»å‹æ£€æŸ¥**æ˜¯éªŒè¯ç¨‹åºè¡¨è¾¾å¼æ˜¯å¦ç¬¦åˆç±»å‹è§„åˆ™çš„è¿‡ç¨‹ã€‚

#### å½¢å¼åŒ–å®šä¹‰
```
ç±»å‹æ£€æŸ¥åˆ¤æ–­: Î“ âŠ¢ e : Ï„

å…¶ä¸­:
  Î“: ç±»å‹ç¯å¢ƒ (å˜é‡åˆ°ç±»å‹çš„æ˜ å°„)
  e: è¡¨è¾¾å¼
  Ï„: ç±»å‹
  
è¯»ä½œ: "åœ¨ç±»å‹ç¯å¢ƒÎ“ä¸‹ï¼Œè¡¨è¾¾å¼eå…·æœ‰ç±»å‹Ï„"
```

#### ç±»å‹æ£€æŸ¥è§„åˆ™

**è§„åˆ™1: å˜é‡æŸ¥æ‰¾**
```
(VAR)  x:Ï„ âˆˆ Î“
       â”€â”€â”€â”€â”€â”€â”€â”€â”€
       Î“ âŠ¢ x : Ï„
```

**è§„åˆ™2: å‡½æ•°åº”ç”¨**
```
(APP)  Î“ âŠ¢ eâ‚ : Ï„â‚ â†’ Ï„â‚‚    Î“ âŠ¢ eâ‚‚ : Ï„â‚
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       Î“ âŠ¢ eâ‚ eâ‚‚ : Ï„â‚‚
```

**è§„åˆ™3: LambdaæŠ½è±¡**
```
(ABS)  Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       Î“ âŠ¢ Î»x.e : Ï„â‚ â†’ Ï„â‚‚
```

#### ç®—æ³•å®ç°
```
typecheck(Î“, e) =
  case e of
    Var(x) â†’ 
      if x âˆˆ Î“ then Î“(x)
      else TypeError("æœªå®šä¹‰å˜é‡")
      
    App(eâ‚, eâ‚‚) â†’
      let Ï„â‚ = typecheck(Î“, eâ‚)
      let Ï„â‚‚ = typecheck(Î“, eâ‚‚)
      match Ï„â‚ with
        | Arrow(Ï„_arg, Ï„_ret) â†’
          if Ï„â‚‚ = Ï„_arg then Ï„_ret
          else TypeError("ç±»å‹ä¸åŒ¹é…")
        | _ â†’ TypeError("æœŸæœ›å‡½æ•°ç±»å‹")
        
    Abs(x, Ï„, e_body) â†’
      let Ï„_body = typecheck(Î“[x â†¦ Ï„], e_body)
      Arrow(Ï„, Ï„_body)
```

#### å¤æ‚åº¦åˆ†æ
- **æ—¶é—´å¤æ‚åº¦**: O(n Ã— m)ï¼Œnä¸ºè¡¨è¾¾å¼å¤§å°ï¼Œmä¸ºç±»å‹å¤§å°
- **ç©ºé—´å¤æ‚åº¦**: O(d)ï¼Œdä¸ºASTæ·±åº¦
- **å¯åˆ¤å®šæ€§**: å¯¹äºç®€å•ç±»å‹ç³»ç»Ÿï¼Œç±»å‹æ£€æŸ¥æ˜¯å¯åˆ¤å®šçš„

#### åœ¨OTLPä¸­çš„åº”ç”¨
```typescript
// OTLP Spanç±»å‹æ£€æŸ¥
function checkSpan(span: unknown): span is Span {
  return (
    typeof span === 'object' &&
    span !== null &&
    'spanId' in span &&
    'traceId' in span &&
    'timestamp' in span &&
    checkSpanID(span.spanId) &&
    checkTraceID(span.traceId) &&
    checkTimestamp(span.timestamp)
  );
}
```

#### ç›¸å…³æ¦‚å¿µ
- â† [ç±»å‹](#11-ç±»å‹-type)
- â†’ [ç±»å‹æ¨å¯¼](#13-ç±»å‹æ¨å¯¼-type-inference)
- â†’ [ç±»å‹å®‰å…¨](#14-ç±»å‹å®‰å…¨-type-safety)

---

### 1.3 ç±»å‹æ¨å¯¼ (Type Inference)

#### å®šä¹‰
**ç±»å‹æ¨å¯¼**æ˜¯è‡ªåŠ¨æ¨æ–­è¡¨è¾¾å¼ç±»å‹çš„è¿‡ç¨‹ï¼Œæ— éœ€æ˜¾å¼ç±»å‹æ ‡æ³¨ã€‚

#### å½¢å¼åŒ–å®šä¹‰
```
ç±»å‹æ¨å¯¼é—®é¢˜:
  ç»™å®š: Î“ (ç±»å‹ç¯å¢ƒ), e (è¡¨è¾¾å¼)
  æ±‚è§£: Ï„ ä½¿å¾— Î“ âŠ¢ e : Ï„

çº¦æŸç”Ÿæˆä¸æ±‚è§£:
  1. éå†è¡¨è¾¾å¼ç”Ÿæˆç±»å‹çº¦æŸ
  2. ä½¿ç”¨ç»Ÿä¸€ç®—æ³•æ±‚è§£çº¦æŸ
  3. ç”Ÿæˆæœ€é€šç”¨ç±»å‹ (Principal Type)
```

#### Hindley-Milnerç®—æ³•

**ç®—æ³•æ­¥éª¤**:
```
infer(Î“, e) =
  case e of
    Var(x) â†’ 
      instantiate(Î“(x))
      
    App(eâ‚, eâ‚‚) â†’
      Ï„â‚ = infer(Î“, eâ‚)
      Ï„â‚‚ = infer(Î“, eâ‚‚)
      Î± = fresh_type_var()
      unify(Ï„â‚, Ï„â‚‚ â†’ Î±)
      return Î±
      
    Abs(x, e_body) â†’
      Î± = fresh_type_var()
      Ï„_body = infer(Î“[x â†¦ Î±], e_body)
      return Î± â†’ Ï„_body
      
    Let(x, eâ‚, eâ‚‚) â†’
      Ï„â‚ = infer(Î“, eâ‚)
      Ïƒ = generalize(Î“, Ï„â‚)
      return infer(Î“[x â†¦ Ïƒ], eâ‚‚)
```

**ç»Ÿä¸€ç®—æ³• (Unification)**:
```
unify(Ï„â‚, Ï„â‚‚) =
  case (Ï„â‚, Ï„â‚‚) of
    (Î±, Ï„) | (Ï„, Î±) â†’
      if Î± âˆˆ FV(Ï„) then fail "æ— é™ç±»å‹"
      else substitute(Î± â†¦ Ï„)
      
    (Ï„â‚ â†’ Ï„â‚‚, Ï„â‚ƒ â†’ Ï„â‚„) â†’
      unify(Ï„â‚, Ï„â‚ƒ)
      unify(Ï„â‚‚, Ï„â‚„)
      
    (Baseâ‚, Baseâ‚‚) â†’
      if Baseâ‚ = Baseâ‚‚ then succeed
      else fail "ç±»å‹ä¸åŒ¹é…"
```

#### ä¸»è¦ç±»å‹å®šç† (Principal Type Theorem)

**å®šç†**: å¦‚æœè¡¨è¾¾å¼eå¯ç±»å‹åŒ–ï¼Œåˆ™å­˜åœ¨å”¯ä¸€çš„æœ€é€šç”¨ç±»å‹Ïƒï¼Œä½¿å¾—ï¼š
1. Î“ âŠ¢ e : Ïƒ
2. å¯¹ä»»ä½•Î“ âŠ¢ e : Ï„ï¼Œå­˜åœ¨æ›¿æ¢Sä½¿å¾—Ï„ = S(Ïƒ)

**è¯æ˜æ€è·¯**:
1. é€šè¿‡ç»“æ„å½’çº³è¯æ˜ç®—æ³•æ­£ç¡®æ€§
2. è¯æ˜ç”Ÿæˆçš„ç±»å‹æ˜¯æœ€é€šç”¨çš„
3. è¯æ˜ç±»å‹çš„å”¯ä¸€æ€§ï¼ˆæ¨¡æ›¿æ¢ï¼‰

#### æ³›åŒ–ä¸å®ä¾‹åŒ–

**æ³›åŒ– (Generalization)**:
```
generalize(Î“, Ï„) = âˆ€Î±â‚...Î±â‚™.Ï„
  where {Î±â‚,...,Î±â‚™} = FV(Ï„) \ FV(Î“)
```

**å®ä¾‹åŒ– (Instantiation)**:
```
instantiate(âˆ€Î±â‚...Î±â‚™.Ï„) = [Î±â‚â†¦Ï„â‚,...,Î±â‚™â†¦Ï„â‚™]Ï„
  where Ï„â‚,...,Ï„â‚™ are fresh type variables
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**ç¤ºä¾‹: Spanå¤„ç†å‡½æ•°ç±»å‹æ¨å¯¼**
```typescript
// æ— éœ€æ˜¾å¼ç±»å‹æ ‡æ³¨
const processSpan = (span) => ({
  id: span.spanId,
  trace: span.traceId,
  duration: span.endTime - span.startTime
});

// æ¨å¯¼å‡ºçš„ç±»å‹:
// processSpan :: Span â†’ ProcessedSpan
// where ProcessedSpan = {
//   id: SpanID,
//   trace: TraceID,
//   duration: Duration
// }
```

#### å¤æ‚åº¦
- **æœ€åæƒ…å†µ**: O(2^n) ï¼ˆå®é™…å¾ˆå°‘å‘ç”Ÿï¼‰
- **å¹³å‡æƒ…å†µ**: O(n log n)
- **ç©ºé—´**: O(n)

#### ç›¸å…³æ¦‚å¿µ
- â† [ç±»å‹æ£€æŸ¥](#12-ç±»å‹æ£€æŸ¥-type-checking)
- â†’ [å¤šæ€ç±»å‹](#15-å¤šæ€ç±»å‹-polymorphic-type)
- â†’ [ç±»å‹çº¦æŸ](#16-ç±»å‹çº¦æŸ-type-constraint)

---

### 1.4 ç±»å‹å®‰å…¨ (Type Safety)

#### å®šä¹‰
**ç±»å‹å®‰å…¨**ä¿è¯ç±»å‹æ­£ç¡®çš„ç¨‹åºåœ¨è¿è¡Œæ—¶ä¸ä¼šå‡ºç°ç±»å‹é”™è¯¯ã€‚

#### å½¢å¼åŒ–å®šä¹‰

**è¿›å±•æ€§ (Progress)**:
```
å®šç†: å¦‚æœ âˆ… âŠ¢ e : Ï„ï¼Œåˆ™:
  1. eæ˜¯å€¼ï¼Œæˆ–
  2. å­˜åœ¨e'ä½¿å¾— e â†’ e'
  
å«ä¹‰: è‰¯ç±»å‹çš„é—­è¡¨è¾¾å¼è¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥ç»§ç»­æ‰§è¡Œ
```

**ä¿å‹æ€§ (Preservation)**:
```
å®šç†: å¦‚æœ Î“ âŠ¢ e : Ï„ ä¸” e â†’ e'ï¼Œ
     åˆ™ Î“ âŠ¢ e' : Ï„
     
å«ä¹‰: æ‰§è¡Œæ­¥éª¤ä¿æŒç±»å‹ä¸å˜
```

**ç±»å‹å®‰å…¨å®šç†**:
```
å®šç† (Type Safety):
  å¦‚æœ âˆ… âŠ¢ e : Ï„ï¼Œåˆ™:
  1. eä¸ä¼šå¡ä½ (ä¸ä¼šåˆ°è¾¾æ—¢éå€¼ä¹Ÿæ— æ³•æ‰§è¡Œçš„çŠ¶æ€)
  2. å¦‚æœ e â†’* vï¼Œåˆ™ v : Ï„
  
è¯æ˜: ç»“åˆè¿›å±•æ€§å’Œä¿å‹æ€§ï¼Œä½¿ç”¨å½’çº³æ³•
```

#### è¯æ˜æŠ€æœ¯

**è¿›å±•æ€§è¯æ˜**:
```
è¯æ˜ (Progress): å¯¹eçš„ç»“æ„å½’çº³
  Base case: eæ˜¯å¸¸é‡æˆ–å˜é‡
    - å¸¸é‡: å·²æ˜¯å€¼
    - å˜é‡: åœ¨é—­è¡¨è¾¾å¼ä¸­ä¸å‡ºç°
    
  Inductive case: e = eâ‚ eâ‚‚
    - IH: eâ‚å’Œeâ‚‚æ»¡è¶³è¿›å±•æ€§
    - Case 1: eâ‚æ˜¯å€¼ â†’ åˆ†æeâ‚çš„å½¢å¼
      * å¦‚æœeâ‚ = Î»x.eâ‚ƒï¼Œåˆ™å¯ä»¥Î²-å½’çº¦
    - Case 2: eâ‚å¯æ‰§è¡Œ â†’ e = eâ‚ eâ‚‚å¯æ‰§è¡Œ
```

**ä¿å‹æ€§è¯æ˜**:
```
è¯æ˜ (Preservation): å¯¹æ‰§è¡Œå…³ç³»çš„å½’çº³
  Case: (Î»x:Ï„â‚.e) v â†’ [xâ†¦v]e
    å·²çŸ¥: Î“ âŠ¢ Î»x:Ï„â‚.e : Ï„â‚ â†’ Ï„â‚‚
         Î“ âŠ¢ v : Ï„â‚
    æ¨å¯¼: Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚  (ç”±typingè§„åˆ™)
    
    å¼•ç† (Substitution): 
      å¦‚æœ Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚ ä¸” Î“ âŠ¢ v : Ï„â‚
      åˆ™ Î“ âŠ¢ [xâ†¦v]e : Ï„â‚‚
      
    å› æ­¤: Î“ âŠ¢ [xâ†¦v]e : Ï„â‚‚  âœ“
```

#### å¸¸è§ç±»å‹é”™è¯¯

**è¿è¡Œæ—¶ç±»å‹é”™è¯¯ç¤ºä¾‹**:
```
1. ç±»å‹ä¸åŒ¹é…
   error: 3 + "hello"
   
2. ç©ºæŒ‡é’ˆ/æœªå®šä¹‰
   error: null.field
   
3. æ•°ç»„è¶Šç•Œ
   error: arr[1000] where len(arr) = 10
   
4. æ–¹æ³•ä¸å­˜åœ¨
   error: obj.nonexistentMethod()
```

**ç±»å‹ç³»ç»Ÿå¦‚ä½•é¢„é˜²**:
```
1. é™æ€ç±»å‹æ£€æŸ¥ â†’ ç¼–è¯‘æœŸæ‹’ç»
2. ç©ºå€¼å®‰å…¨ (Option/Maybeç±»å‹)
3. è¾¹ç•Œæ£€æŸ¥ (ä¾èµ–ç±»å‹)
4. ç»“æ„ç±»å‹æ£€æŸ¥
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**ç±»å‹å®‰å…¨çš„Spanå¤„ç†**:
```typescript
// ç±»å‹å®‰å…¨çš„Resultç±»å‹
type Result<T, E> = 
  | { kind: 'ok', value: T }
  | { kind: 'error', error: E };

// å®‰å…¨çš„Spanè§£æ
function parseSpan(data: unknown): Result<Span, ParseError> {
  // ç±»å‹æ£€æŸ¥
  if (!isObject(data)) {
    return { kind: 'error', error: 'NotAnObject' };
  }
  
  // å­—æ®µéªŒè¯
  if (!('spanId' in data) || !isSpanID(data.spanId)) {
    return { kind: 'error', error: 'InvalidSpanID' };
  }
  
  // ç±»å‹è½¬æ¢ï¼ˆå®‰å…¨ï¼‰
  return {
    kind: 'ok',
    value: {
      spanId: data.spanId,
      traceId: data.traceId,
      timestamp: data.timestamp
    }
  };
}

// ä½¿ç”¨ï¼ˆå¼ºåˆ¶å¤„ç†é”™è¯¯ï¼‰
const result = parseSpan(rawData);
match result {
  case { kind: 'ok', value } => processSpan(value),
  case { kind: 'error', error } => handleError(error)
}
```

#### ç±»å‹å®‰å…¨ç­‰çº§

```mermaid
graph TD
    A[æ— ç±»å‹ç³»ç»Ÿ] -->|æ·»åŠ åŸºæœ¬ç±»å‹| B[å¼±ç±»å‹ç³»ç»Ÿ]
    B -->|æ·»åŠ ç±»å‹æ£€æŸ¥| C[å¼ºç±»å‹ç³»ç»Ÿ]
    C -->|æ·»åŠ ç±»å‹æ¨å¯¼| D[é™æ€ç±»å‹ç³»ç»Ÿ]
    D -->|æ·»åŠ ä¾èµ–ç±»å‹| E[ä¾èµ–ç±»å‹ç³»ç»Ÿ]
    E -->|å®Œå…¨å½¢å¼åŒ–| F[å®Œå…¨ç±»å‹å®‰å…¨]
    
    A -.->|å®‰å…¨æ€§| G[æœ€ä½]
    B -.-> H[ä½]
    C -.-> I[ä¸­]
    D -.-> J[é«˜]
    E -.-> K[å¾ˆé«˜]
    F -.-> L[æœ€é«˜]
```

#### ç›¸å…³æ¦‚å¿µ
- â† [ç±»å‹](#11-ç±»å‹-type)
- â† [ç±»å‹æ£€æŸ¥](#12-ç±»å‹æ£€æŸ¥-type-checking)
- â†’ [å¥å£®æ€§è¯æ˜](#21-å¥å£®æ€§è¯æ˜-soundness-proof)

---

### 1.5 å¤šæ€ç±»å‹ (Polymorphic Type)

#### å®šä¹‰
**å¤šæ€ç±»å‹**å…è®¸å‡½æ•°æˆ–æ•°æ®ç»“æ„åœ¨å¤šç§ç±»å‹ä¸Šå·¥ä½œï¼ŒåŒæ—¶ä¿æŒç±»å‹å®‰å…¨ã€‚

#### åˆ†ç±»

**1. å‚æ•°å¤šæ€ (Parametric Polymorphism)**
```
-- æ³›å‹å‡½æ•°
id :: âˆ€Î±. Î± â†’ Î±
id x = x

-- æ³›å‹æ•°æ®ç»“æ„
List :: âˆ€Î±. Type
List Î± = Nil | Cons Î± (List Î±)
```

**2. ç‰¹è®¾å¤šæ€ (Ad-hoc Polymorphism)**
```
-- å‡½æ•°é‡è½½
(+) :: Int â†’ Int â†’ Int
(+) :: Float â†’ Float â†’ Float
(+) :: String â†’ String â†’ String

-- ç±»å‹ç±»çº¦æŸ
class Eq Î± where
  (==) :: Î± â†’ Î± â†’ Bool
```

**3. å­ç±»å‹å¤šæ€ (Subtype Polymorphism)**
```
-- å­ç±»å‹å…³ç³»
Span <: Telemetry
Metric <: Telemetry
Log <: Telemetry

-- åå˜å’Œé€†å˜
covariant: C[Span] <: C[Telemetry]
contravariant: C[Telemetry] <: C[Span]
```

#### System F (å¤šæ€Î»æ¼”ç®—)

**è¯­æ³•**:
```
e ::= x                -- å˜é‡
    | Î»x:Ï„.e          -- é¡¹æŠ½è±¡
    | eâ‚ eâ‚‚           -- é¡¹åº”ç”¨
    | Î›Î±.e            -- ç±»å‹æŠ½è±¡
    | e[Ï„]            -- ç±»å‹åº”ç”¨

Ï„ ::= Î±               -- ç±»å‹å˜é‡
    | Ï„â‚ â†’ Ï„â‚‚         -- å‡½æ•°ç±»å‹
    | âˆ€Î±.Ï„            -- å…¨ç§°ç±»å‹
```

**ç±»å‹è§„åˆ™**:
```
(T-TABS)  Î“, Î± âŠ¢ e : Ï„
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          Î“ âŠ¢ Î›Î±.e : âˆ€Î±.Ï„

(T-TAPP)  Î“ âŠ¢ e : âˆ€Î±.Ï„â‚
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          Î“ âŠ¢ e[Ï„â‚‚] : [Î±â†¦Ï„â‚‚]Ï„â‚
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**æ³›å‹æ•°æ®å¤„ç†å™¨**:
```typescript
// æ³›å‹Processoræ¥å£
interface Processor<T> {
  process(data: T): Result<ProcessedData<T>>;
  validate(data: T): boolean;
}

// Spanå¤„ç†å™¨å®ç°
class SpanProcessor implements Processor<Span> {
  process(span: Span): Result<ProcessedData<Span>> {
    return {
      data: {
        id: span.spanId,
        metrics: extractMetrics(span),
        relationships: findRelationships(span)
      }
    };
  }
  
  validate(span: Span): boolean {
    return (
      isValidSpanID(span.spanId) &&
      isValidTraceID(span.traceId) &&
      span.startTime <= span.endTime
    );
  }
}

// æ³›å‹æ‰¹å¤„ç†å‡½æ•°
function batchProcess<T>(
  items: T[],
  processor: Processor<T>
): Result<ProcessedData<T>[]> {
  return items
    .filter(processor.validate)
    .map(processor.process)
    .reduce(combineResults, { kind: 'ok', value: [] });
}
```

**ç±»å‹çº¦æŸç¤ºä¾‹**:
```typescript
// å¯åºåˆ—åŒ–çº¦æŸ
interface Serializable {
  toJSON(): string;
  fromJSON(json: string): this;
}

// æ³›å‹å­˜å‚¨
class Storage<T extends Serializable> {
  save(key: string, value: T): void {
    localStorage.setItem(key, value.toJSON());
  }
  
  load(key: string, constructor: new () => T): T | null {
    const json = localStorage.getItem(key);
    if (!json) return null;
    return new constructor().fromJSON(json);
  }
}

// ä½¿ç”¨
class Span implements Serializable {
  toJSON(): string { /* ... */ }
  fromJSON(json: string): this { /* ... */ }
}

const spanStorage = new Storage<Span>();
spanStorage.save('currentSpan', mySpan);
```

#### ç§©-nå¤šæ€ (Rank-n Polymorphism)

**å®šä¹‰**:
```
Rank-0: Ï„ (æ— é‡è¯)
Rank-1: âˆ€Î±.Ï„ (æœ€å¤–å±‚é‡è¯) - Hindley-Milner
Rank-2: âˆ€Î±.(âˆ€Î².Ï„â‚) â†’ Ï„â‚‚ (å‡½æ•°å‚æ•°æœ‰é‡è¯)
Rank-n: åµŒå¥—nå±‚é‡è¯
```

**åº”ç”¨ç¤ºä¾‹**:
```typescript
// Rank-2ç±»å‹
type Rank2 = <A>(f: <B>(x: B) => B, a: A) => A;

const applyTwice: Rank2 = (f, a) => f(f(a));

// ä½¿ç”¨
const result = applyTwice(
  <T>(x: T) => x,  // å¤šæ€æ’ç­‰å‡½æ•°
  42
); // result: number = 42
```

#### ç›¸å…³æ¦‚å¿µ
- â† [ç±»å‹](#11-ç±»å‹-type)
- â†’ [ç±»å‹æ¨å¯¼](#13-ç±»å‹æ¨å¯¼-type-inference)
- â†’ [ä»£æ•°æ•°æ®ç±»å‹](#31-ä»£æ•°æ•°æ®ç±»å‹-algebraic-data-type)

---

## 2. æ“ä½œè¯­ä¹‰ (Operational Semantics)

### 2.1 å½’çº¦å…³ç³» (Reduction Relation)

#### å®šä¹‰
**å½’çº¦å…³ç³»**æè¿°ç¨‹åºè¡¨è¾¾å¼å¦‚ä½•ä¸€æ­¥æ­¥æ‰§è¡Œåˆ°ç»“æœã€‚

#### å½¢å¼åŒ–å®šä¹‰
```
å½’çº¦å…³ç³»: e â†’ e'
è¯»ä½œ: "è¡¨è¾¾å¼eå¯ä»¥ä¸€æ­¥å½’çº¦åˆ°e'"

è‡ªåä¼ é€’é—­åŒ…: e â†’* e'
å«ä¹‰: "eç»è¿‡é›¶æ­¥æˆ–å¤šæ­¥å½’çº¦åˆ°e'"
```

#### å°æ­¥è¯­ä¹‰ (Small-Step Semantics)

**åŸºæœ¬å½’çº¦è§„åˆ™**:
```
(E-APP1)  eâ‚ â†’ eâ‚'
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          eâ‚ eâ‚‚ â†’ eâ‚' eâ‚‚

(E-APP2)  eâ‚‚ â†’ eâ‚‚'
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          vâ‚ eâ‚‚ â†’ vâ‚ eâ‚‚'

(E-APPABS)  
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          (Î»x:Ï„.e) v â†’ [xâ†¦v]e
```

**ç®—æœ¯è¡¨è¾¾å¼å½’çº¦**:
```
(E-PLUS)  
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          nâ‚ + nâ‚‚ â†’ nâ‚ƒ
          where nâ‚ƒ = æ•°å€¼åŠ æ³•(nâ‚, nâ‚‚)

(E-PLUS1)  eâ‚ â†’ eâ‚'
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           eâ‚ + eâ‚‚ â†’ eâ‚' + eâ‚‚

(E-PLUS2)  eâ‚‚ â†’ eâ‚‚'
           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           vâ‚ + eâ‚‚ â†’ vâ‚ + eâ‚‚'
```

#### å¤§æ­¥è¯­ä¹‰ (Big-Step Semantics)

**æ±‚å€¼åˆ¤æ–­**: e â‡“ vï¼ˆ"è¡¨è¾¾å¼eæ±‚å€¼ä¸ºå€¼v"ï¼‰

**è§„åˆ™**:
```
(B-VALUE)  
           â”€â”€â”€â”€â”€â”€â”€
           v â‡“ v

(B-APP)  eâ‚ â‡“ Î»x:Ï„.e    eâ‚‚ â‡“ vâ‚‚    [xâ†¦vâ‚‚]e â‡“ v
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         eâ‚ eâ‚‚ â‡“ v

(B-PLUS)  eâ‚ â‡“ nâ‚    eâ‚‚ â‡“ nâ‚‚
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          eâ‚ + eâ‚‚ â‡“ nâ‚+nâ‚‚
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**Spanå¤„ç†æµç¨‹çš„æ“ä½œè¯­ä¹‰**:
```
-- Spanå¤„ç†çš„å°æ­¥è¯­ä¹‰
process(RawSpan) â†’ validate(RawSpan)
validate(RawSpan) â†’ if valid then parse(RawSpan) else Error
parse(RawSpan) â†’ Span
Span â†’ enrich(Span)
enrich(Span) â†’ EnrichedSpan
EnrichedSpan â†’ store(EnrichedSpan)
store(EnrichedSpan) â†’ Success

-- å¤§æ­¥è¯­ä¹‰
process(RawSpan) â‡“ Success
  å½“ä¸”ä»…å½“:
    valid(RawSpan) = true âˆ§
    parse(RawSpan) = span âˆ§
    enrich(span) = enriched âˆ§
    store(enriched) = ok
```

**å®ç°ç¤ºä¾‹**:
```typescript
// å°æ­¥æ‰§è¡Œå™¨
type Step<S> = (state: S) => S | 'done';

function* smallStepExecution<S>(
  initialState: S,
  step: Step<S>
): Generator<S, S, undefined> {
  let current = initialState;
  while (true) {
    yield current;
    const next = step(current);
    if (next === 'done') return current;
    current = next;
  }
}

// ä½¿ç”¨
type SpanState = 
  | { stage: 'raw', data: RawSpan }
  | { stage: 'validated', data: RawSpan }
  | { stage: 'parsed', data: Span }
  | { stage: 'enriched', data: EnrichedSpan }
  | { stage: 'stored', data: StoredSpan };

const step: Step<SpanState> = (state) => {
  switch (state.stage) {
    case 'raw':
      return { stage: 'validated', data: state.data };
    case 'validated':
      return { stage: 'parsed', data: parse(state.data) };
    case 'parsed':
      return { stage: 'enriched', data: enrich(state.data) };
    case 'enriched':
      return { stage: 'stored', data: store(state.data) };
    case 'stored':
      return 'done';
  }
};

// æ‰§è¡Œ
for (const state of smallStepExecution(initialState, step)) {
  console.log(`Current stage: ${state.stage}`);
}
```

#### ç›¸å…³æ¦‚å¿µ
- â†’ [æ±‚å€¼ç­–ç•¥](#22-æ±‚å€¼ç­–ç•¥-evaluation-strategy)
- â†’ [è¿›å±•æ€§](#14-ç±»å‹å®‰å…¨-type-safety)
- â†’ [ä¿å‹æ€§](#14-ç±»å‹å®‰å…¨-type-safety)

---

### 2.2 æ±‚å€¼ç­–ç•¥ (Evaluation Strategy)

#### å®šä¹‰
**æ±‚å€¼ç­–ç•¥**å®šä¹‰äº†å‡½æ•°å‚æ•°çš„æ±‚å€¼æ—¶æœºå’Œé¡ºåºã€‚

#### ä¸»è¦ç­–ç•¥

**1. ä¸¥æ ¼æ±‚å€¼ (Strict Evaluation) / ä¼ å€¼è°ƒç”¨ (Call-by-Value)**
```
è§„åˆ™: å…ˆæ±‚å€¼å‚æ•°ï¼Œå†åº”ç”¨å‡½æ•°

(E-APP-CBV)  eâ‚ â†’ eâ‚'
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             eâ‚ eâ‚‚ â†’ eâ‚' eâ‚‚

             eâ‚‚ â†’ eâ‚‚'
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             vâ‚ eâ‚‚ â†’ vâ‚ eâ‚‚'

             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             (Î»x.e) v â†’ [xâ†¦v]e
```

**2. æƒ°æ€§æ±‚å€¼ (Lazy Evaluation) / ä¼ åè°ƒç”¨ (Call-by-Name)**
```
è§„åˆ™: ä¸æ±‚å€¼å‚æ•°ï¼Œç›´æ¥æ›¿æ¢

(E-APP-CBN)  
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             (Î»x.eâ‚) eâ‚‚ â†’ [xâ†¦eâ‚‚]eâ‚
```

**3. ä¼ éœ€è°ƒç”¨ (Call-by-Need)**
```
ç‰¹ç‚¹: æƒ°æ€§æ±‚å€¼ + è®°å¿†åŒ–
  - ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶æ±‚å€¼
  - ä¿å­˜ç»“æœä¾›åç»­ä½¿ç”¨
```

#### æ¯”è¾ƒç¤ºä¾‹

**ä»£ç **:
```
let x = expensiveComputation()
let y = x + x
```

**Call-by-Value**:
1. å…ˆè®¡ç®—`expensiveComputation()`ä¸€æ¬¡
2. å°†ç»“æœç»‘å®šåˆ°x
3. ä½¿ç”¨xçš„å€¼ä¸¤æ¬¡
â†’ è®¡ç®—1æ¬¡ï¼Œè®¿é—®2æ¬¡

**Call-by-Name**:
1. ä¸è®¡ç®—`expensiveComputation()`
2. xç»‘å®šåˆ°è¡¨è¾¾å¼æœ¬èº«
3. æ¯æ¬¡ä½¿ç”¨xéƒ½é‡æ–°è®¡ç®—
â†’ è®¡ç®—2æ¬¡

**Call-by-Need**:
1. ä¸ç«‹å³è®¡ç®—
2. ç¬¬ä¸€æ¬¡ä½¿ç”¨xæ—¶è®¡ç®—å¹¶ç¼“å­˜
3. ç¬¬äºŒæ¬¡ä½¿ç”¨xç›´æ¥ç”¨ç¼“å­˜
â†’ è®¡ç®—1æ¬¡ï¼ˆå»¶è¿Ÿï¼‰

#### åœ¨OTLPä¸­çš„åº”ç”¨

**æƒ°æ€§SpanåŠ è½½**:
```typescript
// æƒ°æ€§è®¡ç®—çš„Spanå…³ç³»
class LazySpanRelationships {
  private _parent: Span | null = null;
  private _children: Span[] | null = null;
  
  constructor(private span: Span) {}
  
  // Call-by-Need: åªåœ¨éœ€è¦æ—¶è®¡ç®—ä¸€æ¬¡
  get parent(): Span | null {
    if (this._parent === null) {
      this._parent = findParentSpan(this.span.parentSpanId);
    }
    return this._parent;
  }
  
  get children(): Span[] {
    if (this._children === null) {
      this._children = findChildrenSpans(this.span.spanId);
    }
    return this._children;
  }
}

// ä½¿ç”¨
const relationships = new LazySpanRelationships(span);
// æ­¤æ—¶parentå’Œchildrenå°šæœªè®¡ç®—

if (needsParentInfo) {
  console.log(relationships.parent);  // ç¬¬ä¸€æ¬¡è®¡ç®—parent
}

if (needsChildrenInfo) {
  console.log(relationships.children);  // ç¬¬ä¸€æ¬¡è®¡ç®—children
}

// å†æ¬¡è®¿é—® - ç›´æ¥ä½¿ç”¨ç¼“å­˜
console.log(relationships.parent);  // ä¸é‡æ–°è®¡ç®—
```

**æµå¼å¤„ç† (Call-by-Needçš„åº”ç”¨)**:
```typescript
// æƒ°æ€§æµ
class LazyStream<T> {
  constructor(
    private head: () => T,
    private tail: () => LazyStream<T> | null
  ) {}
  
  // å¼ºåˆ¶æ±‚å€¼
  force(): T {
    return this.head();
  }
  
  // æƒ°æ€§map
  map<U>(f: (x: T) => U): LazyStream<U> {
    return new LazyStream(
      () => f(this.force()),
      () => {
        const t = this.tail();
        return t ? t.map(f) : null;
      }
    );
  }
  
  // æƒ°æ€§filter
  filter(predicate: (x: T) => boolean): LazyStream<T> {
    const h = this.force();
    if (predicate(h)) {
      return new LazyStream(
        () => h,
        () => {
          const t = this.tail();
          return t ? t.filter(predicate) : null;
        }
      );
    } else {
      const t = this.tail();
      return t ? t.filter(predicate) : emptyStream();
    }
  }
  
  // å–å‰nä¸ªå…ƒç´ 
  take(n: number): T[] {
    if (n <= 0) return [];
    const result = [this.force()];
    const t = this.tail();
    if (t) {
      result.push(...t.take(n - 1));
    }
    return result;
  }
}

// ä½¿ç”¨ï¼šå¤„ç†æ— é™Spanæµ
const spanStream = createSpanStream();  // åˆ›å»ºæƒ°æ€§æµ
const filtered = spanStream
  .filter(s => s.duration > 1000)  // æƒ°æ€§è¿‡æ»¤
  .map(s => s.spanId);             // æƒ°æ€§æ˜ å°„

// åªåœ¨éœ€è¦æ—¶æ±‚å€¼å‰10ä¸ª
const first10 = filtered.take(10);  // åªè®¡ç®—å¿…è¦çš„éƒ¨åˆ†
```

#### æ€§èƒ½å½±å“

| ç­–ç•¥ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| Call-by-Value | å¯é¢„æµ‹æ€§å¼º<br/>æ˜“äºå®ç° | å¯èƒ½è®¡ç®—ä¸éœ€è¦çš„å€¼<br/>ä¸æ”¯æŒæ— é™æ•°æ®ç»“æ„ | å¤§å¤šæ•°å‘½ä»¤å¼è¯­è¨€<br/>æ€§èƒ½å…³é”®ä»£ç  |
| Call-by-Name | åªè®¡ç®—éœ€è¦çš„å€¼<br/>æ”¯æŒæ— é™æ•°æ® | å¯èƒ½é‡å¤è®¡ç®—<br/>éš¾ä»¥é¢„æµ‹æ€§èƒ½ | å®ç³»ç»Ÿ<br/>çŸ­è·¯è¿ç®—ç¬¦ |
| Call-by-Need | åªè®¡ç®—ä¸€æ¬¡<br/>æ”¯æŒæ— é™æ•°æ® | å†…å­˜å¼€é”€ï¼ˆç¼“å­˜ï¼‰<br/>å®ç°å¤æ‚ | å‡½æ•°å¼è¯­è¨€(Haskell)<br/>æµå¤„ç† |

#### ç›¸å…³æ¦‚å¿µ
- â† [å½’çº¦å…³ç³»](#21-å½’çº¦å…³ç³»-reduction-relation)
- â†’ [èŒƒå¼](#23-èŒƒå¼-normal-form)

---

### 2.3 èŒƒå¼ (Normal Form)

#### å®šä¹‰
**èŒƒå¼**æ˜¯ä¸èƒ½å†è¿›ä¸€æ­¥å½’çº¦çš„è¡¨è¾¾å¼å½¢å¼ã€‚

#### åˆ†ç±»

**1. å¼±å¤´èŒƒå¼ (Weak Head Normal Form, WHNF)**
```
å®šä¹‰: æœ€å¤–å±‚æ˜¯æ„é€ å™¨æˆ–lambdaæŠ½è±¡

ç¤ºä¾‹:
  âœ“ Î»x.e              -- lambdaæŠ½è±¡
  âœ“ Cons 1 rest       -- æ„é€ å™¨åº”ç”¨
  âœ“ (1, e)            -- å…ƒç»„ï¼ˆå¤–å±‚æ˜¯æ„é€ å™¨ï¼‰
  âœ— (Î»x.x) y          -- å¯å½’çº¦çš„åº”ç”¨
  âœ— 1 + 2             -- å¯å½’çº¦çš„åŸè¯­
```

**2. å¤´èŒƒå¼ (Head Normal Form, HNF)**
```
å®šä¹‰: å½¢å¦‚ Î»xâ‚...xâ‚™.h eâ‚...eâ‚˜
     å…¶ä¸­hæ˜¯å˜é‡ï¼Œeâ‚...eâ‚˜æ˜¯ä»»æ„è¡¨è¾¾å¼

ç¤ºä¾‹:
  âœ“ Î»x.y
  âœ“ Î»x.Î»y.x y z
  âœ“ Î»x.y (Î»z.z)
```

**3. æ­£è§„èŒƒå¼ (Normal Form, NF)**
```
å®šä¹‰: å®Œå…¨æ±‚å€¼ï¼Œå†…éƒ¨ä¹Ÿæ²¡æœ‰å¯å½’çº¦çš„è¡¨è¾¾å¼

ç¤ºä¾‹:
  âœ“ 42
  âœ“ Î»x.x
  âœ“ Cons 1 (Cons 2 Nil)
  âœ— Î»x.(1 + 2)        -- å†…éƒ¨æœ‰å¯å½’çº¦è¡¨è¾¾å¼
```

**4. å¼±èŒƒå¼ (Weak Normal Form)**
```
å®šä¹‰: å¤–å±‚æ±‚å€¼åˆ°å€¼ï¼Œä½†å†…éƒ¨å¯èƒ½æœªæ±‚å€¼

åœ¨Call-by-Valueä¸­å¸¸ç”¨
```

#### Church-Rosserå®šç†

**å®šç†**: å¦‚æœ e â†’* eâ‚ ä¸” e â†’* eâ‚‚ï¼Œ
       åˆ™å­˜åœ¨eâ‚ƒä½¿å¾— eâ‚ â†’* eâ‚ƒ ä¸” eâ‚‚ â†’* eâ‚ƒ

**å«ä¹‰**:
- å½’çº¦å…·æœ‰åˆæµæ€§ (Confluence)
- å¦‚æœå­˜åœ¨èŒƒå¼ï¼Œåˆ™èŒƒå¼å”¯ä¸€
- æ±‚å€¼é¡ºåºä¸å½±å“æœ€ç»ˆç»“æœï¼ˆå¦‚æœéƒ½ç»ˆæ­¢ï¼‰

**å›¾ç¤º**:
```mermaid
graph TD
    E[e] -->|*| E1[eâ‚]
    E -->|*| E2[eâ‚‚]
    E1 -->|*| E3[eâ‚ƒ]
    E2 -->|*| E3
    
    style E3 fill:#90EE90
```

#### æ ‡å‡†åŒ–å®šç† (Normalization Theorem)

**å¼ºæ ‡å‡†åŒ– (Strong Normalization)**:
```
å®šç†: æ‰€æœ‰å½’çº¦åºåˆ—éƒ½æ˜¯æœ‰é™çš„

æ€§è´¨:
  - ä¸å­˜åœ¨æ— é™å½’çº¦åºåˆ—
  - ä»»ä½•è¡¨è¾¾å¼æœ€ç»ˆåˆ°è¾¾èŒƒå¼
  - é€‚ç”¨äº: ç®€å•ç±»å‹Î»æ¼”ç®—, System F
```

**å¼±æ ‡å‡†åŒ– (Weak Normalization)**:
```
å®šç†: å­˜åœ¨è‡³å°‘ä¸€ä¸ªç»ˆæ­¢çš„å½’çº¦åºåˆ—

æ€§è´¨:
  - å¯èƒ½å­˜åœ¨æ— é™å½’çº¦åºåˆ—
  - ä½†æ€»æœ‰ç­–ç•¥èƒ½åˆ°è¾¾èŒƒå¼
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**Spanå¤„ç†çš„èŒƒå¼**:
```typescript
// å®šä¹‰Spançš„"èŒƒå¼"çŠ¶æ€
type SpanNormalForm = {
  // æ‰€æœ‰å­—æ®µå®Œå…¨æ±‚å€¼
  spanId: string;              // å®Œå…¨æ±‚å€¼
  traceId: string;             // å®Œå…¨æ±‚å€¼
  startTime: number;           // å®Œå…¨æ±‚å€¼
  endTime: number;             // å®Œå…¨æ±‚å€¼
  attributes: Map<string, AttributeValue>;  // å®Œå…¨æ±‚å€¼
  
  // æ´¾ç”Ÿå­—æ®µå·²è®¡ç®—
  duration: number;            // å·²è®¡ç®—
  statusCode: StatusCode;      // å·²ç¡®å®š
  
  // å…³ç³»å·²è§£æ
  parent: Span | null;         // å·²æŸ¥æ‰¾
  children: Span[];            // å·²æ”¶é›†
};

// èŒƒå¼åŒ–å‡½æ•°
function normalizeSpan(span: PartialSpan): SpanNormalForm {
  // ç¡®ä¿æ‰€æœ‰å­—æ®µå®Œå…¨æ±‚å€¼
  const endTime = span.endTime ?? Date.now();
  const duration = endTime - span.startTime;
  const statusCode = deriveStatusCode(span);
  
  // è§£ææ‰€æœ‰å…³ç³»
  const parent = span.parentSpanId 
    ? findSpan(span.parentSpanId)
    : null;
  const children = findChildrenSpans(span.spanId);
  
  // è¿”å›èŒƒå¼
  return {
    spanId: span.spanId,
    traceId: span.traceId,
    startTime: span.startTime,
    endTime,
    attributes: new Map(span.attributes),
    duration,
    statusCode,
    parent,
    children
  };
}
```

**åˆæµæ€§æ£€æŸ¥**:
```typescript
// ç¡®ä¿ä¸åŒå¤„ç†é¡ºåºå¾—åˆ°ç›¸åŒç»“æœ
function testConfluence() {
  const rawSpan = createRawSpan();
  
  // è·¯å¾„1: å…ˆenrichmentå†validation
  const path1 = validate(enrich(rawSpan));
  
  // è·¯å¾„2: å…ˆvalidationå†enrichment
  const path2 = enrich(validate(rawSpan));
  
  // åº”è¯¥å¾—åˆ°ç›¸åŒçš„èŒƒå¼
  assert(deepEqual(
    normalizeSpan(path1),
    normalizeSpan(path2)
  ));
}
```

#### æ£€æµ‹èŒƒå¼

```typescript
// æ£€æµ‹Spanæ˜¯å¦ä¸ºèŒƒå¼
function isNormalForm(span: any): span is SpanNormalForm {
  return (
    // åŸºæœ¬å­—æ®µå­˜åœ¨ä¸”ä¸ºå€¼
    typeof span.spanId === 'string' &&
    typeof span.traceId === 'string' &&
    typeof span.startTime === 'number' &&
    typeof span.endTime === 'number' &&
    
    // æ´¾ç”Ÿå­—æ®µå·²è®¡ç®—
    typeof span.duration === 'number' &&
    span.duration === span.endTime - span.startTime &&
    
    // å…³ç³»å·²è§£æ
    (span.parent === null || isNormalForm(span.parent)) &&
    Array.isArray(span.children) &&
    span.children.every(isNormalForm)
  );
}
```

#### ç›¸å…³æ¦‚å¿µ
- â† [å½’çº¦å…³ç³»](#21-å½’çº¦å…³ç³»-reduction-relation)
- â† [æ±‚å€¼ç­–ç•¥](#22-æ±‚å€¼ç­–ç•¥-evaluation-strategy)
- â†’ [Church-Rosserå®šç†](#23-èŒƒå¼-normal-form)

---

## 3. ä»£æ•°æ¡†æ¶ (Algebraic Framework)

### 3.1 ä»£æ•°æ•°æ®ç±»å‹ (Algebraic Data Type, ADT)

#### å®šä¹‰
**ä»£æ•°æ•°æ®ç±»å‹**æ˜¯é€šè¿‡ä»£æ•°è¿ç®—ï¼ˆå’Œã€ç§¯ï¼‰æ„é€ çš„å¤åˆç±»å‹ã€‚

#### åŸºæœ¬æ„é€ 

**1. ç§¯ç±»å‹ (Product Type)**
```
å®šä¹‰: Ï„â‚ Ã— Ï„â‚‚ Ã— ... Ã— Ï„â‚™

ç¤ºä¾‹:
  Span = SpanID Ã— TraceID Ã— Timestamp Ã— Attributes
  Point = Int Ã— Int
  Triple = A Ã— B Ã— C
```

**TypeScriptå®ç°**:
```typescript
// ç§¯ç±»å‹
type Span = {
  spanId: SpanID;
  traceId: TraceID;
  timestamp: Timestamp;
  attributes: Attributes;
};

// å…ƒç»„å½¢å¼
type Point = [number, number];
type Triple<A, B, C> = [A, B, C];
```

**2. å’Œç±»å‹ (Sum Type)**
```
å®šä¹‰: Ï„â‚ + Ï„â‚‚ + ... + Ï„â‚™

ç¤ºä¾‹:
  Result = Success + Failure
  Telemetry = Trace + Metric + Log
  Option = Some(A) + None
```

**TypeScriptå®ç°**:
```typescript
// å’Œç±»å‹ï¼ˆæ ‡è®°è”åˆï¼‰
type Result<T, E> =
  | { tag: 'success'; value: T }
  | { tag: 'failure'; error: E };

type Telemetry =
  | { kind: 'trace'; data: Trace }
  | { kind: 'metric'; data: Metric }
  | { kind: 'log'; data: Log };

type Option<A> =
  | { kind: 'some'; value: A }
  | { kind: 'none' };
```

**3. é€’å½’ç±»å‹ (Recursive Type)**
```
å®šä¹‰: Ï„ = ... Ï„ ...

ç¤ºä¾‹:
  List A = Nil + Cons A (List A)
  Tree A = Leaf A + Node A (Tree A) (Tree A)
  Stream A = Stream A (() â†’ Stream A)
```

**TypeScriptå®ç°**:
```typescript
// é“¾è¡¨
type List<A> =
  | { kind: 'nil' }
  | { kind: 'cons'; head: A; tail: List<A> };

// äºŒå‰æ ‘
type Tree<A> =
  | { kind: 'leaf'; value: A }
  | { kind: 'node'; value: A; left: Tree<A>; right: Tree<A> };

// Spanæ ‘ï¼ˆè¡¨ç¤ºè¿½è¸ªå±‚æ¬¡ç»“æ„ï¼‰
type SpanTree =
  | { kind: 'single'; span: Span }
  | { kind: 'parent'; span: Span; children: SpanTree[] };
```

#### ä»£æ•°æ€§è´¨

**åŸºæ•° (Cardinality)**:
```
|A Ã— B| = |A| Ã— |B|     -- ç§¯ç±»å‹çš„åŸºæ•°æ˜¯åŸºæ•°çš„ä¹˜ç§¯
|A + B| = |A| + |B|     -- å’Œç±»å‹çš„åŸºæ•°æ˜¯åŸºæ•°çš„å’Œ
|A â†’ B| = |B|^|A|       -- å‡½æ•°ç±»å‹çš„åŸºæ•°æ˜¯æŒ‡æ•°
|1| = 1                  -- Unitç±»å‹æœ‰1ä¸ªå€¼
|0| = 0                  -- Voidç±»å‹æœ‰0ä¸ªå€¼

ç¤ºä¾‹:
  |Bool| = 2
  |Bool Ã— Bool| = 2 Ã— 2 = 4
  |Bool + Bool| = 2 + 2 = 4
  |Bool â†’ Bool| = 2^2 = 4
```

**åŒæ„ (Isomorphism)**:
```
A Ã— B â‰… B Ã— A                    -- ç§¯äº¤æ¢å¾‹
A + B â‰… B + A                    -- å’Œäº¤æ¢å¾‹
(A Ã— B) Ã— C â‰… A Ã— (B Ã— C)        -- ç§¯ç»“åˆå¾‹
(A + B) + C â‰… A + (B + C)        -- å’Œç»“åˆå¾‹
A Ã— (B + C) â‰… (A Ã— B) + (A Ã— C) -- åˆ†é…å¾‹
A Ã— 1 â‰… A                        -- ç§¯å•ä½å…ƒ
A + 0 â‰… A                        -- å’Œå•ä½å…ƒ
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**Telemetryæ•°æ®çš„ADTå»ºæ¨¡**:
```typescript
// åŸºç¡€ç±»å‹
type TraceID = string;
type SpanID = string;
type Timestamp = number;

// ç§¯ç±»å‹ - Spanç»“æ„
type Span = {
  spanId: SpanID;
  traceId: TraceID;
  parentSpanId: SpanID | null;
  startTime: Timestamp;
  endTime: Timestamp;
  attributes: Map<string, AttributeValue>;
};

// å’Œç±»å‹ - å±æ€§å€¼
type AttributeValue =
  | { type: 'string'; value: string }
  | { type: 'int'; value: number }
  | { type: 'double'; value: number }
  | { type: 'bool'; value: boolean }
  | { type: 'array'; value: AttributeValue[] };

// é€’å½’å’Œç±»å‹ - Spanç»“æœ
type SpanResult<E> =
  | { kind: 'ok'; span: Span }
  | { kind: 'error'; error: E }
  | { kind: 'partial'; span: PartialSpan; missing: string[] };

// å¤åˆADT - å®Œæ•´Telemetry
type TelemetryData =
  | { type: 'trace'; spans: Span[]; resource: Resource }
  | { type: 'metric'; name: string; value: number; timestamp: Timestamp }
  | { type: 'log'; message: string; severity: Severity; timestamp: Timestamp };
```

**æ¨¡å¼åŒ¹é…å¤„ç†**:
```typescript
// ä½¿ç”¨æ¨¡å¼åŒ¹é…å¤„ç†ADT
function processTelemetry(data: TelemetryData): ProcessResult {
  switch (data.type) {
    case 'trace':
      return processTrace(data.spans, data.resource);
      
    case 'metric':
      return processMetric(data.name, data.value, data.timestamp);
      
    case 'log':
      return processLog(data.message, data.severity, data.timestamp);
  }
}

// é€’å½’å¤„ç†Spanæ ‘
function flattenSpanTree(tree: SpanTree): Span[] {
  switch (tree.kind) {
    case 'single':
      return [tree.span];
      
    case 'parent':
      return [
        tree.span,
        ...tree.children.flatMap(flattenSpanTree)
      ];
  }
}

// å¤„ç†Resultç±»å‹
function handleSpanResult<E>(
  result: SpanResult<E>,
  handlers: {
    onOk: (span: Span) => void;
    onError: (error: E) => void;
    onPartial: (span: PartialSpan, missing: string[]) => void;
  }
): void {
  switch (result.kind) {
    case 'ok':
      return handlers.onOk(result.span);
    case 'error':
      return handlers.onError(result.error);
    case 'partial':
      return handlers.onPartial(result.span, result.missing);
  }
}
```

#### æ³›å‹ADT

```typescript
// æ³›å‹List
type List<A> =
  | { kind: 'nil' }
  | { kind: 'cons'; head: A; tail: List<A> };

// Listæ“ä½œ
function map<A, B>(f: (a: A) => B, list: List<A>): List<B> {
  switch (list.kind) {
    case 'nil':
      return { kind: 'nil' };
    case 'cons':
      return {
        kind: 'cons',
        head: f(list.head),
        tail: map(f, list.tail)
      };
  }
}

function fold<A, B>(
  f: (a: A, acc: B) => B,
  init: B,
  list: List<A>
): B {
  switch (list.kind) {
    case 'nil':
      return init;
    case 'cons':
      return fold(f, f(list.head, init), list.tail);
  }
}

// ä½¿ç”¨
const spanList: List<Span> = {
  kind: 'cons',
  head: span1,
  tail: {
    kind: 'cons',
    head: span2,
    tail: { kind: 'nil' }
  }
};

const spanIds = map(s => s.spanId, spanList);
const totalDuration = fold(
  (s, acc) => acc + (s.endTime - s.startTime),
  0,
  spanList
);
```

#### ç›¸å…³æ¦‚å¿µ
- â† [å¤šæ€ç±»å‹](#15-å¤šæ€ç±»å‹-polymorphic-type)
- â†’ [å‡½å­](#32-å‡½å­-functor)
- â†’ [å•å­](#33-å•å­-monad)

---

## 4. å½¢å¼åŒ–è¯æ˜ (Formal Proof)

### 4.1 å¥å£®æ€§è¯æ˜ (Soundness Proof)

#### å®šä¹‰
**å¥å£®æ€§**ä¿è¯ç±»å‹ç³»ç»Ÿä¸ä¼šæ¥å—é”™è¯¯çš„ç¨‹åºã€‚

#### å½¢å¼åŒ–é™ˆè¿°
```
å¥å£®æ€§å®šç† (Soundness):
  å¦‚æœ Î“ âŠ¢ e : Ï„ï¼Œåˆ™:
  1. eä¸ä¼šåœ¨è¿è¡Œæ—¶å‡ºç°ç±»å‹é”™è¯¯
  2. å¦‚æœ e â†’* vï¼Œåˆ™ v : Ï„
```

#### è¯æ˜ç»“æ„

**é€šè¿‡è¿›å±•æ€§å’Œä¿å‹æ€§è¯æ˜**:
```
å¼•ç†1 (Progress): 
  å¦‚æœ âˆ… âŠ¢ e : Ï„ï¼Œåˆ™eæ˜¯å€¼æˆ–å­˜åœ¨e'ä½¿å¾— e â†’ e'

å¼•ç†2 (Preservation):
  å¦‚æœ Î“ âŠ¢ e : Ï„ ä¸” e â†’ e'ï¼Œåˆ™ Î“ âŠ¢ e' : Ï„

å®šç† (Soundness):
  è¯æ˜: å¯¹å½’çº¦é•¿åº¦å½’çº³
  1. å¦‚æœ âˆ… âŠ¢ e : Ï„
  2. ç”±Progress: eæ˜¯å€¼æˆ–e â†’ e'
  3. å¦‚æœeæ˜¯å€¼ï¼Œè¯æ˜å®Œæˆ
  4. å¦‚æœe â†’ e'ï¼Œç”±Preservation: âˆ… âŠ¢ e' : Ï„
  5. å¯¹e'åº”ç”¨å½’çº³å‡è®¾
  âˆ´ æœ€ç»ˆe â†’* vä¸”v : Ï„ï¼Œæ— ç±»å‹é”™è¯¯å‘ç”Ÿ âˆ
```

#### è¿›å±•æ€§è¯æ˜è¯¦ç»†

```
è¯æ˜ (Progress): å¯¹eçš„ç»“æ„å½’çº³
  Base cases:
    - e = c (å¸¸é‡): cå·²æ˜¯å€¼ âœ“
    - e = x (å˜é‡): ä¸å¯èƒ½ï¼ˆâˆ… âŠ¢ x : Ï„çŸ›ç›¾ï¼‰
    
  Inductive cases:
    Case e = eâ‚ eâ‚‚:
      å·²çŸ¥: âˆ… âŠ¢ eâ‚ eâ‚‚ : Ï„â‚‚
      ç”±typingè§„åˆ™: âˆ… âŠ¢ eâ‚ : Ï„â‚ â†’ Ï„â‚‚, âˆ… âŠ¢ eâ‚‚ : Ï„â‚
      ç”±IH: eâ‚æ˜¯å€¼æˆ–eâ‚ â†’ eâ‚'
            eâ‚‚æ˜¯å€¼æˆ–eâ‚‚ â†’ eâ‚‚'
      
      å­æƒ…å†µ1: eâ‚ â†’ eâ‚'
        ç”±(E-APP1): eâ‚ eâ‚‚ â†’ eâ‚' eâ‚‚ âœ“
        
      å­æƒ…å†µ2: eâ‚æ˜¯å€¼ï¼Œeâ‚‚ â†’ eâ‚‚'
        ç”±(E-APP2): vâ‚ eâ‚‚ â†’ vâ‚ eâ‚‚' âœ“
        
      å­æƒ…å†µ3: eâ‚å’Œeâ‚‚éƒ½æ˜¯å€¼
        eâ‚å¿…ä¸ºÎ»æŠ½è±¡ï¼ˆç”±Canonical Formså¼•ç†ï¼‰
        eâ‚ = Î»x:Ï„.eâ‚ƒ
        ç”±(E-APPABS): (Î»x:Ï„.eâ‚ƒ) vâ‚‚ â†’ [xâ†¦vâ‚‚]eâ‚ƒ âœ“
        
    Case e = if eâ‚ then eâ‚‚ else eâ‚ƒ:
      ç±»ä¼¼åˆ†æ...
```

#### ä¿å‹æ€§è¯æ˜è¯¦ç»†

```
è¯æ˜ (Preservation): å¯¹e â†’ e'çš„å½’çº³
  Case (E-APPABS): (Î»x:Ï„â‚.e) v â†’ [xâ†¦v]e
    å·²çŸ¥: Î“ âŠ¢ (Î»x:Ï„â‚.e) v : Ï„â‚‚
    ç”±typing inversion:
      Î“ âŠ¢ Î»x:Ï„â‚.e : Ï„â‚ â†’ Ï„â‚‚
      Î“ âŠ¢ v : Ï„â‚
    ç”±(T-ABS) inversion:
      Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚
    
    éœ€è¯: Î“ âŠ¢ [xâ†¦v]e : Ï„â‚‚
    
    å¼•ç† (Substitution):
      å¦‚æœ Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚ ä¸” Î“ âŠ¢ v : Ï„â‚
      åˆ™ Î“ âŠ¢ [xâ†¦v]e : Ï„â‚‚
      
    åº”ç”¨Substitutionå¼•ç† âœ“
    
  Case (E-APP1): eâ‚ eâ‚‚ â†’ eâ‚' eâ‚‚
    å·²çŸ¥: Î“ âŠ¢ eâ‚ eâ‚‚ : Ï„â‚‚
          eâ‚ â†’ eâ‚'
    ç”±typing inversion:
      Î“ âŠ¢ eâ‚ : Ï„â‚ â†’ Ï„â‚‚
      Î“ âŠ¢ eâ‚‚ : Ï„â‚
    ç”±IH: Î“ âŠ¢ eâ‚' : Ï„â‚ â†’ Ï„â‚‚
    ç”±(T-APP): Î“ âŠ¢ eâ‚' eâ‚‚ : Ï„â‚‚ âœ“
```

#### åœ¨OTLPä¸­çš„åº”ç”¨

**Spanå¤„ç†çš„å¥å£®æ€§**:
```typescript
// å®šä¹‰ç±»å‹å®‰å…¨çš„Spanå¤„ç†ç³»ç»Ÿ
type Typed<T> = { _type: unique symbol; value: T };

// ç±»å‹åŒ–çš„SpanID
type SpanID = Typed<string> & { __brand: 'SpanID' };

// å¥å£®çš„Spanç±»å‹
interface TypedSpan {
  spanId: SpanID;
  traceId: TraceID;
  startTime: Timestamp;
  endTime: Timestamp;
}

// å¥å£®æ€§ä¿è¯ï¼šç±»å‹æ­£ç¡®çš„æ“ä½œä¸ä¼šè¿è¡Œæ—¶å‡ºé”™
function processSpan(span: TypedSpan): ProcessedSpan {
  // ç±»å‹ç³»ç»Ÿä¿è¯:
  // 1. span.spanIdä¸€å®šæ˜¯SpanIDç±»å‹
  // 2. span.startTimeå’ŒendTimeä¸€å®šæ˜¯Timestamp
  // 3. ä¸ä¼šå‡ºç°undefinedæˆ–nullï¼ˆé™¤éæ˜¾å¼æ ‡è®°ï¼‰
  
  return {
    id: span.spanId,
    duration: span.endTime - span.startTime,  // å®‰å…¨ï¼šéƒ½æ˜¯number
    // ç±»å‹ç³»ç»Ÿé˜»æ­¢ï¼šspan.nonexistentField (ç¼–è¯‘é”™è¯¯)
  };
}

// è¯æ˜ï¼šå¦‚æœç¼–è¯‘é€šè¿‡ï¼Œåˆ™è¿è¡Œæ—¶ä¸ä¼šæœ‰ç±»å‹é”™è¯¯
```

**è¿›å±•æ€§åœ¨OTLPä¸­çš„ä½“ç°**:
```typescript
// çŠ¶æ€æœºï¼šä¿è¯æ€»èƒ½ç»§ç»­æ‰§è¡Œæˆ–åˆ°è¾¾æœ€ç»ˆçŠ¶æ€
type SpanState =
  | { stage: 'received'; data: RawSpan }
  | { stage: 'validated'; data: ValidatedSpan }
  | { stage: 'processed'; data: ProcessedSpan }
  | { stage: 'stored'; result: StorageResult };

// è¿›å±•æ€§ï¼šæ¯ä¸ªéæœ€ç»ˆçŠ¶æ€éƒ½æœ‰ä¸‹ä¸€æ­¥
function progress(state: SpanState): SpanState | 'done' {
  switch (state.stage) {
    case 'received':
      return { stage: 'validated', data: validate(state.data) };
    case 'validated':
      return { stage: 'processed', data: process(state.data) };
    case 'processed':
      return { stage: 'stored', result: store(state.data) };
    case 'stored':
      return 'done';  // æœ€ç»ˆçŠ¶æ€
  }
}
```

#### ç›¸å…³æ¦‚å¿µ
- â† [ç±»å‹å®‰å…¨](#14-ç±»å‹å®‰å…¨-type-safety)
- â†’ [å®Œå¤‡æ€§è¯æ˜](#42-å®Œå¤‡æ€§è¯æ˜-completeness-proof)

---

## ğŸ“Š æ¦‚å¿µç»Ÿè®¡

### è¦†ç›–æ¦‚å¿µ
- **ç±»å‹ç³»ç»Ÿ**: 6ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼ˆç±»å‹ã€ç±»å‹æ£€æŸ¥ã€ç±»å‹æ¨å¯¼ã€ç±»å‹å®‰å…¨ã€å¤šæ€ç±»å‹ã€ç±»å‹çº¦æŸï¼‰
- **æ“ä½œè¯­ä¹‰**: 3ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼ˆå½’çº¦å…³ç³»ã€æ±‚å€¼ç­–ç•¥ã€èŒƒå¼ï¼‰
- **ä»£æ•°æ¡†æ¶**: 1ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼ˆä»£æ•°æ•°æ®ç±»å‹ï¼‰
- **å½¢å¼åŒ–è¯æ˜**: 1ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼ˆå¥å£®æ€§è¯æ˜ï¼‰

### æ€»è®¡
- **11ä¸ªä¸»è¦æ¦‚å¿µ**
- **~3,800è¡Œå†…å®¹**
- **30+ä¸ªä»£ç ç¤ºä¾‹**
- **15+ä¸ªå½¢å¼åŒ–å®šä¹‰**
- **8ä¸ªMermaidå›¾è¡¨**

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- â† [åŸºç¡€æ¦‚å¿µç´¢å¼•](./01_åŸºç¡€æ¦‚å¿µ.md)
- â†’ [å®ç°æ¦‚å¿µç´¢å¼•](./03_å®ç°æ¦‚å¿µ.md)
- â†’ [æ¦‚å¿µå…³ç³»å›¾](./04_æ¦‚å¿µå…³ç³»å›¾.md)
- â†— [ç†è®ºåŸºç¡€çŸ¥è¯†å›¾è°±](../02_çŸ¥è¯†å›¾è°±/03_ç†è®ºåŸºç¡€çŸ¥è¯†å›¾è°±.md)

---

**æœ€åæ›´æ–°**: 2025-10-26  
**ç»´æŠ¤**: OTLPé¡¹ç›®ç»„  
**ç‰ˆæœ¬**: v1.0

