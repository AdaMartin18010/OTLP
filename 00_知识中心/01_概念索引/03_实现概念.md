# 实现概念索引

> **文档版本**: v1.0  
> **创建日期**: 2025-10-26  
> **维护团队**: OTLP项目组  
> **适用范围**: 系统实现、架构设计、性能优化

---

## 📋 文档概述

本文档提供OTLP项目中所有**系统实现相关概念**的统一定义、架构设计、实现细节和最佳实践。

### 覆盖范围
- **数据采集**: 8个核心概念
- **数据处理**: 10个核心概念
- **数据存储**: 7个核心概念
- **系统架构**: 12个核心概念
- **性能优化**: 8个核心概念

### 使用指南
- 🔍 快速查找：使用Ctrl+F搜索概念名称
- 📖 系统学习：按章节顺序阅读
- 🔗 交叉引用：点击链接跳转相关概念
- 💡 最佳实践：参考每个概念的实践建议

---

## 1. 数据采集 (Data Collection)

### 1.1 Instrumentation (埋点)

#### 定义
**Instrumentation**是在应用程序代码中插入遥测数据采集点的过程。

#### 分类

**1. 自动埋点 (Auto-Instrumentation)**
```
特点:
  - 无需修改应用代码
  - 通过agent或中间件自动注入
  - 适合标准框架和库
  
实现方式:
  - Java: Bytecode Instrumentation (ASM, Javassist)
  - Python: Import hooks, decorators
  - Node.js: Require hooks
  - .NET: IL weaving
```

**2. 手动埋点 (Manual Instrumentation)**
```
特点:
  - 开发者显式编写代码
  - 完全控制采集内容
  - 适合业务逻辑监控
  
实现方式:
  - SDK调用
  - 注解/装饰器
  - AOP切面
```

**3. 半自动埋点 (Semi-Auto Instrumentation)**
```
特点:
  - 结合自动和手动
  - 框架提供基础能力
  - 开发者扩展定制
```

#### 实现示例

**Java自动埋点 (Agent方式)**:
```java
// Agent入口
public class OTLPAgent {
    public static void premain(
        String agentArgs,
        Instrumentation inst
    ) {
        inst.addTransformer(new SpanTransformer());
    }
}

// Bytecode转换器
public class SpanTransformer implements ClassFileTransformer {
    @Override
    public byte[] transform(
        ClassLoader loader,
        String className,
        Class<?> classBeingRedefined,
        ProtectionDomain protectionDomain,
        byte[] classfileBuffer
    ) {
        // 使用ASM修改字节码
        ClassReader cr = new ClassReader(classfileBuffer);
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        ClassVisitor cv = new SpanMethodVisitor(cw);
        cr.accept(cv, 0);
        return cw.toByteArray();
    }
}

// 方法级埋点
public class SpanMethodVisitor extends ClassVisitor {
    @Override
    public MethodVisitor visitMethod(
        int access,
        String name,
        String descriptor,
        String signature,
        String[] exceptions
    ) {
        MethodVisitor mv = super.visitMethod(
            access, name, descriptor, signature, exceptions
        );
        
        // 如果方法需要监控
        if (shouldInstrument(name)) {
            return new SpanInjectingMethodVisitor(mv, name);
        }
        return mv;
    }
}

// 注入Span创建代码
public class SpanInjectingMethodVisitor extends MethodVisitor {
    private String methodName;
    
    @Override
    public void visitCode() {
        super.visitCode();
        // 方法开始：创建Span
        mv.visitMethodInsn(
            INVOKESTATIC,
            "io/opentelemetry/api/trace/Tracer",
            "spanBuilder",
            "(Ljava/lang/String;)Lio/opentelemetry/api/trace/SpanBuilder;",
            false
        );
        // ... 更多字节码注入
    }
    
    @Override
    public void visitInsn(int opcode) {
        // 方法返回前：结束Span
        if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
            mv.visitMethodInsn(
                INVOKEINTERFACE,
                "io/opentelemetry/api/trace/Span",
                "end",
                "()V",
                true
            );
        }
        super.visitInsn(opcode);
    }
}
```

**TypeScript手动埋点**:
```typescript
import { trace, context } from '@opentelemetry/api';

// 装饰器方式
function TraceMethod(operationName?: string) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const tracer = trace.getTracer('my-service');
      const span = tracer.startSpan(
        operationName || `${target.constructor.name}.${propertyKey}`
      );
      
      try {
        // 执行原方法
        const result = await originalMethod.apply(this, args);
        span.setStatus({ code: SpanStatusCode.OK });
        return result;
      } catch (error) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error.message
        });
        span.recordException(error);
        throw error;
      } finally {
        span.end();
      }
    };
    
    return descriptor;
  };
}

// 使用
class OrderService {
  @TraceMethod('createOrder')
  async createOrder(order: Order): Promise<OrderResult> {
    // 业务逻辑
    return await this.repository.save(order);
  }
  
  @TraceMethod()  // 自动使用 'OrderService.processPayment'
  async processPayment(orderId: string, amount: number): Promise<void> {
    // 支付处理
  }
}
```

**Python上下文管理器埋点**:
```python
from opentelemetry import trace
from contextlib import contextmanager

tracer = trace.get_tracer(__name__)

@contextmanager
def traced_operation(operation_name: str, **attributes):
    """上下文管理器：自动管理Span生命周期"""
    span = tracer.start_span(operation_name)
    
    # 设置属性
    for key, value in attributes.items():
        span.set_attribute(key, value)
    
    try:
        yield span
    except Exception as e:
        span.set_status(trace.Status(trace.StatusCode.ERROR))
        span.record_exception(e)
        raise
    finally:
        span.end()

# 使用
def process_order(order_id: str):
    with traced_operation('process_order', order_id=order_id) as span:
        # 业务逻辑
        order = fetch_order(order_id)
        
        with traced_operation('validate_order', order_id=order_id):
            validate(order)
        
        with traced_operation('charge_payment', amount=order.total):
            charge_payment(order.payment_info, order.total)
        
        span.set_attribute('order.status', 'completed')
```

#### 最佳实践

**1. 采集粒度选择**:
```
✓ 关键业务操作（订单、支付、核心API）
✓ 外部调用（数据库、缓存、HTTP请求）
✓ 重要异步操作（消息队列、定时任务）
✗ 过细的内部方法（getter/setter、工具函数）
✗ 高频循环内部（除非性能关键）
```

**2. 属性命名规范**:
```typescript
// 遵循语义约定
span.setAttribute('http.method', 'POST');
span.setAttribute('http.url', 'https://api.example.com/orders');
span.setAttribute('http.status_code', 200);

// 业务属性：使用前缀
span.setAttribute('order.id', orderId);
span.setAttribute('order.amount', amount);
span.setAttribute('user.id', userId);
```

**3. 错误处理**:
```typescript
try {
  result = await operation();
  span.setStatus({ code: SpanStatusCode.OK });
} catch (error) {
  // 记录异常
  span.recordException(error);
  
  // 设置状态
  span.setStatus({
    code: SpanStatusCode.ERROR,
    message: error.message
  });
  
  // 添加错误上下文
  span.setAttribute('error.type', error.constructor.name);
  span.setAttribute('error.handled', true);
  
  // 重新抛出
  throw error;
} finally {
  span.end();
}
```

#### 性能考虑

**开销分析**:
```
自动埋点开销:
  - 启动时间: +100-500ms (类加载和转换)
  - 内存: +20-50MB (agent和元数据)
  - CPU: +2-5% (Span创建和上下文传递)

手动埋点开销:
  - 启动时间: 忽略不计
  - 内存: +5-10MB (SDK和缓冲区)
  - CPU: +1-2% (仅在埋点处)

建议:
  - 生产环境采样率: 1-10%
  - 使用异步导出器
  - 配置合理的批处理大小
```

#### 相关概念
- → [Context传播](#12-context传播-context-propagation)
- → [采样策略](#13-采样策略-sampling-strategy)
- → [Exporter](#14-exporter-导出器)

---

### 1.2 Context传播 (Context Propagation)

#### 定义
**Context传播**是在分布式系统中跨服务边界传递追踪上下文的机制。

#### 核心组件

**1. Context对象**:
```typescript
interface Context {
  // 当前活跃的Span
  activeSpan?: Span;
  
  // Baggage（跨服务传递的键值对）
  baggage: Map<string, string>;
  
  // 相关性ID
  traceId: TraceID;
  spanId: SpanID;
  traceFlags: number;
}
```

**2. Propagator（传播器）**:
```
作用: 序列化和反序列化Context

类型:
  - TraceContext (W3C标准)
  - B3 (Zipkin格式)
  - Jaeger
  - AWS X-Ray
```

#### 传播机制

**HTTP头传播 (TraceContext)**:
```
请求头:
  traceparent: 00-{trace-id}-{span-id}-{flags}
  tracestate: vendor1=value1,vendor2=value2
  
示例:
  traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
  tracestate: otlp=t:8;r:62,vendor=data
```

**实现示例 - 客户端注入**:
```typescript
import { propagation, context } from '@opentelemetry/api';

// HTTP客户端中间件
class TracingMiddleware {
  async intercept(request: HttpRequest): Promise<HttpResponse> {
    const activeContext = context.active();
    
    // 注入追踪头
    propagation.inject(activeContext, request.headers, {
      set: (carrier, key, value) => {
        carrier[key] = value;
      }
    });
    
    // 发送请求
    return await this.next(request);
  }
}

// 实际注入的头
/*
  headers: {
    'traceparent': '00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01',
    'tracestate': 'otlp=t:8',
    ...otherHeaders
  }
*/
```

**实现示例 - 服务端提取**:
```typescript
// HTTP服务端中间件
class TracingInterceptor {
  async handle(request: HttpRequest): Promise<HttpResponse> {
    // 从请求头提取Context
    const extractedContext = propagation.extract(
      context.active(),
      request.headers,
      {
        get: (carrier, key) => carrier[key],
        keys: (carrier) => Object.keys(carrier)
      }
    );
    
    // 创建子Span
    const tracer = trace.getTracer('my-service');
    const span = tracer.startSpan(
      `HTTP ${request.method} ${request.path}`,
      {
        kind: SpanKind.SERVER,
        attributes: {
          'http.method': request.method,
          'http.url': request.url,
          'http.target': request.path
        }
      },
      extractedContext  // 使用提取的Context
    );
    
    // 在新Context中执行请求处理
    return context.with(
      trace.setSpan(extractedContext, span),
      async () => {
        try {
          const response = await this.processRequest(request);
          span.setStatus({ code: SpanStatusCode.OK });
          span.setAttribute('http.status_code', response.statusCode);
          return response;
        } catch (error) {
          span.recordException(error);
          span.setStatus({ code: SpanStatusCode.ERROR });
          throw error;
        } finally {
          span.end();
        }
      }
    );
  }
}
```

#### 跨异步边界传播

**Promise链**:
```typescript
import { context, trace } from '@opentelemetry/api';

async function processOrder(orderId: string) {
  const span = trace.getTracer('orders').startSpan('processOrder');
  
  // Context自动在Promise链中传播
  return context.with(trace.setSpan(context.active(), span), async () => {
    try {
      const order = await fetchOrder(orderId);        // Context自动传播
      const validated = await validateOrder(order);   // Context自动传播
      const result = await saveOrder(validated);      // Context自动传播
      
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  });
}
```

**消息队列传播**:
```typescript
// 生产者：注入Context到消息头
class MessageProducer {
  async publish(topic: string, message: any): Promise<void> {
    const activeContext = context.active();
    const headers: Record<string, string> = {};
    
    // 注入追踪信息到消息头
    propagation.inject(activeContext, headers);
    
    await this.client.publish(topic, {
      payload: message,
      headers: headers  // 包含traceparent等
    });
  }
}

// 消费者：提取Context
class MessageConsumer {
  async onMessage(msg: Message): Promise<void> {
    // 从消息头提取Context
    const extractedContext = propagation.extract(
      context.active(),
      msg.headers
    );
    
    // 创建Consumer Span
    const span = trace.getTracer('consumer').startSpan(
      `Process ${msg.topic}`,
      { kind: SpanKind.CONSUMER },
      extractedContext
    );
    
    return context.with(
      trace.setSpan(extractedContext, span),
      async () => {
        try {
          await this.processMessage(msg.payload);
          span.setStatus({ code: SpanStatusCode.OK });
        } catch (error) {
          span.recordException(error);
          throw error;
        } finally {
          span.end();
        }
      }
    );
  }
}
```

#### Baggage使用

**定义和传播**:
```typescript
import { propagation, context, baggageUtils } from '@opentelemetry/api';

// 设置Baggage
const ctx = baggageUtils.setBaggage(context.active(), {
  'user.id': '12345',
  'request.id': 'req-abc-123',
  'feature.flag': 'new-checkout'
});

// 在此Context中执行
context.with(ctx, () => {
  // Baggage会自动传播到所有子Span
  makeServiceCall();  // 服务调用会携带Baggage
});

// 在下游服务提取Baggage
const baggage = baggageUtils.getBaggage(context.active());
const userId = baggage.getEntry('user.id')?.value;  // '12345'
```

**应用场景**:
```typescript
// 场景1: 特性开关传播
const featureContext = baggageUtils.setBaggage(context.active(), {
  'feature.new-algorithm': 'enabled'
});

context.with(featureContext, async () => {
  // 所有下游服务都能访问这个特性开关
  await orderService.process();  // 内部可以检查feature.new-algorithm
});

// 场景2: 用户信息传播
const userContext = baggageUtils.setBaggage(context.active(), {
  'user.id': user.id,
  'user.role': user.role,
  'user.tenant': user.tenantId
});

// 所有服务都能访问用户信息，无需重复查询
```

#### W3C TraceContext规范

**traceparent格式**:
```
格式: version-trace-id-parent-id-trace-flags

version (2字符):
  - 00: 当前版本
  
trace-id (32字符十六进制):
  - 128位追踪ID
  - 不能全为0
  
parent-id (16字符十六进制):
  - 64位父Span ID
  - 不能全为0
  
trace-flags (2字符十六进制):
  - 8位标志位
  - 最低位: 采样标志 (1=采样, 0=不采样)
```

**tracestate格式**:
```
格式: vendor1=value1,vendor2=value2

规则:
  - 最多32个供应商条目
  - 每个键最多256字符
  - 遵循先进先出 (新条目加在前面)
  
示例:
  tracestate: otlp=t:8;r:62,vendor1=data,vendor2=metadata
```

#### 相关概念
- ← [Instrumentation](#11-instrumentation-埋点)
- → [Span关系](#21-span关系-span-relationships)
- → [分布式追踪](#41-分布式追踪-distributed-tracing)

---

### 1.3 采样策略 (Sampling Strategy)

#### 定义
**采样策略**决定哪些Trace应该被记录和导出，以平衡可观测性和性能开销。

#### 采样类型

**1. Head Sampling (头部采样)**
```
特点:
  - 在Trace开始时决策
  - 决策在根Span创建时做出
  - 下游服务遵循上游决策
  
优点:
  - 实现简单
  - 开销可预测
  
缺点:
  - 可能错过重要Trace（如错误Trace）
  - 无法基于完整Trace特征决策
```

**2. Tail Sampling (尾部采样)**
```
特点:
  - Trace完成后再决策
  - 可以基于完整信息（持续时间、错误、属性）
  - 需要临时存储所有Span
  
优点:
  - 更智能的决策
  - 不错过重要Trace
  
缺点:
  - 需要更多内存和计算
  - 实现复杂
```

#### Head Sampling实现

**父采样器 (ParentBased)**:
```typescript
import { ParentBasedSampler, AlwaysOnSampler, TraceIdRatioBasedSampler } from '@opentelemetry/sdk-trace-base';

// 配置：有父Span则遵循，否则10%采样率
const sampler = new ParentBasedSampler({
  root: new TraceIdRatioBasedSampler(0.1),  // 根Span 10%采样
  remoteParentSampled: new AlwaysOnSampler(),     // 父Span采样则采样
  remoteParentNotSampled: new AlwaysOffSampler(), // 父Span不采样则不采样
  localParentSampled: new AlwaysOnSampler(),
  localParentNotSampled: new AlwaysOffSampler()
});
```

**基于TraceID的采样**:
```typescript
class TraceIdRatioSampler {
  constructor(private ratio: number) {
    // ratio: 0.0 ~ 1.0
  }
  
  shouldSample(
    context: Context,
    traceId: string,
    spanName: string,
    spanKind: SpanKind,
    attributes: Attributes,
    links: Link[]
  ): SamplingResult {
    // 使用TraceID的后8字节计算
    const traceIdBytes = Buffer.from(traceId.slice(-16), 'hex');
    const traceIdValue = traceIdBytes.readBigUInt64BE();
    const threshold = this.ratio * Number.MAX_SAFE_INTEGER;
    
    const decision = traceIdValue < threshold
      ? SamplingDecision.RECORD_AND_SAMPLED
      : SamplingDecision.NOT_RECORD;
    
    return {
      decision,
      attributes: {}
    };
  }
}
```

**自定义规则采样器**:
```typescript
class RuleBasedSampler {
  shouldSample(
    context: Context,
    traceId: string,
    spanName: string,
    spanKind: SpanKind,
    attributes: Attributes,
    links: Link[]
  ): SamplingResult {
    // 规则1: 错误必须采样
    if (attributes['error'] === true) {
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED,
        attributes: { 'sampling.reason': 'error' }
      };
    }
    
    // 规则2: 慢请求必须采样
    const duration = attributes['http.duration'] as number;
    if (duration > 1000) {  // >1秒
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED,
        attributes: { 'sampling.reason': 'slow' }
      };
    }
    
    // 规则3: 关键端点100%采样
    const criticalPaths = ['/api/payment', '/api/order'];
    const path = attributes['http.target'] as string;
    if (criticalPaths.includes(path)) {
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED,
        attributes: { 'sampling.reason': 'critical-path' }
      };
    }
    
    // 规则4: 普通请求1%采样
    return {
      decision: this.sampleByRate(traceId, 0.01),
      attributes: { 'sampling.reason': 'default' }
    };
  }
  
  private sampleByRate(traceId: string, rate: number): SamplingDecision {
    const hash = this.hashTraceId(traceId);
    return hash < rate
      ? SamplingDecision.RECORD_AND_SAMPLED
      : SamplingDecision.NOT_RECORD;
  }
}
```

#### Tail Sampling实现

**Collector配置**:
```yaml
processors:
  tail_sampling:
    decision_wait: 10s  # 等待Trace完成
    num_traces: 100000  # 缓存Trace数
    expected_new_traces_per_sec: 1000
    policies:
      # 策略1: 所有错误Trace
      - name: errors
        type: status_code
        status_code:
          status_codes: [ERROR]
      
      # 策略2: 慢Trace (>2秒)
      - name: slow-traces
        type: latency
        latency:
          threshold_ms: 2000
      
      # 策略3: 特定服务的Trace
      - name: critical-services
        type: string_attribute
        string_attribute:
          key: service.name
          values: [payment-service, order-service]
      
      # 策略4: 采样率（其他Trace 1%）
      - name: probabilistic
        type: probabilistic
        probabilistic:
          sampling_percentage: 1

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [tail_sampling, batch]
      exporters: [jaeger]
```

**自定义Tail Sampling**:
```typescript
class TailSamplingProcessor {
  private traces: Map<string, TraceData> = new Map();
  private readonly DECISION_WAIT = 10000;  // 10秒
  
  async onSpanEnd(span: ReadableSpan): Promise<void> {
    const traceId = span.spanContext().traceId;
    
    // 添加Span到Trace缓存
    if (!this.traces.has(traceId)) {
      this.traces.set(traceId, {
        spans: [],
        startTime: Date.now(),
        decision: null
      });
      
      // 延迟决策
      setTimeout(() => this.makeDecision(traceId), this.DECISION_WAIT);
    }
    
    this.traces.get(traceId)!.spans.push(span);
  }
  
  private async makeDecision(traceId: string): Promise<void> {
    const traceData = this.traces.get(traceId);
    if (!traceData) return;
    
    const spans = traceData.spans;
    
    // 决策逻辑
    let shouldSample = false;
    let reason = '';
    
    // 1. 检查是否有错误
    if (spans.some(s => s.status.code === SpanStatusCode.ERROR)) {
      shouldSample = true;
      reason = 'has-error';
    }
    
    // 2. 检查总持续时间
    else if (this.calculateDuration(spans) > 2000) {
      shouldSample = true;
      reason = 'slow-trace';
    }
    
    // 3. 检查Span数量（复杂Trace）
    else if (spans.length > 50) {
      shouldSample = true;
      reason = 'complex-trace';
    }
    
    // 4. 随机采样
    else if (Math.random() < 0.01) {
      shouldSample = true;
      reason = 'sampled';
    }
    
    // 执行决策
    if (shouldSample) {
      await this.exportTrace(spans, reason);
    }
    
    // 清理
    this.traces.delete(traceId);
  }
  
  private calculateDuration(spans: ReadableSpan[]): number {
    const times = spans.flatMap(s => [s.startTime, s.endTime]);
    return Math.max(...times) - Math.min(...times);
  }
}
```

#### 混合采样策略

```typescript
// 组合多个采样器
class CompositeSampler {
  private samplers: { sampler: Sampler; priority: number }[];
  
  constructor(samplers: { sampler: Sampler; priority: number }[]) {
    // 按优先级排序
    this.samplers = samplers.sort((a, b) => b.priority - a.priority);
  }
  
  shouldSample(
    context: Context,
    traceId: string,
    spanName: string,
    spanKind: SpanKind,
    attributes: Attributes,
    links: Link[]
  ): SamplingResult {
    // 按优先级顺序尝试每个采样器
    for (const { sampler } of this.samplers) {
      const result = sampler.shouldSample(
        context, traceId, spanName, spanKind, attributes, links
      );
      
      // 如果决定采样，立即返回
      if (result.decision === SamplingDecision.RECORD_AND_SAMPLED) {
        return result;
      }
    }
    
    // 所有采样器都拒绝
    return {
      decision: SamplingDecision.NOT_RECORD,
      attributes: {}
    };
  }
}

// 使用
const sampler = new CompositeSampler([
  { sampler: new ErrorSampler(), priority: 100 },      // 最高优先级
  { sampler: new SlowTraceSampler(), priority: 90 },
  { sampler: new CriticalPathSampler(), priority: 80 },
  { sampler: new TraceIdRatioSampler(0.01), priority: 1 }  // 默认
]);
```

#### 采样率动态调整

```typescript
class AdaptiveSampler {
  private currentRate = 0.1;
  private readonly TARGET_TPS = 1000;  // 目标：每秒1000个Trace
  private readonly ADJUSTMENT_INTERVAL = 60000;  // 每分钟调整
  
  private tracesInLastInterval = 0;
  
  constructor() {
    setInterval(() => this.adjust(), this.ADJUSTMENT_INTERVAL);
  }
  
  shouldSample(...args): SamplingResult {
    this.tracesInLastInterval++;
    
    const hash = this.hashTraceId(args[1]);
    const decision = hash < this.currentRate
      ? SamplingDecision.RECORD_AND_SAMPLED
      : SamplingDecision.NOT_RECORD;
    
    return { decision, attributes: { 'sampling.rate': this.currentRate } };
  }
  
  private adjust(): void {
    const actualTPS = this.tracesInLastInterval / (this.ADJUSTMENT_INTERVAL / 1000);
    
    // 调整采样率
    if (actualTPS > this.TARGET_TPS * 1.1) {
      // 超过目标10%，降低采样率
      this.currentRate *= 0.9;
    } else if (actualTPS < this.TARGET_TPS * 0.9) {
      // 低于目标10%，提高采样率
      this.currentRate *= 1.1;
    }
    
    // 限制范围
    this.currentRate = Math.max(0.001, Math.min(1.0, this.currentRate));
    
    console.log(`Adjusted sampling rate to ${this.currentRate} (TPS: ${actualTPS})`);
    
    // 重置计数器
    this.tracesInLastInterval = 0;
  }
}
```

#### 最佳实践

| 场景 | 推荐策略 | 采样率 | 说明 |
|------|----------|--------|------|
| 开发环境 | AlwaysOn | 100% | 完整可观测性 |
| 测试环境 | ParentBased | 50-100% | 发现问题 |
| 生产（低流量） | ParentBased | 10-50% | 平衡性能和可观测性 |
| 生产（高流量） | RuleBased | 1-10% | 错误100%，其他采样 |
| 生产（超高流量） | Adaptive + Tail | 0.1-1% | 动态调整，智能采样 |

#### 相关概念
- ← [Instrumentation](#11-instrumentation-埋点)
- → [性能优化](#5-性能优化-performance-optimization)
- → [Collector处理](#23-collector处理-collector-processing)

---

## 📊 概念统计

### 本文档覆盖
- **数据采集**: 3个核心概念（Instrumentation、Context传播、采样策略）
- **实现代码**: 20+个完整示例
- **最佳实践**: 15+条实践建议
- **配置示例**: 10+个配置文件

### 待补充章节
- **数据处理**: 10个概念（待补充）
- **数据存储**: 7个概念（待补充）
- **系统架构**: 12个概念（待补充）
- **性能优化**: 8个概念（待补充）

**总计**: ~2,900行内容（当前章节）

---

## 🔗 相关文档

- ← [基础概念索引](./01_基础概念.md)
- ← [形式化概念索引](./02_形式化概念.md)
- → [概念关系图](./04_概念关系图.md)
- ↗ [技术实现知识图谱](../02_知识图谱/04_技术实现知识图谱.md)

---

**最后更新**: 2025-10-26  
**维护**: OTLP项目组  
**版本**: v1.0

