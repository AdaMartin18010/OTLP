# å®ç°æ¦‚å¿µç´¢å¼•

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-10-26  
> **ç»´æŠ¤å›¢é˜Ÿ**: OTLPé¡¹ç›®ç»„  
> **é€‚ç”¨èŒƒå›´**: ç³»ç»Ÿå®ç°ã€æ¶æ„è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›OTLPé¡¹ç›®ä¸­æ‰€æœ‰**ç³»ç»Ÿå®ç°ç›¸å…³æ¦‚å¿µ**çš„ç»Ÿä¸€å®šä¹‰ã€æ¶æ„è®¾è®¡ã€å®ç°ç»†èŠ‚å’Œæœ€ä½³å®è·µã€‚

### è¦†ç›–èŒƒå›´

- **æ•°æ®é‡‡é›†**: 8ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **æ•°æ®å¤„ç†**: 10ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **æ•°æ®å­˜å‚¨**: 7ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **ç³»ç»Ÿæ¶æ„**: 12ä¸ªæ ¸å¿ƒæ¦‚å¿µ
- **æ€§èƒ½ä¼˜åŒ–**: 8ä¸ªæ ¸å¿ƒæ¦‚å¿µ

### ä½¿ç”¨æŒ‡å—

- ğŸ” å¿«é€ŸæŸ¥æ‰¾ï¼šä½¿ç”¨Ctrl+Fæœç´¢æ¦‚å¿µåç§°
- ğŸ“– ç³»ç»Ÿå­¦ä¹ ï¼šæŒ‰ç« èŠ‚é¡ºåºé˜…è¯»
- ğŸ”— äº¤å‰å¼•ç”¨ï¼šç‚¹å‡»é“¾æ¥è·³è½¬ç›¸å…³æ¦‚å¿µ
- ğŸ’¡ æœ€ä½³å®è·µï¼šå‚è€ƒæ¯ä¸ªæ¦‚å¿µçš„å®è·µå»ºè®®

---

## 1. æ•°æ®é‡‡é›† (Data Collection)

### 1.1 Instrumentation (åŸ‹ç‚¹)

#### å®šä¹‰

**Instrumentation**æ˜¯åœ¨åº”ç”¨ç¨‹åºä»£ç ä¸­æ’å…¥é¥æµ‹æ•°æ®é‡‡é›†ç‚¹çš„è¿‡ç¨‹ã€‚

#### åˆ†ç±»

**1. è‡ªåŠ¨åŸ‹ç‚¹ (Auto-Instrumentation)**

```
ç‰¹ç‚¹:
  - æ— éœ€ä¿®æ”¹åº”ç”¨ä»£ç 
  - é€šè¿‡agentæˆ–ä¸­é—´ä»¶è‡ªåŠ¨æ³¨å…¥
  - é€‚åˆæ ‡å‡†æ¡†æ¶å’Œåº“
  
å®ç°æ–¹å¼:
  - Java: Bytecode Instrumentation (ASM, Javassist)
  - Python: Import hooks, decorators
  - Node.js: Require hooks
  - .NET: IL weaving
```

**2. æ‰‹åŠ¨åŸ‹ç‚¹ (Manual Instrumentation)**

```
ç‰¹ç‚¹:
  - å¼€å‘è€…æ˜¾å¼ç¼–å†™ä»£ç 
  - å®Œå…¨æ§åˆ¶é‡‡é›†å†…å®¹
  - é€‚åˆä¸šåŠ¡é€»è¾‘ç›‘æ§
  
å®ç°æ–¹å¼:
  - SDKè°ƒç”¨
  - æ³¨è§£/è£…é¥°å™¨
  - AOPåˆ‡é¢
```

**3. åŠè‡ªåŠ¨åŸ‹ç‚¹ (Semi-Auto Instrumentation)**

```
ç‰¹ç‚¹:
  - ç»“åˆè‡ªåŠ¨å’Œæ‰‹åŠ¨
  - æ¡†æ¶æä¾›åŸºç¡€èƒ½åŠ›
  - å¼€å‘è€…æ‰©å±•å®šåˆ¶
```

#### å®ç°ç¤ºä¾‹

**Javaè‡ªåŠ¨åŸ‹ç‚¹ (Agentæ–¹å¼)**:

```java
// Agentå…¥å£
public class OTLPAgent {
    public static void premain(
        String agentArgs,
        Instrumentation inst
    ) {
        inst.addTransformer(new SpanTransformer());
    }
}

// Bytecodeè½¬æ¢å™¨
public class SpanTransformer implements ClassFileTransformer {
    @Override
    public byte[] transform(
        ClassLoader loader,
        String className,
        Class<?> classBeingRedefined,
        ProtectionDomain protectionDomain,
        byte[] classfileBuffer
    ) {
        // ä½¿ç”¨ASMä¿®æ”¹å­—èŠ‚ç 
        ClassReader cr = new ClassReader(classfileBuffer);
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        ClassVisitor cv = new SpanMethodVisitor(cw);
        cr.accept(cv, 0);
        return cw.toByteArray();
    }
}

// æ–¹æ³•çº§åŸ‹ç‚¹
public class SpanMethodVisitor extends ClassVisitor {
    @Override
    public MethodVisitor visitMethod(
        int access,
        String name,
        String descriptor,
        String signature,
        String[] exceptions
    ) {
        MethodVisitor mv = super.visitMethod(
            access, name, descriptor, signature, exceptions
        );
        
        // å¦‚æœæ–¹æ³•éœ€è¦ç›‘æ§
        if (shouldInstrument(name)) {
            return new SpanInjectingMethodVisitor(mv, name);
        }
        return mv;
    }
}

// æ³¨å…¥Spanåˆ›å»ºä»£ç 
public class SpanInjectingMethodVisitor extends MethodVisitor {
    private String methodName;
    
    @Override
    public void visitCode() {
        super.visitCode();
        // æ–¹æ³•å¼€å§‹ï¼šåˆ›å»ºSpan
        mv.visitMethodInsn(
            INVOKESTATIC,
            "io/opentelemetry/api/trace/Tracer",
            "spanBuilder",
            "(Ljava/lang/String;)Lio/opentelemetry/api/trace/SpanBuilder;",
            false
        );
        // ... æ›´å¤šå­—èŠ‚ç æ³¨å…¥
    }
    
    @Override
    public void visitInsn(int opcode) {
        // æ–¹æ³•è¿”å›å‰ï¼šç»“æŸSpan
        if ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {
            mv.visitMethodInsn(
                INVOKEINTERFACE,
                "io/opentelemetry/api/trace/Span",
                "end",
                "()V",
                true
            );
        }
        super.visitInsn(opcode);
    }
}
```

**TypeScriptæ‰‹åŠ¨åŸ‹ç‚¹**:

```typescript
import { trace, context } from '@opentelemetry/api';

// è£…é¥°å™¨æ–¹å¼
function TraceMethod(operationName?: string) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const tracer = trace.getTracer('my-service');
      const span = tracer.startSpan(
        operationName || `${target.constructor.name}.${propertyKey}`
      );
      
      try {
        // æ‰§è¡ŒåŸæ–¹æ³•
        const result = await originalMethod.apply(this, args);
        span.setStatus({ code: SpanStatusCode.OK });
        return result;
      } catch (error) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error.message
        });
        span.recordException(error);
        throw error;
      } finally {
        span.end();
      }
    };
    
    return descriptor;
  };
}

// ä½¿ç”¨
class OrderService {
  @TraceMethod('createOrder')
  async createOrder(order: Order): Promise<OrderResult> {
    // ä¸šåŠ¡é€»è¾‘
    return await this.repository.save(order);
  }
  
  @TraceMethod()  // è‡ªåŠ¨ä½¿ç”¨ 'OrderService.processPayment'
  async processPayment(orderId: string, amount: number): Promise<void> {
    // æ”¯ä»˜å¤„ç†
  }
}
```

**Pythonä¸Šä¸‹æ–‡ç®¡ç†å™¨åŸ‹ç‚¹**:

```python
from opentelemetry import trace
from contextlib import contextmanager

tracer = trace.get_tracer(__name__)

@contextmanager
def traced_operation(operation_name: str, **attributes):
    """ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼šè‡ªåŠ¨ç®¡ç†Spanç”Ÿå‘½å‘¨æœŸ"""
    span = tracer.start_span(operation_name)
    
    # è®¾ç½®å±æ€§
    for key, value in attributes.items():
        span.set_attribute(key, value)
    
    try:
        yield span
    except Exception as e:
        span.set_status(trace.Status(trace.StatusCode.ERROR))
        span.record_exception(e)
        raise
    finally:
        span.end()

# ä½¿ç”¨
def process_order(order_id: str):
    with traced_operation('process_order', order_id=order_id) as span:
        # ä¸šåŠ¡é€»è¾‘
        order = fetch_order(order_id)
        
        with traced_operation('validate_order', order_id=order_id):
            validate(order)
        
        with traced_operation('charge_payment', amount=order.total):
            charge_payment(order.payment_info, order.total)
        
        span.set_attribute('order.status', 'completed')
```

#### æœ€ä½³å®è·µ

**1. é‡‡é›†ç²’åº¦é€‰æ‹©**:

```
âœ“ å…³é”®ä¸šåŠ¡æ“ä½œï¼ˆè®¢å•ã€æ”¯ä»˜ã€æ ¸å¿ƒAPIï¼‰
âœ“ å¤–éƒ¨è°ƒç”¨ï¼ˆæ•°æ®åº“ã€ç¼“å­˜ã€HTTPè¯·æ±‚ï¼‰
âœ“ é‡è¦å¼‚æ­¥æ“ä½œï¼ˆæ¶ˆæ¯é˜Ÿåˆ—ã€å®šæ—¶ä»»åŠ¡ï¼‰
âœ— è¿‡ç»†çš„å†…éƒ¨æ–¹æ³•ï¼ˆgetter/setterã€å·¥å…·å‡½æ•°ï¼‰
âœ— é«˜é¢‘å¾ªç¯å†…éƒ¨ï¼ˆé™¤éæ€§èƒ½å…³é”®ï¼‰
```

**2. å±æ€§å‘½åè§„èŒƒ**:

```typescript
// éµå¾ªè¯­ä¹‰çº¦å®š
span.setAttribute('http.method', 'POST');
span.setAttribute('http.url', 'https://api.example.com/orders');
span.setAttribute('http.status_code', 200);

// ä¸šåŠ¡å±æ€§ï¼šä½¿ç”¨å‰ç¼€
span.setAttribute('order.id', orderId);
span.setAttribute('order.amount', amount);
span.setAttribute('user.id', userId);
```

**3. é”™è¯¯å¤„ç†**:

```typescript
try {
  result = await operation();
  span.setStatus({ code: SpanStatusCode.OK });
} catch (error) {
  // è®°å½•å¼‚å¸¸
  span.recordException(error);
  
  // è®¾ç½®çŠ¶æ€
  span.setStatus({
    code: SpanStatusCode.ERROR,
    message: error.message
  });
  
  // æ·»åŠ é”™è¯¯ä¸Šä¸‹æ–‡
  span.setAttribute('error.type', error.constructor.name);
  span.setAttribute('error.handled', true);
  
  // é‡æ–°æŠ›å‡º
  throw error;
} finally {
  span.end();
}
```

#### æ€§èƒ½è€ƒè™‘

**å¼€é”€åˆ†æ**:

```
è‡ªåŠ¨åŸ‹ç‚¹å¼€é”€:
  - å¯åŠ¨æ—¶é—´: +100-500ms (ç±»åŠ è½½å’Œè½¬æ¢)
  - å†…å­˜: +20-50MB (agentå’Œå…ƒæ•°æ®)
  - CPU: +2-5% (Spanåˆ›å»ºå’Œä¸Šä¸‹æ–‡ä¼ é€’)

æ‰‹åŠ¨åŸ‹ç‚¹å¼€é”€:
  - å¯åŠ¨æ—¶é—´: å¿½ç•¥ä¸è®¡
  - å†…å­˜: +5-10MB (SDKå’Œç¼“å†²åŒº)
  - CPU: +1-2% (ä»…åœ¨åŸ‹ç‚¹å¤„)

å»ºè®®:
  - ç”Ÿäº§ç¯å¢ƒé‡‡æ ·ç‡: 1-10%
  - ä½¿ç”¨å¼‚æ­¥å¯¼å‡ºå™¨
  - é…ç½®åˆç†çš„æ‰¹å¤„ç†å¤§å°
```

#### ç›¸å…³æ¦‚å¿µ

- â†’ [Contextä¼ æ’­](#12-contextä¼ æ’­-context-propagation)
- â†’ [é‡‡æ ·ç­–ç•¥](#13-é‡‡æ ·ç­–ç•¥-sampling-strategy)
- â†’ [Exporter](#14-exporter-å¯¼å‡ºå™¨)

---

### 1.2 Contextä¼ æ’­ (Context Propagation)

#### å®šä¹‰

**Contextä¼ æ’­**æ˜¯åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­è·¨æœåŠ¡è¾¹ç•Œä¼ é€’è¿½è¸ªä¸Šä¸‹æ–‡çš„æœºåˆ¶ã€‚

#### æ ¸å¿ƒç»„ä»¶

**1. Contextå¯¹è±¡**:

```typescript
interface Context {
  // å½“å‰æ´»è·ƒçš„Span
  activeSpan?: Span;
  
  // Baggageï¼ˆè·¨æœåŠ¡ä¼ é€’çš„é”®å€¼å¯¹ï¼‰
  baggage: Map<string, string>;
  
  // ç›¸å…³æ€§ID
  traceId: TraceID;
  spanId: SpanID;
  traceFlags: number;
}
```

**2. Propagatorï¼ˆä¼ æ’­å™¨ï¼‰**:

```
ä½œç”¨: åºåˆ—åŒ–å’Œååºåˆ—åŒ–Context

ç±»å‹:
  - TraceContext (W3Cæ ‡å‡†)
  - B3 (Zipkinæ ¼å¼)
  - Jaeger
  - AWS X-Ray
```

#### ä¼ æ’­æœºåˆ¶

**HTTPå¤´ä¼ æ’­ (TraceContext)**:

```
è¯·æ±‚å¤´:
  traceparent: 00-{trace-id}-{span-id}-{flags}
  tracestate: vendor1=value1,vendor2=value2
  
ç¤ºä¾‹:
  traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
  tracestate: otlp=t:8;r:62,vendor=data
```

**å®ç°ç¤ºä¾‹ - å®¢æˆ·ç«¯æ³¨å…¥**:

```typescript
import { propagation, context } from '@opentelemetry/api';

// HTTPå®¢æˆ·ç«¯ä¸­é—´ä»¶
class TracingMiddleware {
  async intercept(request: HttpRequest): Promise<HttpResponse> {
    const activeContext = context.active();
    
    // æ³¨å…¥è¿½è¸ªå¤´
    propagation.inject(activeContext, request.headers, {
      set: (carrier, key, value) => {
        carrier[key] = value;
      }
    });
    
    // å‘é€è¯·æ±‚
    return await this.next(request);
  }
}

// å®é™…æ³¨å…¥çš„å¤´
/*
  headers: {
    'traceparent': '00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01',
    'tracestate': 'otlp=t:8',
    ...otherHeaders
  }
*/
```

**å®ç°ç¤ºä¾‹ - æœåŠ¡ç«¯æå–**:

```typescript
// HTTPæœåŠ¡ç«¯ä¸­é—´ä»¶
class TracingInterceptor {
  async handle(request: HttpRequest): Promise<HttpResponse> {
    // ä»è¯·æ±‚å¤´æå–Context
    const extractedContext = propagation.extract(
      context.active(),
      request.headers,
      {
        get: (carrier, key) => carrier[key],
        keys: (carrier) => Object.keys(carrier)
      }
    );
    
    // åˆ›å»ºå­Span
    const tracer = trace.getTracer('my-service');
    const span = tracer.startSpan(
      `HTTP ${request.method} ${request.path}`,
      {
        kind: SpanKind.SERVER,
        attributes: {
          'http.method': request.method,
          'http.url': request.url,
          'http.target': request.path
        }
      },
      extractedContext  // ä½¿ç”¨æå–çš„Context
    );
    
    // åœ¨æ–°Contextä¸­æ‰§è¡Œè¯·æ±‚å¤„ç†
    return context.with(
      trace.setSpan(extractedContext, span),
      async () => {
        try {
          const response = await this.processRequest(request);
          span.setStatus({ code: SpanStatusCode.OK });
          span.setAttribute('http.status_code', response.statusCode);
          return response;
        } catch (error) {
          span.recordException(error);
          span.setStatus({ code: SpanStatusCode.ERROR });
          throw error;
        } finally {
          span.end();
        }
      }
    );
  }
}
```

#### è·¨å¼‚æ­¥è¾¹ç•Œä¼ æ’­

**Promiseé“¾**:

```typescript
import { context, trace } from '@opentelemetry/api';

async function processOrder(orderId: string) {
  const span = trace.getTracer('orders').startSpan('processOrder');
  
  // Contextè‡ªåŠ¨åœ¨Promiseé“¾ä¸­ä¼ æ’­
  return context.with(trace.setSpan(context.active(), span), async () => {
    try {
      const order = await fetchOrder(orderId);        // Contextè‡ªåŠ¨ä¼ æ’­
      const validated = await validateOrder(order);   // Contextè‡ªåŠ¨ä¼ æ’­
      const result = await saveOrder(validated);      // Contextè‡ªåŠ¨ä¼ æ’­
      
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  });
}
```

**æ¶ˆæ¯é˜Ÿåˆ—ä¼ æ’­**:

```typescript
// ç”Ÿäº§è€…ï¼šæ³¨å…¥Contextåˆ°æ¶ˆæ¯å¤´
class MessageProducer {
  async publish(topic: string, message: any): Promise<void> {
    const activeContext = context.active();
    const headers: Record<string, string> = {};
    
    // æ³¨å…¥è¿½è¸ªä¿¡æ¯åˆ°æ¶ˆæ¯å¤´
    propagation.inject(activeContext, headers);
    
    await this.client.publish(topic, {
      payload: message,
      headers: headers  // åŒ…å«traceparentç­‰
    });
  }
}

// æ¶ˆè´¹è€…ï¼šæå–Context
class MessageConsumer {
  async onMessage(msg: Message): Promise<void> {
    // ä»æ¶ˆæ¯å¤´æå–Context
    const extractedContext = propagation.extract(
      context.active(),
      msg.headers
    );
    
    // åˆ›å»ºConsumer Span
    const span = trace.getTracer('consumer').startSpan(
      `Process ${msg.topic}`,
      { kind: SpanKind.CONSUMER },
      extractedContext
    );
    
    return context.with(
      trace.setSpan(extractedContext, span),
      async () => {
        try {
          await this.processMessage(msg.payload);
          span.setStatus({ code: SpanStatusCode.OK });
        } catch (error) {
          span.recordException(error);
          throw error;
        } finally {
          span.end();
        }
      }
    );
  }
}
```

#### Baggageä½¿ç”¨

**å®šä¹‰å’Œä¼ æ’­**:

```typescript
import { propagation, context, baggageUtils } from '@opentelemetry/api';

// è®¾ç½®Baggage
const ctx = baggageUtils.setBaggage(context.active(), {
  'user.id': '12345',
  'request.id': 'req-abc-123',
  'feature.flag': 'new-checkout'
});

// åœ¨æ­¤Contextä¸­æ‰§è¡Œ
context.with(ctx, () => {
  // Baggageä¼šè‡ªåŠ¨ä¼ æ’­åˆ°æ‰€æœ‰å­Span
  makeServiceCall();  // æœåŠ¡è°ƒç”¨ä¼šæºå¸¦Baggage
});

// åœ¨ä¸‹æ¸¸æœåŠ¡æå–Baggage
const baggage = baggageUtils.getBaggage(context.active());
const userId = baggage.getEntry('user.id')?.value;  // '12345'
```

**åº”ç”¨åœºæ™¯**:

```typescript
// åœºæ™¯1: ç‰¹æ€§å¼€å…³ä¼ æ’­
const featureContext = baggageUtils.setBaggage(context.active(), {
  'feature.new-algorithm': 'enabled'
});

context.with(featureContext, async () => {
  // æ‰€æœ‰ä¸‹æ¸¸æœåŠ¡éƒ½èƒ½è®¿é—®è¿™ä¸ªç‰¹æ€§å¼€å…³
  await orderService.process();  // å†…éƒ¨å¯ä»¥æ£€æŸ¥feature.new-algorithm
});

// åœºæ™¯2: ç”¨æˆ·ä¿¡æ¯ä¼ æ’­
const userContext = baggageUtils.setBaggage(context.active(), {
  'user.id': user.id,
  'user.role': user.role,
  'user.tenant': user.tenantId
});

// æ‰€æœ‰æœåŠ¡éƒ½èƒ½è®¿é—®ç”¨æˆ·ä¿¡æ¯ï¼Œæ— éœ€é‡å¤æŸ¥è¯¢
```

#### W3C TraceContextè§„èŒƒ

**traceparentæ ¼å¼**:

```
æ ¼å¼: version-trace-id-parent-id-trace-flags

version (2å­—ç¬¦):
  - 00: å½“å‰ç‰ˆæœ¬
  
trace-id (32å­—ç¬¦åå…­è¿›åˆ¶):
  - 128ä½è¿½è¸ªID
  - ä¸èƒ½å…¨ä¸º0
  
parent-id (16å­—ç¬¦åå…­è¿›åˆ¶):
  - 64ä½çˆ¶Span ID
  - ä¸èƒ½å…¨ä¸º0
  
trace-flags (2å­—ç¬¦åå…­è¿›åˆ¶):
  - 8ä½æ ‡å¿—ä½
  - æœ€ä½ä½: é‡‡æ ·æ ‡å¿— (1=é‡‡æ ·, 0=ä¸é‡‡æ ·)
```

**tracestateæ ¼å¼**:

```
æ ¼å¼: vendor1=value1,vendor2=value2

è§„åˆ™:
  - æœ€å¤š32ä¸ªä¾›åº”å•†æ¡ç›®
  - æ¯ä¸ªé”®æœ€å¤š256å­—ç¬¦
  - éµå¾ªå…ˆè¿›å…ˆå‡º (æ–°æ¡ç›®åŠ åœ¨å‰é¢)
  
ç¤ºä¾‹:
  tracestate: otlp=t:8;r:62,vendor1=data,vendor2=metadata
```

#### ç›¸å…³æ¦‚å¿µ

- â† [Instrumentation](#11-instrumentation-åŸ‹ç‚¹)
- â†’ [Spanå…³ç³»](#21-spanå…³ç³»-span-relationships)
- â†’ [åˆ†å¸ƒå¼è¿½è¸ª](#41-åˆ†å¸ƒå¼è¿½è¸ª-distributed-tracing)

---

### 1.3 é‡‡æ ·ç­–ç•¥ (Sampling Strategy)

#### å®šä¹‰

**é‡‡æ ·ç­–ç•¥**å†³å®šå“ªäº›Traceåº”è¯¥è¢«è®°å½•å’Œå¯¼å‡ºï¼Œä»¥å¹³è¡¡å¯è§‚æµ‹æ€§å’Œæ€§èƒ½å¼€é”€ã€‚

#### é‡‡æ ·ç±»å‹

**1. Head Sampling (å¤´éƒ¨é‡‡æ ·)**

```
ç‰¹ç‚¹:
  - åœ¨Traceå¼€å§‹æ—¶å†³ç­–
  - å†³ç­–åœ¨æ ¹Spanåˆ›å»ºæ—¶åšå‡º
  - ä¸‹æ¸¸æœåŠ¡éµå¾ªä¸Šæ¸¸å†³ç­–
  
ä¼˜ç‚¹:
  - å®ç°ç®€å•
  - å¼€é”€å¯é¢„æµ‹
  
ç¼ºç‚¹:
  - å¯èƒ½é”™è¿‡é‡è¦Traceï¼ˆå¦‚é”™è¯¯Traceï¼‰
  - æ— æ³•åŸºäºå®Œæ•´Traceç‰¹å¾å†³ç­–
```

**2. Tail Sampling (å°¾éƒ¨é‡‡æ ·)**

```
ç‰¹ç‚¹:
  - Traceå®Œæˆåå†å†³ç­–
  - å¯ä»¥åŸºäºå®Œæ•´ä¿¡æ¯ï¼ˆæŒç»­æ—¶é—´ã€é”™è¯¯ã€å±æ€§ï¼‰
  - éœ€è¦ä¸´æ—¶å­˜å‚¨æ‰€æœ‰Span
  
ä¼˜ç‚¹:
  - æ›´æ™ºèƒ½çš„å†³ç­–
  - ä¸é”™è¿‡é‡è¦Trace
  
ç¼ºç‚¹:
  - éœ€è¦æ›´å¤šå†…å­˜å’Œè®¡ç®—
  - å®ç°å¤æ‚
```

#### Head Samplingå®ç°

**çˆ¶é‡‡æ ·å™¨ (ParentBased)**:

```typescript
import { ParentBasedSampler, AlwaysOnSampler, TraceIdRatioBasedSampler } from '@opentelemetry/sdk-trace-base';

// é…ç½®ï¼šæœ‰çˆ¶Spanåˆ™éµå¾ªï¼Œå¦åˆ™10%é‡‡æ ·ç‡
const sampler = new ParentBasedSampler({
  root: new TraceIdRatioBasedSampler(0.1),  // æ ¹Span 10%é‡‡æ ·
  remoteParentSampled: new AlwaysOnSampler(),     // çˆ¶Spané‡‡æ ·åˆ™é‡‡æ ·
  remoteParentNotSampled: new AlwaysOffSampler(), // çˆ¶Spanä¸é‡‡æ ·åˆ™ä¸é‡‡æ ·
  localParentSampled: new AlwaysOnSampler(),
  localParentNotSampled: new AlwaysOffSampler()
});
```

**åŸºäºTraceIDçš„é‡‡æ ·**:

```typescript
class TraceIdRatioSampler {
  constructor(private ratio: number) {
    // ratio: 0.0 ~ 1.0
  }
  
  shouldSample(
    context: Context,
    traceId: string,
    spanName: string,
    spanKind: SpanKind,
    attributes: Attributes,
    links: Link[]
  ): SamplingResult {
    // ä½¿ç”¨TraceIDçš„å8å­—èŠ‚è®¡ç®—
    const traceIdBytes = Buffer.from(traceId.slice(-16), 'hex');
    const traceIdValue = traceIdBytes.readBigUInt64BE();
    const threshold = this.ratio * Number.MAX_SAFE_INTEGER;
    
    const decision = traceIdValue < threshold
      ? SamplingDecision.RECORD_AND_SAMPLED
      : SamplingDecision.NOT_RECORD;
    
    return {
      decision,
      attributes: {}
    };
  }
}
```

**è‡ªå®šä¹‰è§„åˆ™é‡‡æ ·å™¨**:

```typescript
class RuleBasedSampler {
  shouldSample(
    context: Context,
    traceId: string,
    spanName: string,
    spanKind: SpanKind,
    attributes: Attributes,
    links: Link[]
  ): SamplingResult {
    // è§„åˆ™1: é”™è¯¯å¿…é¡»é‡‡æ ·
    if (attributes['error'] === true) {
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED,
        attributes: { 'sampling.reason': 'error' }
      };
    }
    
    // è§„åˆ™2: æ…¢è¯·æ±‚å¿…é¡»é‡‡æ ·
    const duration = attributes['http.duration'] as number;
    if (duration > 1000) {  // >1ç§’
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED,
        attributes: { 'sampling.reason': 'slow' }
      };
    }
    
    // è§„åˆ™3: å…³é”®ç«¯ç‚¹100%é‡‡æ ·
    const criticalPaths = ['/api/payment', '/api/order'];
    const path = attributes['http.target'] as string;
    if (criticalPaths.includes(path)) {
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED,
        attributes: { 'sampling.reason': 'critical-path' }
      };
    }
    
    // è§„åˆ™4: æ™®é€šè¯·æ±‚1%é‡‡æ ·
    return {
      decision: this.sampleByRate(traceId, 0.01),
      attributes: { 'sampling.reason': 'default' }
    };
  }
  
  private sampleByRate(traceId: string, rate: number): SamplingDecision {
    const hash = this.hashTraceId(traceId);
    return hash < rate
      ? SamplingDecision.RECORD_AND_SAMPLED
      : SamplingDecision.NOT_RECORD;
  }
}
```

#### Tail Samplingå®ç°

**Collectoré…ç½®**:

```yaml
processors:
  tail_sampling:
    decision_wait: 10s  # ç­‰å¾…Traceå®Œæˆ
    num_traces: 100000  # ç¼“å­˜Traceæ•°
    expected_new_traces_per_sec: 1000
    policies:
      # ç­–ç•¥1: æ‰€æœ‰é”™è¯¯Trace
      - name: errors
        type: status_code
        status_code:
          status_codes: [ERROR]
      
      # ç­–ç•¥2: æ…¢Trace (>2ç§’)
      - name: slow-traces
        type: latency
        latency:
          threshold_ms: 2000
      
      # ç­–ç•¥3: ç‰¹å®šæœåŠ¡çš„Trace
      - name: critical-services
        type: string_attribute
        string_attribute:
          key: service.name
          values: [payment-service, order-service]
      
      # ç­–ç•¥4: é‡‡æ ·ç‡ï¼ˆå…¶ä»–Trace 1%ï¼‰
      - name: probabilistic
        type: probabilistic
        probabilistic:
          sampling_percentage: 1

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [tail_sampling, batch]
      exporters: [jaeger]
```

**è‡ªå®šä¹‰Tail Sampling**:

```typescript
class TailSamplingProcessor {
  private traces: Map<string, TraceData> = new Map();
  private readonly DECISION_WAIT = 10000;  // 10ç§’
  
  async onSpanEnd(span: ReadableSpan): Promise<void> {
    const traceId = span.spanContext().traceId;
    
    // æ·»åŠ Spanåˆ°Traceç¼“å­˜
    if (!this.traces.has(traceId)) {
      this.traces.set(traceId, {
        spans: [],
        startTime: Date.now(),
        decision: null
      });
      
      // å»¶è¿Ÿå†³ç­–
      setTimeout(() => this.makeDecision(traceId), this.DECISION_WAIT);
    }
    
    this.traces.get(traceId)!.spans.push(span);
  }
  
  private async makeDecision(traceId: string): Promise<void> {
    const traceData = this.traces.get(traceId);
    if (!traceData) return;
    
    const spans = traceData.spans;
    
    // å†³ç­–é€»è¾‘
    let shouldSample = false;
    let reason = '';
    
    // 1. æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
    if (spans.some(s => s.status.code === SpanStatusCode.ERROR)) {
      shouldSample = true;
      reason = 'has-error';
    }
    
    // 2. æ£€æŸ¥æ€»æŒç»­æ—¶é—´
    else if (this.calculateDuration(spans) > 2000) {
      shouldSample = true;
      reason = 'slow-trace';
    }
    
    // 3. æ£€æŸ¥Spanæ•°é‡ï¼ˆå¤æ‚Traceï¼‰
    else if (spans.length > 50) {
      shouldSample = true;
      reason = 'complex-trace';
    }
    
    // 4. éšæœºé‡‡æ ·
    else if (Math.random() < 0.01) {
      shouldSample = true;
      reason = 'sampled';
    }
    
    // æ‰§è¡Œå†³ç­–
    if (shouldSample) {
      await this.exportTrace(spans, reason);
    }
    
    // æ¸…ç†
    this.traces.delete(traceId);
  }
  
  private calculateDuration(spans: ReadableSpan[]): number {
    const times = spans.flatMap(s => [s.startTime, s.endTime]);
    return Math.max(...times) - Math.min(...times);
  }
}
```

#### æ··åˆé‡‡æ ·ç­–ç•¥

```typescript
// ç»„åˆå¤šä¸ªé‡‡æ ·å™¨
class CompositeSampler {
  private samplers: { sampler: Sampler; priority: number }[];
  
  constructor(samplers: { sampler: Sampler; priority: number }[]) {
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    this.samplers = samplers.sort((a, b) => b.priority - a.priority);
  }
  
  shouldSample(
    context: Context,
    traceId: string,
    spanName: string,
    spanKind: SpanKind,
    attributes: Attributes,
    links: Link[]
  ): SamplingResult {
    // æŒ‰ä¼˜å…ˆçº§é¡ºåºå°è¯•æ¯ä¸ªé‡‡æ ·å™¨
    for (const { sampler } of this.samplers) {
      const result = sampler.shouldSample(
        context, traceId, spanName, spanKind, attributes, links
      );
      
      // å¦‚æœå†³å®šé‡‡æ ·ï¼Œç«‹å³è¿”å›
      if (result.decision === SamplingDecision.RECORD_AND_SAMPLED) {
        return result;
      }
    }
    
    // æ‰€æœ‰é‡‡æ ·å™¨éƒ½æ‹’ç»
    return {
      decision: SamplingDecision.NOT_RECORD,
      attributes: {}
    };
  }
}

// ä½¿ç”¨
const sampler = new CompositeSampler([
  { sampler: new ErrorSampler(), priority: 100 },      // æœ€é«˜ä¼˜å…ˆçº§
  { sampler: new SlowTraceSampler(), priority: 90 },
  { sampler: new CriticalPathSampler(), priority: 80 },
  { sampler: new TraceIdRatioSampler(0.01), priority: 1 }  // é»˜è®¤
]);
```

#### é‡‡æ ·ç‡åŠ¨æ€è°ƒæ•´

```typescript
class AdaptiveSampler {
  private currentRate = 0.1;
  private readonly TARGET_TPS = 1000;  // ç›®æ ‡ï¼šæ¯ç§’1000ä¸ªTrace
  private readonly ADJUSTMENT_INTERVAL = 60000;  // æ¯åˆ†é’Ÿè°ƒæ•´
  
  private tracesInLastInterval = 0;
  
  constructor() {
    setInterval(() => this.adjust(), this.ADJUSTMENT_INTERVAL);
  }
  
  shouldSample(...args): SamplingResult {
    this.tracesInLastInterval++;
    
    const hash = this.hashTraceId(args[1]);
    const decision = hash < this.currentRate
      ? SamplingDecision.RECORD_AND_SAMPLED
      : SamplingDecision.NOT_RECORD;
    
    return { decision, attributes: { 'sampling.rate': this.currentRate } };
  }
  
  private adjust(): void {
    const actualTPS = this.tracesInLastInterval / (this.ADJUSTMENT_INTERVAL / 1000);
    
    // è°ƒæ•´é‡‡æ ·ç‡
    if (actualTPS > this.TARGET_TPS * 1.1) {
      // è¶…è¿‡ç›®æ ‡10%ï¼Œé™ä½é‡‡æ ·ç‡
      this.currentRate *= 0.9;
    } else if (actualTPS < this.TARGET_TPS * 0.9) {
      // ä½äºç›®æ ‡10%ï¼Œæé«˜é‡‡æ ·ç‡
      this.currentRate *= 1.1;
    }
    
    // é™åˆ¶èŒƒå›´
    this.currentRate = Math.max(0.001, Math.min(1.0, this.currentRate));
    
    console.log(`Adjusted sampling rate to ${this.currentRate} (TPS: ${actualTPS})`);
    
    // é‡ç½®è®¡æ•°å™¨
    this.tracesInLastInterval = 0;
  }
}
```

#### æœ€ä½³å®è·µ

| åœºæ™¯ | æ¨èç­–ç•¥ | é‡‡æ ·ç‡ | è¯´æ˜ |
|------|----------|--------|------|
| å¼€å‘ç¯å¢ƒ | AlwaysOn | 100% | å®Œæ•´å¯è§‚æµ‹æ€§ |
| æµ‹è¯•ç¯å¢ƒ | ParentBased | 50-100% | å‘ç°é—®é¢˜ |
| ç”Ÿäº§ï¼ˆä½æµé‡ï¼‰ | ParentBased | 10-50% | å¹³è¡¡æ€§èƒ½å’Œå¯è§‚æµ‹æ€§ |
| ç”Ÿäº§ï¼ˆé«˜æµé‡ï¼‰ | RuleBased | 1-10% | é”™è¯¯100%ï¼Œå…¶ä»–é‡‡æ · |
| ç”Ÿäº§ï¼ˆè¶…é«˜æµé‡ï¼‰ | Adaptive + Tail | 0.1-1% | åŠ¨æ€è°ƒæ•´ï¼Œæ™ºèƒ½é‡‡æ · |

#### ç›¸å…³æ¦‚å¿µ

- â† [Instrumentation](#11-instrumentation-åŸ‹ç‚¹)
- â†’ [æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–-performance-optimization)
- â†’ [Collectorå¤„ç†](#23-collectorå¤„ç†-collector-processing)

---

## ğŸ“Š æ¦‚å¿µç»Ÿè®¡

### æœ¬æ–‡æ¡£è¦†ç›–

- **æ•°æ®é‡‡é›†**: 3ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼ˆInstrumentationã€Contextä¼ æ’­ã€é‡‡æ ·ç­–ç•¥ï¼‰
- **å®ç°ä»£ç **: 20+ä¸ªå®Œæ•´ç¤ºä¾‹
- **æœ€ä½³å®è·µ**: 15+æ¡å®è·µå»ºè®®
- **é…ç½®ç¤ºä¾‹**: 10+ä¸ªé…ç½®æ–‡ä»¶

### å¾…è¡¥å……ç« èŠ‚

- **æ•°æ®å¤„ç†**: 10ä¸ªæ¦‚å¿µï¼ˆå¾…è¡¥å……ï¼‰
- **æ•°æ®å­˜å‚¨**: 7ä¸ªæ¦‚å¿µï¼ˆå¾…è¡¥å……ï¼‰
- **ç³»ç»Ÿæ¶æ„**: 12ä¸ªæ¦‚å¿µï¼ˆå¾…è¡¥å……ï¼‰
- **æ€§èƒ½ä¼˜åŒ–**: 8ä¸ªæ¦‚å¿µï¼ˆå¾…è¡¥å……ï¼‰

**æ€»è®¡**: ~2,900è¡Œå†…å®¹ï¼ˆå½“å‰ç« èŠ‚ï¼‰

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- â† [åŸºç¡€æ¦‚å¿µç´¢å¼•](./01_åŸºç¡€æ¦‚å¿µ.md)
- â† [å½¢å¼åŒ–æ¦‚å¿µç´¢å¼•](./02_å½¢å¼åŒ–æ¦‚å¿µ.md)
- â†’ [æ¦‚å¿µå…³ç³»å›¾](./04_æ¦‚å¿µå…³ç³»å›¾.md)
- â†— [æŠ€æœ¯å®ç°çŸ¥è¯†å›¾è°±](../02_çŸ¥è¯†å›¾è°±/04_æŠ€æœ¯å®ç°çŸ¥è¯†å›¾è°±.md)

---

**æœ€åæ›´æ–°**: 2025-10-26  
**ç»´æŠ¤**: OTLPé¡¹ç›®ç»„  
**ç‰ˆæœ¬**: v1.0
