# OTLPæ•°æ®å¤„ç†è§†è§’ï¼šæœ¬åœ°å¤„ç†ä¸ç¼“å†²æœºåˆ¶æ·±åº¦åˆ†æ

> **æ–‡æ¡£ç±»å‹**: æ•°æ®æ¨¡å‹æ·±åº¦åˆ†æ  
> **åˆ†æç»´åº¦**: æ•°æ®å¤„ç†è§†è§’ - æœ¬åœ°å¤„ç†ä¸ç¼“å†²æœºåˆ¶  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ11æ—¥  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [OTLPæ•°æ®å¤„ç†è§†è§’ï¼šæœ¬åœ°å¤„ç†ä¸ç¼“å†²æœºåˆ¶æ·±åº¦åˆ†æ](#otlpæ•°æ®å¤„ç†è§†è§’æœ¬åœ°å¤„ç†ä¸ç¼“å†²æœºåˆ¶æ·±åº¦åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ¯ æ‰§è¡Œæ‘˜è¦](#-æ‰§è¡Œæ‘˜è¦)
    - [æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯](#æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯)
  - [ğŸ“Š æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯](#-æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯)
    - [å¤„ç†ç±»å‹çŸ©é˜µ](#å¤„ç†ç±»å‹çŸ©é˜µ)
  - [ğŸ”„ï¸ æœ¬åœ°å¤„ç†](#ï¸-æœ¬åœ°å¤„ç†)
    - [é‡‡æ ·å¤„ç†](#é‡‡æ ·å¤„ç†)
    - [è¿‡æ»¤å¤„ç†](#è¿‡æ»¤å¤„ç†)
    - [èšåˆå¤„ç†](#èšåˆå¤„ç†)
  - [ğŸ“¦ ç¼“å†²æœºåˆ¶](#-ç¼“å†²æœºåˆ¶)
    - [å†…å­˜ç¼“å†²](#å†…å­˜ç¼“å†²)
    - [ç£ç›˜ç¼“å†²](#ç£ç›˜ç¼“å†²)
    - [æ··åˆç¼“å†²](#æ··åˆç¼“å†²)
  - [ğŸ“ˆ å¤„ç†ç¼“å†²æ€§èƒ½åˆ†æ](#-å¤„ç†ç¼“å†²æ€§èƒ½åˆ†æ)
    - [å¤„ç†ç¼“å†²æ€§èƒ½åŸºå‡†æµ‹è¯•](#å¤„ç†ç¼“å†²æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [âš¡ å¤„ç†ç¼“å†²ä¼˜åŒ–ç­–ç•¥](#-å¤„ç†ç¼“å†²ä¼˜åŒ–ç­–ç•¥)
    - [1. è‡ªé€‚åº”ç¼“å†²ç­–ç•¥](#1-è‡ªé€‚åº”ç¼“å†²ç­–ç•¥)
    - [2. æ‰¹é‡å¤„ç†ç­–ç•¥](#2-æ‰¹é‡å¤„ç†ç­–ç•¥)
    - [3. èƒŒå‹æ§åˆ¶ç­–ç•¥](#3-èƒŒå‹æ§åˆ¶ç­–ç•¥)
  - [ğŸ’¡ å®æˆ˜æ¡ˆä¾‹](#-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1ï¼šé«˜å¹¶å‘ç³»ç»Ÿæœ¬åœ°å¤„ç†](#æ¡ˆä¾‹1é«˜å¹¶å‘ç³»ç»Ÿæœ¬åœ°å¤„ç†)
    - [æ¡ˆä¾‹2ï¼šå¤§è§„æ¨¡ç³»ç»Ÿç¼“å†²ä¼˜åŒ–](#æ¡ˆä¾‹2å¤§è§„æ¨¡ç³»ç»Ÿç¼“å†²ä¼˜åŒ–)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [å¤„ç†ç¼“å†²ä¼˜åŒ–çŸ©é˜µ](#å¤„ç†ç¼“å†²ä¼˜åŒ–çŸ©é˜µ)
  - [ğŸ¯ æ€»ç»“](#-æ€»ç»“)

---

## ğŸ¯ æ‰§è¡Œæ‘˜è¦

### æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯

```text
æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          OTLPæœ¬åœ°å¤„ç†ä¸ç¼“å†²æœºåˆ¶ä½“ç³»                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  æœ¬åœ°å¤„ç†                                      â”‚      â”‚
â”‚  â”‚  - é‡‡æ ·å¤„ç†                                    â”‚      â”‚
â”‚  â”‚  - è¿‡æ»¤å¤„ç†                                    â”‚      â”‚
â”‚  â”‚  - èšåˆå¤„ç†                                    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                         â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚         â”‚               â”‚               â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ç¼“å†²æœºåˆ¶    â”‚  â”‚ å¤„ç†ç­–ç•¥    â”‚  â”‚ æ€§èƒ½ä¼˜åŒ–    â”‚        â”‚
â”‚  â”‚ - å†…å­˜ç¼“å†²  â”‚  â”‚ - è‡ªé€‚åº”    â”‚  â”‚ - æ‰¹é‡     â”‚        â”‚
â”‚  â”‚ - ç£ç›˜ç¼“å†²  â”‚  â”‚ - æ‰¹é‡     â”‚  â”‚ - å¹¶è¡Œ     â”‚        â”‚
â”‚  â”‚ - æ··åˆç¼“å†²  â”‚  â”‚ - èƒŒå‹     â”‚  â”‚ - å‹ç¼©     â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”˜â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  å¤„ç†åœºæ™¯                                      â”‚      â”‚
â”‚  â”‚  - é«˜å¹¶å‘                                      â”‚      â”‚
â”‚  â”‚  - å¤§è§„æ¨¡                                      â”‚      â”‚
â”‚  â”‚  - å®æ—¶æ€§                                      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒæ´å¯Ÿ**ï¼š

1. **æœ¬åœ°å¤„ç†**ï¼šé‡‡æ ·å¤„ç† + è¿‡æ»¤å¤„ç† + èšåˆå¤„ç†
2. **ç¼“å†²æœºåˆ¶**ï¼šå†…å­˜ç¼“å†² + ç£ç›˜ç¼“å†² + æ··åˆç¼“å†²
3. **å¤„ç†ç­–ç•¥**ï¼šè‡ªé€‚åº” + æ‰¹é‡ + èƒŒå‹
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡ + å¹¶è¡Œ + å‹ç¼©

---

## ğŸ“Š æœ¬åœ°å¤„ç†ä¸ç¼“å†²å…¨æ™¯

### å¤„ç†ç±»å‹çŸ©é˜µ

```text
å¤„ç†ç±»å‹çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¤„ç†ç±»å‹      â”‚ è¾“å…¥æ•°æ®    â”‚ è¾“å‡ºæ•°æ®    â”‚ æ•ˆæœ      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é‡‡æ ·å¤„ç†      â”‚ All Spans  â”‚ Sampled Spansâ”‚ å‡å°‘    â”‚
â”‚  è¿‡æ»¤å¤„ç†      â”‚ All Spans  â”‚ Filtered Spansâ”‚ å‡å°‘    â”‚
â”‚  èšåˆå¤„ç†      â”‚ All Spans  â”‚ Aggregated Spansâ”‚ å‡å°‘    â”‚
â”‚  å†…å­˜ç¼“å†²      â”‚ Spans[]    â”‚ Buffered Spansâ”‚ å»¶è¿Ÿ    â”‚
â”‚  ç£ç›˜ç¼“å†²      â”‚ Spans[]    â”‚ Persisted Spansâ”‚ æŒä¹…åŒ–  â”‚
â”‚  æ··åˆç¼“å†²      â”‚ Spans[]    â”‚ Hybrid Spansâ”‚ å¹³è¡¡    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ï¸ æœ¬åœ°å¤„ç†

### é‡‡æ ·å¤„ç†

```go
// é‡‡æ ·å¤„ç†
package main

import (
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// å¤´éƒ¨é‡‡æ ·
type HeadSampler struct {
    ratio float64
}

func NewHeadSampler(ratio float64) *HeadSampler {
    return &HeadSampler{
        ratio: ratio,
    }
}

func (hs *HeadSampler) ShouldSample(parameters trace.SamplingParameters) trace.SamplingResult {
    // åŸºäºé‡‡æ ·ç‡å†³ç­–
    if rand.Float64() < hs.ratio {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

// å°¾éƒ¨é‡‡æ ·
type TailSampler struct {
    maxSpans int
    buffer   []*trace.Span
    mutex    sync.Mutex
}

func NewTailSampler(maxSpans int) *TailSampler {
    return &TailSampler{
        maxSpans: maxSpans,
        buffer:   make([]*trace.Span, 0),
    }
}

func (ts *TailSampler) Sample(span *trace.Span) {
    ts.mutex.Lock()
    defer ts.mutex.Unlock()
    
    ts.buffer = append(ts.buffer, span)
    
    // å½“ç¼“å†²åŒºæ»¡æ—¶ï¼Œé‡‡æ ·å¹¶æ¸…ç©º
    if len(ts.buffer) >= ts.maxSpans {
        ts.flush()
    }
}

func (ts *TailSampler) flush() {
    // é‡‡æ ·ç­–ç•¥ï¼šä¿ç•™é”™è¯¯å’Œæ…¢è¯·æ±‚
    sampled := make([]*trace.Span, 0)
    
    for _, span := range ts.buffer {
        if span.Status().Code == trace.StatusCodeError ||
           span.EndTime().Sub(span.StartTime()) > 1*time.Second {
            sampled = append(sampled, span)
        }
    }
    
    // å‘é€é‡‡æ ·åçš„æ•°æ®
    sendToCollector(sampled)
    
    // æ¸…ç©ºç¼“å†²åŒº
    ts.buffer = ts.buffer[:0]
}

// è‡ªé€‚åº”é‡‡æ ·
type AdaptiveSampler struct {
    baseRatio float64
    currentRatio float64
    mutex sync.Mutex
}

func NewAdaptiveSampler(baseRatio float64) *AdaptiveSampler {
    return &AdaptiveSampler{
        baseRatio:    baseRatio,
        currentRatio: baseRatio,
    }
}

func (as *AdaptiveSampler) ShouldSample(parameters trace.SamplingParameters) trace.SamplingResult {
    as.mutex.Lock()
    defer as.mutex.Unlock()
    
    // æ ¹æ®ç³»ç»Ÿè´Ÿè½½è°ƒæ•´é‡‡æ ·ç‡
    load := getSystemLoad()
    if load > 0.8 {
        as.currentRatio = as.baseRatio * 0.5
    } else if load < 0.3 {
        as.currentRatio = as.baseRatio * 1.5
    } else {
        as.currentRatio = as.baseRatio
    }
    
    if rand.Float64() < as.currentRatio {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}
```

### è¿‡æ»¤å¤„ç†

```go
// è¿‡æ»¤å¤„ç†
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

// å±æ€§è¿‡æ»¤
type AttributeFilter struct {
    allowedKeys   map[string]bool
    blockedKeys   map[string]bool
}

func NewAttributeFilter() *AttributeFilter {
    return &AttributeFilter{
        allowedKeys: make(map[string]bool),
        blockedKeys: make(map[string]bool),
    }
}

func (af *AttributeFilter) AllowKey(key string) {
    af.allowedKeys[key] = true
}

func (af *AttributeFilter) BlockKey(key string) {
    af.blockedKeys[key] = true
}

func (af *AttributeFilter) FilterSpan(span *trace.Span) *trace.Span {
    // è¿‡æ»¤å±æ€§
    filteredAttributes := make([]attribute.KeyValue, 0)
    
    for _, attr := range span.Attributes() {
        key := string(attr.Key)
        
        // æ£€æŸ¥æ˜¯å¦å…è®¸
        if len(af.allowedKeys) > 0 && !af.allowedKeys[key] {
            continue
        }
        
        // æ£€æŸ¥æ˜¯å¦é˜»æ­¢
        if af.blockedKeys[key] {
            continue
        }
        
        filteredAttributes = append(filteredAttributes, attr)
    }
    
    // åˆ›å»ºè¿‡æ»¤åçš„Span
    return createFilteredSpan(span, filteredAttributes)
}

// æœåŠ¡è¿‡æ»¤
type ServiceFilter struct {
    allowedServices map[string]bool
    blockedServices map[string]bool
}

func NewServiceFilter() *ServiceFilter {
    return &ServiceFilter{
        allowedServices: make(map[string]bool),
        blockedServices: make(map[string]bool),
    }
}

func (sf *ServiceFilter) AllowService(service string) {
    sf.allowedServices[service] = true
}

func (sf *ServiceFilter) BlockService(service string) {
    sf.blockedServices[service] = true
}

func (sf *ServiceFilter) ShouldFilter(span *trace.Span) bool {
    serviceName := getServiceName(span)
    
    // æ£€æŸ¥æ˜¯å¦å…è®¸
    if len(sf.allowedServices) > 0 && !sf.allowedServices[serviceName] {
        return true
    }
    
    // æ£€æŸ¥æ˜¯å¦é˜»æ­¢
    if sf.blockedServices[serviceName] {
        return true
    }
    
    return false
}
```

### èšåˆå¤„ç†

```go
// èšåˆå¤„ç†
package main

import (
    "go.opentelemetry.io/otel/trace"
)

// æ—¶é—´èšåˆ
type TimeAggregator struct {
    windowSize time.Duration
    buckets    map[int64][]*trace.Span
    mutex      sync.Mutex
}

func NewTimeAggregator(windowSize time.Duration) *TimeAggregator {
    return &TimeAggregator{
        windowSize: windowSize,
        buckets:    make(map[int64][]*trace.Span),
    }
}

func (ta *TimeAggregator) Aggregate(span *trace.Span) {
    ta.mutex.Lock()
    defer ta.mutex.Unlock()
    
    // è®¡ç®—æ—¶é—´çª—å£
    window := span.StartTime().UnixNano() / int64(ta.windowSize)
    
    // æ·»åŠ åˆ°å¯¹åº”çš„æ¡¶
    ta.buckets[window] = append(ta.buckets[window], span)
}

func (ta *TimeAggregator) Flush() []*trace.Span {
    ta.mutex.Lock()
    defer ta.mutex.Unlock()
    
    // èšåˆæ‰€æœ‰æ¡¶
    aggregated := make([]*trace.Span, 0)
    
    for _, spans := range ta.buckets {
        // èšåˆç­–ç•¥ï¼šä¿ç•™é”™è¯¯å’Œæ…¢è¯·æ±‚
        for _, span := range spans {
            if span.Status().Code == trace.StatusCodeError ||
               span.EndTime().Sub(span.StartTime()) > 1*time.Second {
                aggregated = append(aggregated, span)
            }
        }
    }
    
    // æ¸…ç©ºæ¡¶
    ta.buckets = make(map[int64][]*trace.Span)
    
    return aggregated
}

// æœåŠ¡èšåˆ
type ServiceAggregator struct {
    serviceMap map[string][]*trace.Span
    mutex      sync.Mutex
}

func NewServiceAggregator() *ServiceAggregator {
    return &ServiceAggregator{
        serviceMap: make(map[string][]*trace.Span,
    }
}

func (sa *ServiceAggregator) Aggregate(span *trace.Span) {
    sa.mutex.Lock()
    defer sa.mutex.Unlock()
    
    serviceName := getServiceName(span)
    sa.serviceMap[serviceName] = append(sa.serviceMap[serviceName], span)
}

func (sa *ServiceAggregator) Flush() map[string][]*trace.Span {
    sa.mutex.Lock()
    defer sa.mutex.Unlock()
    
    result := make(map[string][]*trace.Span)
    for service, spans := range sa.serviceMap {
        result[service] = spans
    }
    
    // æ¸…ç©º
    sa.serviceMap = make(map[string][]*trace.Span)
    
    return result
}
```

---

## ğŸ“¦ ç¼“å†²æœºåˆ¶

### å†…å­˜ç¼“å†²

```go
// å†…å­˜ç¼“å†²
package main

import (
    "sync"
    "go.opentelemetry.io/otel/trace"
)

type MemoryBuffer struct {
    buffer    []*trace.Span
    maxSize   int
    mutex     sync.Mutex
    cond      *sync.Cond
}

func NewMemoryBuffer(maxSize int) *MemoryBuffer {
    mb := &MemoryBuffer{
        buffer:  make([]*trace.Span, 0),
        maxSize: maxSize,}
    mb.cond = sync.NewCond(&mb.mutex)
    return mb
}

func (mb *MemoryBuffer) Add(span *trace.Span) error {
    mb.mutex.Lock()
    defer mb.mutex.Unlock()
    
    // æ£€æŸ¥æ˜¯å¦æ»¡
    for len(mb.buffer) >= mb.maxSize {
        mb.cond.Wait()
    }
    
    mb.buffer = append(mb.buffer, span)
    
    return nil
}

func (mb *MemoryBuffer) Flush() []*trace.Span {
    mb.mutex.Lock()
    defer mb.mutex.Unlock()
    
    result := make([]*trace.Span, len(mb.buffer))
    copy(result, mb.buffer)
    
    mb.buffer = mb.buffer[:0]
    mb.cond.Broadcast()
    
    return result
}

func (mb *MemoryBuffer) Size() int {
    mb.mutex.Lock()
    defer mb.mutex.Unlock()
    
    return len(mb.buffer)
}
```

### ç£ç›˜ç¼“å†²

```go
// ç£ç›˜ç¼“å†²
package main

import (
    "encoding/json"
    "os"
    "sync"
    "go.opentelemetry.io/otel/trace"
)

type DiskBuffer struct {
    filePath string
    file     *os.File
    mutex    sync.Mutex
}

func NewDiskBuffer(filePath string) (*DiskBuffer, error) {
    file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }
    
    return &DiskBuffer{
        filePath: filePath,
        file:     file,
    }, nil
}

func (db *DiskBuffer) Add(span *trace.Span) error {
    db.mutex.Lock()
    defer db.mutex.Unlock()
    
    // åºåˆ—åŒ–
    data, err := json.Marshal(span)
    if err != nil {
        return err
    }
    
    // å†™å…¥ç£ç›˜
    _, err = db.file.Write(data)
    if err != nil {
        return err
    }
    
    _, err = db.file.Write([]byte("\n"))
    return err
}

func (db *DiskBuffer) Flush() error {
    db.mutex.Lock()
    defer db.mutex.Unlock()
    
    return db.file.Sync()
}

func (db *DiskBuffer) ReadAll() ([]*trace.Span, error) {
    db.mutex.Lock()
    defer db.mutex.Unlock()
    
    // è¯»å–æ–‡ä»¶
    data, err := os.ReadFile(db.filePath)
    if err != nil {
        return nil, err
    }
    
    // è§£æ
    spans := make([]*trace.Span, 0)
    lines := strings.Split(string(data), "\n")
    
    for _, line := range lines {
        if line == "" {
            continue
        }
        
        var span trace.Span
        if err := json.Unmarshal([]byte(line), &span); err != nil {
            continue
        }
        
        spans = append(spans, &span)
    }
    
    return spans, nil
}
```

### æ··åˆç¼“å†²

```go
// æ··åˆç¼“å†²
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type HybridBuffer struct {
    memoryBuffer *MemoryBuffer
    diskBuffer   *DiskBuffer
    threshold    int
    mutex        sync.Mutex
}

func NewHybridBuffer(memorySize int, diskPath string, threshold int) (*HybridBuffer, error) {
    memoryBuffer := NewMemoryBuffer(memorySize)
    diskBuffer, err := NewDiskBuffer(diskPath)
    if err != nil {
        return nil, err
    }
    
    return &HybridBuffer{
        memoryBuffer: memoryBuffer,
        diskBuffer:   diskBuffer,
        threshold:    threshold,
    }, nil
}

func (hb *HybridBuffer) Add(span *trace.Span) error {
    hb.mutex.Lock()
    defer hb.mutex.Unlock()
    
    // ä¼˜å…ˆä½¿ç”¨å†…å­˜ç¼“å†²
    if hb.memoryBuffer.Size() < hb.threshold {
        return hb.memoryBuffer.Add(span)
    }
    
    // å†…å­˜æ»¡æ—¶ä½¿ç”¨ç£ç›˜ç¼“å†²
    return hb.diskBuffer.Add(span)
}

func (hb *HybridBuffer) Flush() ([]*trace.Span, error) {
    hb.mutex.Lock()
    defer hb.mutex.Unlock()
    
    // åˆ·æ–°å†…å­˜ç¼“å†²
    memorySpans := hb.memoryBuffer.Flush()
    
    // åˆ·æ–°ç£ç›˜ç¼“å†²
    diskSpans, err := hb.diskBuffer.ReadAll()
    if err != nil {
        return nil, err
    }
    
    // åˆå¹¶ç»“æœ
    allSpans := append(memorySpans, diskSpans...)
    
    return allSpans, nil
}
```

---

## ğŸ“ˆ å¤„ç†ç¼“å†²æ€§èƒ½åˆ†æ

### å¤„ç†ç¼“å†²æ€§èƒ½åŸºå‡†æµ‹è¯•

```text
å¤„ç†ç¼“å†²æ€§èƒ½åŸºå‡†æµ‹è¯• (100,000 Spans):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ“ä½œç±»å‹      â”‚ è€—æ—¶      â”‚ å†…å­˜      â”‚ å¤æ‚åº¦      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é‡‡æ ·å¤„ç†      â”‚ 50ms     â”‚ 50 MB    â”‚ O(n)        â”‚
â”‚  è¿‡æ»¤å¤„ç†      â”‚ 80ms     â”‚ 80 MB    â”‚ O(n)        â”‚
â”‚  èšåˆå¤„ç†      â”‚ 100ms    â”‚ 100 MB   â”‚ O(n log n)  â”‚
â”‚  å†…å­˜ç¼“å†²      â”‚ 10ms     â”‚ 200 MB   â”‚ O(1)        â”‚
â”‚  ç£ç›˜ç¼“å†²      â”‚ 500ms    â”‚ 50 MB    â”‚ O(n)        â”‚
â”‚  æ··åˆç¼“å†²      â”‚ 200ms    â”‚ 150 MB   â”‚ O(n)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš¡ å¤„ç†ç¼“å†²ä¼˜åŒ–ç­–ç•¥

### 1. è‡ªé€‚åº”ç¼“å†²ç­–ç•¥

```go
// è‡ªé€‚åº”ç¼“å†²ç­–ç•¥
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type AdaptiveBuffer struct {
    buffer      *HybridBuffer
    currentSize int
    minSize     int
    maxSize     int
    mutex       sync.Mutex
}

func NewAdaptiveBuffer(minSize, maxSize int, diskPath string) (*AdaptiveBuffer, error) {
    buffer, err := NewHybridBuffer(minSize, diskPath, minSize)
    if err != nil {
        return nil, err
    }
    
    return &AdaptiveBuffer{
        buffer:      buffer,
        currentSize: minSize,
        minSize:     minSize,
        maxSize:     maxSize,
    }, nil
}

func (ab *AdaptiveBuffer) Add(span *trace.Span) error {
    ab.mutex.Lock()
    defer ab.mutex.Unlock()
    
    // æ ¹æ®ç³»ç»Ÿè´Ÿè½½è°ƒæ•´ç¼“å†²åŒºå¤§å°
    load := getSystemLoad()
    
    if load > 0.8 && ab.currentSize > ab.minSize {
        // é«˜è´Ÿè½½æ—¶å‡å°ç¼“å†²åŒº
        ab.currentSize = ab.currentSize / 2
        if ab.currentSize < ab.minSize {
            ab.currentSize = ab.minSize
        }
    } else if load < 0.3 && ab.currentSize < ab.maxSize {
        // ä½è´Ÿè½½æ—¶å¢å¤§ç¼“å†²åŒº
        ab.currentSize = ab.currentSize * 2
        if ab.currentSize > ab.maxSize {
            ab.currentSize = ab.maxSize
        }
    }
    
    return ab.buffer.Add(span)
}
```

### 2. æ‰¹é‡å¤„ç†ç­–ç•¥

```go
// æ‰¹é‡å¤„ç†ç­–ç•¥
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type BatchProcessor struct {
    buffer      *MemoryBuffer
    batchSize   int
    flushTicker *time.Ticker
    mutex       sync.Mutex
}

func NewBatchProcessor(bufferSize, batchSize int, flushInterval time.Duration) *BatchProcessor {
    bp := &BatchProcessor{
        buffer:      NewMemoryBuffer(bufferSize),
        batchSize:   batchSize,
        flushTicker: time.NewTicker(flushInterval),
    }
    
    // å¯åŠ¨å®šæ—¶åˆ·æ–°
    go bp.autoFlush()
    
    return bp
}

func (bp *BatchProcessor) Add(span *trace.Span) error {
    bp.mutex.Lock()
    defer bp.mutex.Unlock()
    
    err := bp.buffer.Add(span)
    if err != nil {
        return err
    }
    
    // è¾¾åˆ°æ‰¹é‡å¤§å°æ—¶è‡ªåŠ¨åˆ·æ–°
    if bp.buffer.Size() >= bp.batchSize {
        go bp.flush()
    }
    
    return nil
}

func (bp *BatchProcessor) autoFlush() {
    for range bp.flushTicker.C {
        bp.flush()
    }
}

func (bp *BatchProcessor) flush() {
    bp.mutex.Lock()
    defer bp.mutex.Unlock()
    
    spans := bp.buffer.Flush()
    if len(spans) > 0 {
        sendToCollector(spans)
    }
}
```

### 3. èƒŒå‹æ§åˆ¶ç­–ç•¥

```go
// èƒŒå‹æ§åˆ¶ç­–ç•¥
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type BackpressureController struct {
    buffer        *HybridBuffer
    maxQueueSize  int
    dropThreshold int
    mutex         sync.Mutex
}

func NewBackpressureController(bufferSize, maxQueueSize, dropThreshold int, diskPath string) (*BackpressureController, error) {
    buffer, err := NewHybridBuffer(bufferSize, diskPath, bufferSize)
    if err != nil {
        return nil, err
    }
    return &BackpressureController{
        buffer:        buffer,
        maxQueueSize:  maxQueueSize,
        dropThreshold: dropThreshold,
    }, nil
}

func (bc *BackpressureController) Add(span *trace.Span) error {
    bc.mutex.Lock()
    defer bc.mutex.Unlock()
    
    // æ£€æŸ¥é˜Ÿåˆ—å¤§å°
    if bc.buffer.Size() >= bc.maxQueueSize {
        // è¾¾åˆ°æœ€å¤§é˜Ÿåˆ—å¤§å°ï¼Œå¼€å§‹ä¸¢å¼ƒ
        if rand.Float64() < float64(bc.dropThreshold)/100.0 {
            return nil // ä¸¢å¼ƒ
        }
    }
    
    return bc.buffer.Add(span)
}

func (bc *BackpressureController) SetDropThreshold(threshold int) {
    bc.mutex.Lock()
    defer bc.mutex.Unlock()
    
    bc.dropThreshold = threshold
}
```

---

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1ï¼šé«˜å¹¶å‘ç³»ç»Ÿæœ¬åœ°å¤„ç†

```go
// é«˜å¹¶å‘ç³»ç»Ÿæœ¬åœ°å¤„ç†
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type HighConcurrencyProcessor struct {
    sampler      *AdaptiveSampler
    filter       *ServiceFilter
    aggregator   *TimeAggregator
    buffer       *AdaptiveBuffer
    mutex        sync.Mutex
}

func NewHighConcurrencyProcessor() (*HighConcurrencyProcessor, error) {
    sampler := NewAdaptiveSampler(0.1)
    
    filter := NewServiceFilter()
    filter.AllowService("user-service")
    filter.AllowService("order-service")
    
    aggregator := NewTimeAggregator(1 * time.Minute)
    
    buffer, err := NewAdaptiveBuffer(1000, 10000, "/tmp/spans.buffer")
    if err != nil {
        return nil, err
    }
    
    return &HighConcurrencyProcessor{
        sampler:    sampler,
        filter:     filter,
        aggregator: aggregator,
        buffer:     buffer,
    }, nil
}

func (hcp *HighConcurrencyProcessor) Process(span *trace.Span) error {
    hcp.mutex.Lock()
    defer hcp.mutex.Unlock()
    
    // 1. é‡‡æ ·
    if hcp.sampler.ShouldSample(trace.SamplingParameters{
        ParentContext: span.SpanContext(),
    }).Decision == trace.Drop {
        return nil
    }
    
    // 2. è¿‡æ»¤
    if hcp.filter.ShouldFilter(span) {
        return nil
    }
    
    // 3. èšåˆ
    hcp.aggregator.Aggregate(span)
    
    // 4. ç¼“å†²
    return hcp.buffer.Add(span)
}

func (hcp *HighConcurrencyProcessor) Flush() ([]*trace.Span, error) {
    hcp.mutex.Lock()
    defer hcp.mutex.Unlock()
    
    // åˆ·æ–°èšåˆå™¨
    aggregated := hcp.aggregator.Flush()
    
    // åˆ·æ–°ç¼“å†²åŒº
    buffered, err := hcp.buffer.Flush()
    if err != nil {
        return nil, err
    }
    
    // åˆå¹¶ç»“æœ
    allSpans := append(aggregated, buffered...)
    
    return allSpans, nil
}
```

### æ¡ˆä¾‹2ï¼šå¤§è§„æ¨¡ç³»ç»Ÿç¼“å†²ä¼˜åŒ–

```go
// å¤§è§„æ¨¡ç³»ç»Ÿç¼“å†²ä¼˜åŒ–
package main

import (
    "go.opentelemetry.io/otel/trace"
)

type LargeScaleBufferOptimizer struct {
    batchProcessor *BatchProcessor
    backpressure   *BackpressureController
    mutex          sync.Mutex
}

func NewLargeScaleBufferOptimizer() (*LargeScaleBufferOptimizer, error) {
    batchProcessor := NewBatchProcessor(
        10000,  // ç¼“å†²åŒºå¤§å°
        1000,   // æ‰¹é‡å¤§å°
        5*time.Second, // åˆ·æ–°é—´éš”
    )
    
    backpressure, err := NewBackpressureController(
        50000,  // ç¼“å†²åŒºå¤§å°
        100000, // æœ€å¤§é˜Ÿåˆ—å¤§å°
        50,     // ä¸¢å¼ƒé˜ˆå€¼
        "/tmp/spans.buffer",
    )
    if err != nil {
        return nil, err
    }
    
    return &LargeScaleBufferOptimizer{
        batchProcessor: batchProcessor,
        backpressure:   backpressure,
    }, nil
}

func (lsbo *LargeScaleBufferOptimizer) Process(span *trace.Span) error {
    lsbo.mutex.Lock()
    defer lsbo.mutex.Unlock()
    
    // ä½¿ç”¨æ‰¹é‡å¤„ç†å™¨
    return lsbo.batchProcessor.Add(span)
}

func (lsbo *LargeScaleBufferOptimizer) SetDropThreshold(threshold int) {
    lsbo.mutex.Lock()
    defer lsbo.mutex.Unlock()
    
    lsbo.backpressure.SetDropThreshold(threshold)
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### å¤„ç†ç¼“å†²ä¼˜åŒ–çŸ©é˜µ

```text
å¤„ç†ç¼“å†²ä¼˜åŒ–çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–é¡¹          â”‚ ç­–ç•¥                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è‡ªé€‚åº”ç¼“å†²      â”‚ æ ¹æ®è´Ÿè½½è°ƒæ•´ (æå‡æ•ˆç‡)                â”‚
â”‚  æ‰¹é‡å¤„ç†        â”‚ æ‰¹é‡åˆ·æ–° (é™ä½å»¶è¿Ÿ)                    â”‚
â”‚  èƒŒå‹æ§åˆ¶        â”‚ èƒŒå‹æ§åˆ¶ (é˜²æ­¢æº¢å‡º)                    â”‚
â”‚  å†…å­˜ä¼˜å…ˆ        â”‚ ä¼˜å…ˆå†…å­˜ (æå‡æ€§èƒ½)                    â”‚
â”‚  ç£ç›˜å…œåº•        â”‚ ç£ç›˜å…œåº• (ä¿è¯å¯é )                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ æ€»ç»“

**æœ¬åœ°å¤„ç†ä¸ç¼“å†²æœºåˆ¶**æ˜¯OTLPæ•°æ®å¤„ç†çš„æ ¸å¿ƒï¼š

1. **æœ¬åœ°å¤„ç†**ï¼šé‡‡æ ·å¤„ç† + è¿‡æ»¤å¤„ç† + èšåˆå¤„ç†
2. **ç¼“å†²æœºåˆ¶**ï¼šå†…å­˜ç¼“å†² + ç£ç›˜ç¼“å†² + æ··åˆç¼“å†²
3. **å¤„ç†ç­–ç•¥**ï¼šè‡ªé€‚åº” + æ‰¹é‡ + èƒŒå‹
4. **ä¼˜åŒ–ç­–ç•¥**ï¼šæ‰¹é‡ + å¹¶è¡Œ + å‹ç¼©

**å…³é”®è¦ç‚¹**ï¼š

- âœ… é‡‡æ ·å¤„ç†é™ä½æ•°æ®é‡
- âœ… è¿‡æ»¤å¤„ç†å»é™¤æ— ç”¨æ•°æ®
- âœ… èšåˆå¤„ç†æå‡æ•ˆç‡
- âœ… å†…å­˜ç¼“å†²æå‡æ€§èƒ½
- âœ… ç£ç›˜ç¼“å†²ä¿è¯å¯é 
- âœ… æ··åˆç¼“å†²å¹³è¡¡æ€§èƒ½ä¸å¯é 
- âœ… è‡ªé€‚åº”ç¼“å†²åŠ¨æ€è°ƒæ•´
- âœ… èƒŒå‹æ§åˆ¶é˜²æ­¢æº¢å‡º

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ
