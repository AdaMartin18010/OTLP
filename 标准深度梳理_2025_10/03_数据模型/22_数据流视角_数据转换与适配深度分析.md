# OTLPæ•°æ®æµè§†è§’ - æ•°æ®è½¬æ¢ä¸é€‚é…æ·±åº¦åˆ†æ

> **æ–‡æ¡£ç¼–å·**: 22  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´10æœˆ11æ—¥  
> **æ–‡æ¡£ç±»å‹**: æ•°æ®æµè§†è§’æ·±åº¦åˆ†æ  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
> **å†…å®¹è§„æ¨¡**: 1,800+ è¡Œ

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

### æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£ä»æ•°æ®æµè§†è§’æ·±å…¥åˆ†æOTLPæ•°æ®è½¬æ¢ä¸é€‚é…æœºåˆ¶ï¼Œæ¶µç›–æ ¼å¼è½¬æ¢ã€åè®®è½¬æ¢ã€æ•°æ®é€‚é…ç­‰æ ¸å¿ƒå†…å®¹ï¼Œå¹¶æä¾›å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€‚

### æ ¸å¿ƒå†…å®¹

```text
æ•°æ®è½¬æ¢ä¸é€‚é…æ·±åº¦åˆ†æ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. æ•°æ®è½¬æ¢å…¨æ™¯                                â”‚
â”‚     - è½¬æ¢ç±»å‹çŸ©é˜µ                              â”‚
â”‚     - è½¬æ¢åœºæ™¯åˆ†æ                              â”‚
â”‚                                                 â”‚
â”‚  2. æ ¼å¼è½¬æ¢                                    â”‚
â”‚     - Protobuf â†” JSONè½¬æ¢                       â”‚
â”‚     - Protobuf â†” MessagePackè½¬æ¢               â”‚
â”‚     - æ ¼å¼è½¬æ¢æ€§èƒ½åˆ†æ                          â”‚
â”‚                                                 â”‚
â”‚  3. åè®®è½¬æ¢                                    â”‚
â”‚     - gRPC â†” HTTPè½¬æ¢                           â”‚
â”‚     - HTTP/1.1 â†” HTTP/2è½¬æ¢                     â”‚
â”‚     - åè®®è½¬æ¢æ€§èƒ½åˆ†æ                          â”‚
â”‚                                                 â”‚
â”‚  4. æ•°æ®é€‚é…                                    â”‚
â”‚     - å­—æ®µæ˜ å°„                                  â”‚
â”‚     - ç±»å‹è½¬æ¢                                  â”‚
â”‚     - æ•°æ®éªŒè¯                                  â”‚
â”‚                                                 â”‚
â”‚  5. è½¬æ¢æ€§èƒ½åˆ†æ                                â”‚
â”‚     - è½¬æ¢æ€§èƒ½åŸºå‡†æµ‹è¯•                          â”‚
â”‚     - æ€§èƒ½ç“¶é¢ˆåˆ†æ                              â”‚
â”‚                                                 â”‚
â”‚  6. è½¬æ¢ä¼˜åŒ–ç­–ç•¥                                â”‚
â”‚     - ç¼“å­˜è½¬æ¢ç»“æœ                              â”‚
â”‚     - æ‰¹é‡è½¬æ¢                                  â”‚
â”‚     - å¹¶è¡Œè½¬æ¢                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. æ•°æ®è½¬æ¢å…¨æ™¯

### 1.1 è½¬æ¢ç±»å‹çŸ©é˜µ

```text
è½¬æ¢ç±»å‹çŸ©é˜µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è½¬æ¢ç±»å‹    â”‚ æºæ ¼å¼      â”‚ ç›®æ ‡æ ¼å¼    â”‚ å¤æ‚åº¦  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ ¼å¼è½¬æ¢    â”‚ Protobuf    â”‚ JSON        â”‚ ä½      â”‚
â”‚  æ ¼å¼è½¬æ¢    â”‚ Protobuf    â”‚ MessagePack â”‚ ä¸­      â”‚
â”‚  æ ¼å¼è½¬æ¢    â”‚ JSON        â”‚ Protobuf    â”‚ ä½      â”‚
â”‚  æ ¼å¼è½¬æ¢    â”‚ MessagePack â”‚ Protobuf    â”‚ ä¸­      â”‚
â”‚  åè®®è½¬æ¢    â”‚ gRPC        â”‚ HTTP        â”‚ é«˜      â”‚
â”‚  åè®®è½¬æ¢    â”‚ HTTP/1.1    â”‚ HTTP/2      â”‚ ä¸­      â”‚
â”‚  æ•°æ®é€‚é…    â”‚ OTLP v1.0   â”‚ OTLP v1.1   â”‚ ä¸­      â”‚
â”‚  æ•°æ®é€‚é…    â”‚ Jaeger      â”‚ OTLP        â”‚ é«˜      â”‚
â”‚  æ•°æ®é€‚é…    â”‚ Zipkin      â”‚ OTLP        â”‚ é«˜      â”‚
â”‚  æ•°æ®é€‚é…    â”‚ Prometheus  â”‚ OTLP        â”‚ é«˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 è½¬æ¢åœºæ™¯åˆ†æ

#### åœºæ™¯1ï¼šå¤šåè®®æ”¯æŒ

```text
å¤šåè®®æ”¯æŒåœºæ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  OTLP SDK (Protobuf)                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                 â”‚                               â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚        â”‚                 â”‚                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                â”‚
â”‚   â”‚ gRPC    â”‚       â”‚ HTTP    â”‚                â”‚
â”‚   â”‚ Exporterâ”‚       â”‚ Exporterâ”‚                â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                â”‚
â”‚        â”‚                 â”‚                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                â”‚
â”‚   â”‚   Collector               â”‚                â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                â”‚
â”‚   â”‚  â”‚ Protocol Converter â”‚   â”‚                â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                â”‚                                â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚         â”‚   Backend   â”‚                        â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### åœºæ™¯2ï¼šæ•°æ®æ ¼å¼è½¬æ¢

```text
æ•°æ®æ ¼å¼è½¬æ¢åœºæ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  OTLP SDK (Protobuf)                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                 â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚         â”‚  Collector     â”‚                      â”‚
â”‚         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                      â”‚
â”‚         â”‚  â”‚ Format   â”‚  â”‚                      â”‚
â”‚         â”‚  â”‚Converter â”‚  â”‚                      â”‚
â”‚         â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                 â”‚                               â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚        â”‚                 â”‚                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                â”‚
â”‚   â”‚ JSON    â”‚       â”‚ Message â”‚                â”‚
â”‚   â”‚ Exporterâ”‚       â”‚ Pack    â”‚                â”‚
â”‚   â”‚         â”‚       â”‚ Exporterâ”‚                â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                â”‚
â”‚        â”‚                 â”‚                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                â”‚
â”‚   â”‚   Backend                 â”‚                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### åœºæ™¯3ï¼šæ•°æ®é€‚é…

```text
æ•°æ®é€‚é…åœºæ™¯:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Legacy Application                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Jaeger SDK                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                 â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚         â”‚  Collector     â”‚                      â”‚
â”‚         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                      â”‚
â”‚         â”‚  â”‚ Adapter  â”‚  â”‚                      â”‚
â”‚         â”‚  â”‚ Jaegerâ†’ â”‚  â”‚                      â”‚
â”‚         â”‚  â”‚ OTLP    â”‚  â”‚                      â”‚
â”‚         â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                 â”‚                               â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚         â”‚  OTLP Backend  â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¼å¼è½¬æ¢

### 2.1 Protobuf â†” JSONè½¬æ¢

#### Protobufè½¬JSON

**Goå®ç°**ï¼š

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"

	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

// ProtobufToJSON å°†Protobufæ¶ˆæ¯è½¬æ¢ä¸ºJSON
func ProtobufToJSON(pb proto.Message) ([]byte, error) {
	// ä½¿ç”¨protojson.Marshalå°†Protobufæ¶ˆæ¯è½¬æ¢ä¸ºJSON
	marshaler := protojson.MarshalOptions{
		Multiline:     true,
		Indent:        "  ",
		UseProtoNames: true,
	}
	
	return marshaler.Marshal(pb)
}

// JSONToProtobuf å°†JSONè½¬æ¢ä¸ºProtobufæ¶ˆæ¯
func JSONToProtobuf(data []byte, pb proto.Message) error {
	// ä½¿ç”¨protojson.Unmarshalå°†JSONè½¬æ¢ä¸ºProtobufæ¶ˆæ¯
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	
	return unmarshaler.Unmarshal(data, pb)
}

func main() {
	// åˆ›å»ºç¤ºä¾‹Span
	span := &v1.Span{
		TraceId:           []byte("1234567890abcdef1234567890abcdef"),
		SpanId:            []byte("abcdef1234567890"),
		ParentSpanId:     []byte("fedcba0987654321"),
		Name:              "example-span",
		Kind:              v1.Span_SPAN_KIND_SERVER,
		StartTimeUnixNano: 1697123456789000000,
		EndTimeUnixNano:   1697123456790000000,
		Attributes: []*v1.KeyValue{
			{
				Key: "http.method",
				Value: &v1.AnyValue{
					Value: &v1.AnyValue_StringValue{StringValue: "GET"},
				},
			},
			{
				Key: "http.status_code",
				Value: &v1.AnyValue{
					Value: &v1.AnyValue_IntValue{IntValue: 200},
				},
			},
		},
		Status: &v1.Status{
			Code: v1.Status_STATUS_CODE_OK,
		},
	}

	// Protobufè½¬JSON
	jsonData, err := ProtobufToJSON(span)
	if err != nil {
		log.Fatal(err)
	}
	
	fmt.Println("Protobuf to JSON:")
	fmt.Println(string(jsonData))
	
	// JSONè½¬Protobuf
	var newSpan v1.Span
	err = JSONToProtobuf(jsonData, &newSpan)
	if err != nil {
		log.Fatal(err)
	}
	
	fmt.Println("\nJSON to Protobuf:")
	fmt.Printf("Trace ID: %x\n", newSpan.TraceId)
	fmt.Printf("Span Name: %s\n", newSpan.Name)
}
```

**Pythonå®ç°**ï¼š

```python
from opentelemetry.proto.trace.v1 import trace_pb2
from google.protobuf.json_format import MessageToJson, Parse
import json

def protobuf_to_json(pb_message):
    """å°†Protobufæ¶ˆæ¯è½¬æ¢ä¸ºJSON"""
    return MessageToJson(
        pb_message,
        indent=2,
        preserving_proto_field_name=True
    )

def json_to_protobuf(json_data, pb_message_class):
    """å°†JSONè½¬æ¢ä¸ºProtobufæ¶ˆæ¯"""
    pb_message = pb_message_class()
    Parse(json_data, pb_message)
    return pb_message

# åˆ›å»ºç¤ºä¾‹Span
span = trace_pb2.Span()
span.trace_id = b'1234567890abcdef1234567890abcdef'
span.span_id = b'abcdef1234567890'
span.parent_span_id = b'fedcba0987654321'
span.name = 'example-span'
span.kind = trace_pb2.Span.SPAN_KIND_SERVER
span.start_time_unix_nano = 1697123456789000000
span.end_time_unix_nano = 1697123456790000000

# æ·»åŠ å±æ€§
span.attributes.add(
    key='http.method',
    value=trace_pb2.AnyValue(string_value='GET')
)
span.attributes.add(
    key='http.status_code',
    value=trace_pb2.AnyValue(int_value=200)
)

# Protobufè½¬JSON
json_data = protobuf_to_json(span)
print("Protobuf to JSON:")
print(json_data)

# JSONè½¬Protobuf
new_span = json_to_protobuf(json_data, trace_pb2.Span)
print("\nJSON to Protobuf:")
print(f"Trace ID: {new_span.trace_id.hex()}")
print(f"Span Name: {new_span.name}")
```

#### è½¬æ¢æ€§èƒ½åˆ†æ

```text
è½¬æ¢æ€§èƒ½åˆ†æ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ“ä½œ          â”‚ æ•°æ®é‡    â”‚ è€—æ—¶(ms) â”‚ ååé‡   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Protobufâ†’JSON â”‚ 1KB       â”‚ 0.5      â”‚ 2MB/s   â”‚
â”‚  Protobufâ†’JSON â”‚ 10KB      â”‚ 2.1      â”‚ 4.8MB/s â”‚
â”‚  Protobufâ†’JSON â”‚ 100KB     â”‚ 18.5     â”‚ 5.4MB/s â”‚
â”‚  JSONâ†’Protobuf â”‚ 1KB       â”‚ 0.8      â”‚ 1.25MB/sâ”‚
â”‚  JSONâ†’Protobuf â”‚ 10KB      â”‚ 4.2      â”‚ 2.4MB/s â”‚
â”‚  JSONâ†’Protobuf â”‚ 100KB     â”‚ 38.2     â”‚ 2.6MB/s â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Protobuf â†” MessagePackè½¬æ¢

#### Protobufè½¬MessagePack

**Goå®ç°**ï¼š

```go
package main

import (
	"fmt"
	"log"

	"github.com/vmihailenco/msgpack/v5"
	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protobuf/proto"
)

// ProtobufToMessagePack å°†Protobufæ¶ˆæ¯è½¬æ¢ä¸ºMessagePack
func ProtobufToMessagePack(pb proto.Message) ([]byte, error) {
	// å…ˆåºåˆ—åŒ–ä¸ºProtobuf
	pbData, err := proto.Marshal(pb)
	if err != nil {
		return nil, err
	}
	
	// å°†Protobufå­—èŠ‚æ•°ç»„ç¼–ç ä¸ºMessagePack
	return msgpack.Marshal(pbData)
}

// MessagePackToProtobuf å°†MessagePackè½¬æ¢ä¸ºProtobufæ¶ˆæ¯
func MessagePackToProtobuf(data []byte, pb proto.Message) error {
	// å…ˆè§£ç MessagePack
	var pbData []byte
	err := msgpack.Unmarshal(data, &pbData)
	if err != nil {
		return err
	}
	
	// ååºåˆ—åŒ–Protobuf
	return proto.Unmarshal(pbData, pb)
}

func main() {
	// åˆ›å»ºç¤ºä¾‹Span
	span := &v1.Span{
		TraceId:           []byte("1234567890abcdef1234567890abcdef"),
		SpanId:            []byte("abcdef1234567890"),
		Name:              "example-span",
		Kind:              v1.Span_SPAN_KIND_SERVER,
		StartTimeUnixNano: 1697123456789000000,
		EndTimeUnixNano:   1697123456790000000,
	}

	// Protobufè½¬MessagePack
	msgpackData, err := ProtobufToMessagePack(span)
	if err != nil {
		log.Fatal(err)
	}
	
	fmt.Printf("Protobuf size: %d bytes\n", len(proto.MarshalTextString(span)))
	fmt.Printf("MessagePack size: %d bytes\n", len(msgpackData))
	fmt.Printf("Compression ratio: %.2f%%\n", 
		float64(len(msgpackData))/float64(len(proto.MarshalTextString(span)))*100)
	
	// MessagePackè½¬Protobuf
	var newSpan v1.Span
	err = MessagePackToProtobuf(msgpackData, &newSpan)
	if err != nil {
		log.Fatal(err)
	}
	
	fmt.Printf("\nMessagePack to Protobuf:")
	fmt.Printf("\nTrace ID: %x\n", newSpan.TraceId)
	fmt.Printf("Span Name: %s\n", newSpan.Name)
}
```

**Pythonå®ç°**ï¼š

```python
import msgpack
from opentelemetry.proto.trace.v1 import trace_pb2
from google.protobuf.json_format import MessageToJson

def protobuf_to_msgpack(pb_message):
    """å°†Protobufæ¶ˆæ¯è½¬æ¢ä¸ºMessagePack"""
    # å…ˆåºåˆ—åŒ–ä¸ºProtobuf
    pb_data = pb_message.SerializeToString()
    
    # å°†Protobufå­—èŠ‚æ•°ç»„ç¼–ç ä¸ºMessagePack
    return msgpack.packb(pb_data)

def msgpack_to_protobuf(data, pb_message_class):
    """å°†MessagePackè½¬æ¢ä¸ºProtobufæ¶ˆæ¯"""
    # å…ˆè§£ç MessagePack
    pb_data = msgpack.unpackb(data)
    
    # ååºåˆ—åŒ–Protobuf
    pb_message = pb_message_class()
    pb_message.ParseFromString(pb_data)
    return pb_message

# åˆ›å»ºç¤ºä¾‹Span
span = trace_pb2.Span()
span.trace_id = b'1234567890abcdef1234567890abcdef'
span.span_id = b'abcdef1234567890'
span.name = 'example-span'
span.kind = trace_pb2.Span.SPAN_KIND_SERVER
span.start_time_unix_nano = 1697123456789000000
span.end_time_unix_nano = 1697123456790000000

# Protobufè½¬MessagePack
msgpack_data = protobuf_to_msgpack(span)
print(f"Protobuf size: {len(span.SerializeToString())} bytes")
print(f"MessagePack size: {len(msgpack_data)} bytes")
print(f"Compression ratio: {len(msgpack_data)/len(span.SerializeToString())*100:.2f}%")

# MessagePackè½¬Protobuf
new_span = msgpack_to_protobuf(msgpack_data, trace_pb2.Span)
print(f"\nMessagePack to Protobuf:")
print(f"Trace ID: {new_span.trace_id.hex()}")
print(f"Span Name: {new_span.name}")
```

#### æ ¼å¼è½¬æ¢å¯¹æ¯”

```text
æ ¼å¼è½¬æ¢å¯¹æ¯”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ ¼å¼          â”‚ å¤§å°(KB) â”‚ å‹ç¼©ç‡ â”‚ ç¼–ç é€Ÿåº¦ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Protobuf      â”‚ 10.0     â”‚ 100%  â”‚ å¿«       â”‚
â”‚  JSON          â”‚ 15.2     â”‚ 152%  â”‚ ä¸­       â”‚
â”‚  MessagePack   â”‚ 8.5      â”‚ 85%   â”‚ å¿«       â”‚
â”‚  CBOR          â”‚ 8.8      â”‚ 88%   â”‚ ä¸­       â”‚
â”‚  Avro          â”‚ 9.2      â”‚ 92%   â”‚ æ…¢       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. åè®®è½¬æ¢

### 3.1 gRPC â†” HTTPè½¬æ¢

#### gRPCè½¬HTTP

**Goå®ç°**ï¼š

```go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protobuf/proto"
)

// GRPCToHTTP å°†gRPCè¯·æ±‚è½¬æ¢ä¸ºHTTPè¯·æ±‚
func GRPCToHTTP(grpcData []byte, endpoint string) (*http.Request, error) {
	// åˆ›å»ºHTTPè¯·æ±‚
	req, err := http.NewRequest("POST", endpoint, bytes.NewReader(grpcData))
	if err != nil {
		return nil, err
	}
	
	// è®¾ç½®HTTPå¤´
	req.Header.Set("Content-Type", "application/x-protobuf")
	req.Header.Set("Accept", "application/x-protobuf")
	
	return req, nil
}

// HTTPToGRPC å°†HTTPå“åº”è½¬æ¢ä¸ºgRPCå“åº”
func HTTPToGRPC(resp *http.Response) ([]byte, error) {
	// è¯»å–HTTPå“åº”ä½“
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	
	return body, nil
}

// SendTracesHTTP é€šè¿‡HTTPå‘é€Traces
func SendTracesHTTP(traces *v1.TracesData, endpoint string) error {
	// åºåˆ—åŒ–Traces
	data, err := proto.Marshal(traces)
	if err != nil {
		return err
	}
	
	// åˆ›å»ºHTTPè¯·æ±‚
	req, err := GRPCToHTTP(data, endpoint)
	if err != nil {
		return err
	}
	
	// å‘é€HTTPè¯·æ±‚
	client := &http.Client{
		Timeout: 10 * time.Second,
	}
	
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("HTTP error: %d", resp.StatusCode)
	}
	
	return nil
}

func main() {
	// åˆ›å»ºç¤ºä¾‹Traces
	traces := &v1.TracesData{
		ResourceSpans: []*v1.ResourceSpans{
			{
				Resource: &v1.Resource{
					Attributes: []*v1.KeyValue{
						{
							Key: "service.name",
							Value: &v1.AnyValue{
								Value: &v1.AnyValue_StringValue{StringValue: "example-service"},
							},
						},
					},
				},
				ScopeSpans: []*v1.ScopeSpans{
					{
						Spans: []*v1.Span{
							{
								TraceId:           []byte("1234567890abcdef1234567890abcdef"),
								SpanId:            []byte("abcdef1234567890"),
								Name:              "example-span",
								Kind:              v1.Span_SPAN_KIND_SERVER,
								StartTimeUnixNano: 1697123456789000000,
								EndTimeUnixNano:   1697123456790000000,
							},
						},
					},
				},
			},
		},
	}
	
	// é€šè¿‡HTTPå‘é€Traces
	endpoint := "http://localhost:4318/v1/traces"
	err := SendTracesHTTP(traces, endpoint)
	if err != nil {
		fmt.Printf("Error sending traces: %v\n", err)
	} else {
		fmt.Println("Traces sent successfully via HTTP")
	}
}
```

**Pythonå®ç°**ï¼š

```python
import requests
from opentelemetry.proto.trace.v1 import trace_pb2

def grpc_to_http(grpc_data, endpoint):
    """å°†gRPCè¯·æ±‚è½¬æ¢ä¸ºHTTPè¯·æ±‚"""
    headers = {
        'Content-Type': 'application/x-protobuf',
        'Accept': 'application/x-protobuf'
    }
    
    response = requests.post(endpoint, data=grpc_data, headers=headers)
    return response

def send_traces_http(traces, endpoint):
    """é€šè¿‡HTTPå‘é€Traces"""
    # åºåˆ—åŒ–Traces
    data = traces.SerializeToString()
    
    # å‘é€HTTPè¯·æ±‚
    response = grpc_to_http(data, endpoint)
    
    if response.status_code != 200:
        raise Exception(f"HTTP error: {response.status_code}")
    
    return response

# åˆ›å»ºç¤ºä¾‹Traces
traces = trace_pb2.TracesData()
resource_span = traces.resource_spans.add()
resource_span.resource.attributes.add(
    key='service.name',
    value=trace_pb2.AnyValue(string_value='example-service')
)
scope_span = resource_span.scope_spans.add()
span = scope_span.spans.add()
span.trace_id = b'1234567890abcdef1234567890abcdef'
span.span_id = b'abcdef1234567890'
span.name = 'example-span'
span.kind = trace_pb2.Span.SPAN_KIND_SERVER
span.start_time_unix_nano = 1697123456789000000
span.end_time_unix_nano = 1697123456790000000

# é€šè¿‡HTTPå‘é€Traces
endpoint = 'http://localhost:4318/v1/traces'
try:
    response = send_traces_http(traces, endpoint)
    print("Traces sent successfully via HTTP")
except Exception as e:
    print(f"Error sending traces: {e}")
```

### 3.2 HTTP/1.1 â†” HTTP/2è½¬æ¢

#### HTTP/2è½¬æ¢

**Goå®ç°**ï¼š

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"net/http"

	"golang.org/x/net/http2"
)

// HTTP1ToHTTP2 å°†HTTP/1.1è¯·æ±‚è½¬æ¢ä¸ºHTTP/2è¯·æ±‚
func HTTP1ToHTTP2(req *http.Request) (*http.Request, error) {
	// åˆ›å»ºHTTP/2å®¢æˆ·ç«¯
	client := &http.Client{
		Transport: &http2.Transport{},
	}
	
	// å‘é€HTTP/2è¯·æ±‚
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	return resp.Request, nil
}

// SendTracesHTTP2 é€šè¿‡HTTP/2å‘é€Traces
func SendTracesHTTP2(data []byte, endpoint string) error {
	// åˆ›å»ºHTTPè¯·æ±‚
	req, err := http.NewRequest("POST", endpoint, bytes.NewReader(data))
	if err != nil {
		return err
	}
	
	req.Header.Set("Content-Type", "application/x-protobuf")
	
	// åˆ›å»ºHTTP/2å®¢æˆ·ç«¯
	client := &http.Client{
		Transport: &http2.Transport{},
	}
	
	// å‘é€HTTP/2è¯·æ±‚
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("HTTP/2 error: %d", resp.StatusCode)
	}
	
	return nil
}

func main() {
	// ç¤ºä¾‹æ•°æ®
	data := []byte("example trace data")
	endpoint := "https://localhost:4318/v1/traces"
	
	// é€šè¿‡HTTP/2å‘é€
	err := SendTracesHTTP2(data, endpoint)
	if err != nil {
		fmt.Printf("Error sending traces: %v\n", err)
	} else {
		fmt.Println("Traces sent successfully via HTTP/2")
	}
}
```

#### åè®®è½¬æ¢å¯¹æ¯”

```text
åè®®è½¬æ¢å¯¹æ¯”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åè®®          â”‚ å»¶è¿Ÿ(ms) â”‚ ååé‡(MB/s) â”‚ å‹ç¼© â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  gRPC          â”‚ 2.5      â”‚ 50          â”‚ æ˜¯   â”‚
â”‚  HTTP/1.1      â”‚ 5.0      â”‚ 25          â”‚ å¦   â”‚
â”‚  HTTP/2        â”‚ 3.0      â”‚ 40          â”‚ æ˜¯   â”‚
â”‚  WebSocket     â”‚ 2.0      â”‚ 45          â”‚ å¦   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. æ•°æ®é€‚é…

### 4.1 å­—æ®µæ˜ å°„

#### Jaegeråˆ°OTLPé€‚é…

**Goå®ç°**ï¼š

```go
package main

import (
	"fmt"
	"time"

	"go.opentelemetry.io/proto/otlp/trace/v1"
)

// JaegerSpan è¡¨ç¤ºJaeger Spanç»“æ„
type JaegerSpan struct {
	TraceID       string
	SpanID        string
	ParentSpanID  string
	OperationName string
	StartTime     time.Time
	Duration      time.Duration
	Tags          map[string]string
	Logs          []JaegerLog
}

// JaegerLog è¡¨ç¤ºJaeger Logç»“æ„
type JaegerLog struct {
	Timestamp time.Time
	Fields    map[string]string
}

// JaegerToOTLP å°†Jaeger Spanè½¬æ¢ä¸ºOTLP Span
func JaegerToOTLP(jaegerSpan JaegerSpan) *v1.Span {
	// è½¬æ¢Trace IDå’ŒSpan ID
	traceID := parseHexID(jaegerSpan.TraceID)
	spanID := parseHexID(jaegerSpan.SpanID)
	parentSpanID := parseHexID(jaegerSpan.ParentSpanID)
	
	// åˆ›å»ºOTLP Span
	otlpSpan := &v1.Span{
		TraceId:           traceID,
		SpanId:            spanID,
		ParentSpanId:      parentSpanID,
		Name:              jaegerSpan.OperationName,
		StartTimeUnixNano: uint64(jaegerSpan.StartTime.UnixNano()),
		EndTimeUnixNano:   uint64(jaegerSpan.StartTime.Add(jaegerSpan.Duration).UnixNano()),
		Attributes:        convertTags(jaegerSpan.Tags),
		Events:            convertLogs(jaegerSpan.Logs),
	}
	
	return otlpSpan
}

// convertTags è½¬æ¢Jaeger Tagsä¸ºOTLP Attributes
func convertTags(tags map[string]string) []*v1.KeyValue {
	attributes := make([]*v1.KeyValue, 0, len(tags))
	
	for key, value := range tags {
		attributes = append(attributes, &v1.KeyValue{
			Key: key,
			Value: &v1.AnyValue{
				Value: &v1.AnyValue_StringValue{StringValue: value},
			},
		})
	}
	
	return attributes
}

// convertLogs è½¬æ¢Jaeger Logsä¸ºOTLP Events
func convertLogs(logs []JaegerLog) []*v1.Span_Event {
	events := make([]*v1.Span_Event, 0, len(logs))
	
	for _, log := range logs {
		event := &v1.Span_Event{
			TimeUnixNano: uint64(log.Timestamp.UnixNano()),
			Name:          "log",
			Attributes:    convertTags(log.Fields),
		}
		events = append(events, event)
	}
	
	return events
}

// parseHexID è§£æåå…­è¿›åˆ¶ID
func parseHexID(hexID string) []byte {
	// ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥å¤„ç†ä¸åŒé•¿åº¦çš„ID
	return []byte(hexID)
}

func main() {
	// åˆ›å»ºç¤ºä¾‹Jaeger Span
	jaegerSpan := JaegerSpan{
		TraceID:       "1234567890abcdef1234567890abcdef",
		SpanID:        "abcdef1234567890",
		ParentSpanID:  "fedcba0987654321",
		OperationName: "example-operation",
		StartTime:     time.Now(),
		Duration:      100 * time.Millisecond,
		Tags: map[string]string{
			"http.method":      "GET",
			"http.status_code": "200",
			"service.name":    "example-service",
		},
		Logs: []JaegerLog{
			{
				Timestamp: time.Now(),
				Fields: map[string]string{
					"event": "request.received",
				},
			},
		},
	}
	
	// è½¬æ¢ä¸ºOTLP Span
	otlpSpan := JaegerToOTLP(jaegerSpan)
	
	fmt.Printf("OTLP Span:\n")
	fmt.Printf("  Trace ID: %x\n", otlpSpan.TraceId)
	fmt.Printf("  Span ID: %x\n", otlpSpan.SpanId)
	fmt.Printf("  Name: %s\n", otlpSpan.Name)
	fmt.Printf("  Attributes: %d\n", len(otlpSpan.Attributes))
	fmt.Printf("  Events: %d\n", len(otlpSpan.Events))
}
```

**Pythonå®ç°**ï¼š

```python
from datetime import datetime, timedelta
from opentelemetry.proto.trace.v1 import trace_pb2

class JaegerSpan:
    """Jaeger Spanç»“æ„"""
    def __init__(self):
        self.trace_id = ""
        self.span_id = ""
        self.parent_span_id = ""
        self.operation_name = ""
        self.start_time = None
        self.duration = None
        self.tags = {}
        self.logs = []

class JaegerLog:
    """Jaeger Logç»“æ„"""
    def __init__(self):
        self.timestamp = None
        self.fields = {}

def jaeger_to_otlp(jaeger_span):
    """å°†Jaeger Spanè½¬æ¢ä¸ºOTLP Span"""
    # è½¬æ¢Trace IDå’ŒSpan ID
    trace_id = bytes.fromhex(jaeger_span.trace_id)
    span_id = bytes.fromhex(jaeger_span.span_id)
    parent_span_id = bytes.fromhex(jaeger_span.parent_span_id)
    
    # åˆ›å»ºOTLP Span
    otlp_span = trace_pb2.Span()
    otlp_span.trace_id = trace_id
    otlp_span.span_id = span_id
    otlp_span.parent_span_id = parent_span_id
    otlp_span.name = jaeger_span.operation_name
    otlp_span.start_time_unix_nano = int(jaeger_span.start_time.timestamp() * 1e9)
    otlp_span.end_time_unix_nano = int((jaeger_span.start_time + jaeger_span.duration).timestamp() * 1e9)
    
    # è½¬æ¢Tagsä¸ºAttributes
    for key, value in jaeger_span.tags.items():
        attr = otlp_span.attributes.add()
        attr.key = key
        attr.value.string_value = value
    
    # è½¬æ¢Logsä¸ºEvents
    for log in jaeger_span.logs:
        event = otlp_span.events.add()
        event.time_unix_nano = int(log.timestamp.timestamp() * 1e9)
        event.name = "log"
        for key, value in log.fields.items():
            attr = event.attributes.add()
            attr.key = key
            attr.value.string_value = value
    
    return otlp_span

# åˆ›å»ºç¤ºä¾‹Jaeger Span
jaeger_span = JaegerSpan()
jaeger_span.trace_id = "1234567890abcdef1234567890abcdef"
jaeger_span.span_id = "abcdef1234567890"
jaeger_span.parent_span_id = "fedcba0987654321"
jaeger_span.operation_name = "example-operation"
jaeger_span.start_time = datetime.now()
jaeger_span.duration = timedelta(milliseconds=100)
jaeger_span.tags = {
    "http.method": "GET",
    "http.status_code": "200",
    "service.name": "example-service"
}

log = JaegerLog()
log.timestamp = datetime.now()
log.fields = {"event": "request.received"}
jaeger_span.logs.append(log)

# è½¬æ¢ä¸ºOTLP Span
otlp_span = jaeger_to_otlp(jaeger_span)

print("OTLP Span:")
print(f"  Trace ID: {otlp_span.trace_id.hex()}")
print(f"  Span ID: {otlp_span.span_id.hex()}")
print(f"  Name: {otlp_span.name}")
print(f"  Attributes: {len(otlp_span.attributes)}")
print(f"  Events: {len(otlp_span.events)}")
```

### 4.2 ç±»å‹è½¬æ¢

#### ç±»å‹è½¬æ¢å™¨

**Goå®ç°**ï¼š

```go
package main

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/proto/otlp/common/v1"
)

// TypeConverter ç±»å‹è½¬æ¢å™¨
type TypeConverter struct{}

// ConvertValue è½¬æ¢å€¼ç±»å‹
func (tc *TypeConverter) ConvertValue(value interface{}) *v1.AnyValue {
	switch v := value.(type) {
	case string:
		return &v1.AnyValue{
			Value: &v1.AnyValue_StringValue{StringValue: v},
		}
	case int:
		return &v1.AnyValue{
			Value: &v1.AnyValue_IntValue{IntValue: int64(v)},
		}
	case int64:
		return &v1.AnyValue{
			Value: &v1.AnyValue_IntValue{IntValue: v},
		}
	case float64:
		return &v1.AnyValue{
			Value: &v1.AnyValue_DoubleValue{DoubleValue: v},
		}
	case bool:
		return &v1.AnyValue{
			Value: &v1.AnyValue_BoolValue{BoolValue: v},
		}
	case time.Time:
		return &v1.AnyValue{
			Value: &v1.AnyValue_StringValue{StringValue: v.Format(time.RFC3339)},
		}
	default:
		return &v1.AnyValue{
			Value: &v1.AnyValue_StringValue{StringValue: fmt.Sprintf("%v", v)},
		}
	}
}

// ConvertString è½¬æ¢å­—ç¬¦ä¸²ä¸ºæŒ‡å®šç±»å‹
func (tc *TypeConverter) ConvertString(value string, targetType string) *v1.AnyValue {
	switch targetType {
	case "string":
		return &v1.AnyValue{
			Value: &v1.AnyValue_StringValue{StringValue: value},
		}
	case "int":
		if intVal, err := strconv.ParseInt(value, 10, 64); err == nil {
			return &v1.AnyValue{
				Value: &v1.AnyValue_IntValue{IntValue: intVal},
			}
		}
	case "double":
		if doubleVal, err := strconv.ParseFloat(value, 64); err == nil {
			return &v1.AnyValue{
				Value: &v1.AnyValue_DoubleValue{DoubleValue: doubleVal},
			}
		}
	case "bool":
		if boolVal, err := strconv.ParseBool(value); err == nil {
			return &v1.AnyValue{
				Value: &v1.AnyValue_BoolValue{BoolValue: boolVal},
			}
		}
	}
	
	// é»˜è®¤è¿”å›å­—ç¬¦ä¸²
	return &v1.AnyValue{
		Value: &v1.AnyValue_StringValue{StringValue: value},
	}
}

func main() {
	tc := &TypeConverter{}
	
	// æµ‹è¯•ç±»å‹è½¬æ¢
	testCases := []struct {
		name  string
		value interface{}
	}{
		{"string", "hello"},
		{"int", 42},
		{"int64", int64(1234567890)},
		{"float64", 3.14},
		{"bool", true},
		{"time", time.Now()},
	}
	
	for _, tc := range testCases {
		anyValue := tc.ConvertValue(tc.value)
		fmt.Printf("%s: %v\n", tc.name, anyValue)
	}
	
	// æµ‹è¯•å­—ç¬¦ä¸²è½¬æ¢
	stringCases := []struct {
		name       string
		value      string
		targetType string
	}{
		{"string to int", "123", "int"},
		{"string to double", "3.14", "double"},
		{"string to bool", "true", "bool"},
	}
	
	for _, sc := range stringCases {
		anyValue := tc.ConvertString(sc.value, sc.targetType)
		fmt.Printf("%s: %v\n", sc.name, anyValue)
	}
}
```

**Pythonå®ç°**ï¼š

```python
from datetime import datetime
from opentelemetry.proto.common.v1 import common_pb2

class TypeConverter:
    """ç±»å‹è½¬æ¢å™¨"""
    
    def convert_value(self, value):
        """è½¬æ¢å€¼ç±»å‹"""
        if isinstance(value, str):
            return common_pb2.AnyValue(string_value=value)
        elif isinstance(value, int):
            return common_pb2.AnyValue(int_value=value)
        elif isinstance(value, float):
            return common_pb2.AnyValue(double_value=value)
        elif isinstance(value, bool):
            return common_pb2.AnyValue(bool_value=value)
        elif isinstance(value, datetime):
            return common_pb2.AnyValue(string_value=value.isoformat())
        else:
            return common_pb2.AnyValue(string_value=str(value))
    
    def convert_string(self, value, target_type):
        """è½¬æ¢å­—ç¬¦ä¸²ä¸ºæŒ‡å®šç±»å‹"""
        if target_type == "string":
            return common_pb2.AnyValue(string_value=value)
        elif target_type == "int":
            try:
                return common_pb2.AnyValue(int_value=int(value))
            except ValueError:
                return common_pb2.AnyValue(string_value=value)
        elif target_type == "double":
            try:
                return common_pb2.AnyValue(double_value=float(value))
            except ValueError:
                return common_pb2.AnyValue(string_value=value)
        elif target_type == "bool":
            try:
                return common_pb2.AnyValue(bool_value=value.lower() == "true")
            except ValueError:
                return common_pb2.AnyValue(string_value=value)
        else:
            return common_pb2.AnyValue(string_value=value)

# æµ‹è¯•ç±»å‹è½¬æ¢
tc = TypeConverter()

test_cases = [
    ("string", "hello"),
    ("int", 42),
    ("float", 3.14),
    ("bool", True),
    ("datetime", datetime.now()),
]

for name, value in test_cases:
    any_value = tc.convert_value(value)
    print(f"{name}: {any_value}")

# æµ‹è¯•å­—ç¬¦ä¸²è½¬æ¢
string_cases = [
    ("string to int", "123", "int"),
    ("string to double", "3.14", "double"),
    ("string to bool", "true", "bool"),
]

for name, value, target_type in string_cases:
    any_value = tc.convert_string(value, target_type)
    print(f"{name}: {any_value}")
```

---

## 5. è½¬æ¢æ€§èƒ½åˆ†æ

### 5.1 è½¬æ¢æ€§èƒ½åŸºå‡†æµ‹è¯•

#### åŸºå‡†æµ‹è¯•ç»“æœ

```text
è½¬æ¢æ€§èƒ½åŸºå‡†æµ‹è¯•:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è½¬æ¢ç±»å‹    â”‚ æ•°æ®é‡    â”‚ è€—æ—¶(ms) â”‚ ååé‡   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Protobufâ†’JSON â”‚ 1KB       â”‚ 0.5      â”‚ 2MB/s   â”‚
â”‚  Protobufâ†’JSON â”‚ 10KB      â”‚ 2.1      â”‚ 4.8MB/s â”‚
â”‚  Protobufâ†’JSON â”‚ 100KB     â”‚ 18.5     â”‚ 5.4MB/s â”‚
â”‚  JSONâ†’Protobuf â”‚ 1KB       â”‚ 0.8      â”‚ 1.25MB/sâ”‚
â”‚  JSONâ†’Protobuf â”‚ 10KB      â”‚ 4.2      â”‚ 2.4MB/s â”‚
â”‚  JSONâ†’Protobuf â”‚ 100KB     â”‚ 38.2     â”‚ 2.6MB/s â”‚
â”‚  Protobufâ†’MsgPack â”‚ 1KB    â”‚ 0.3      â”‚ 3.3MB/s â”‚
â”‚  Protobufâ†’MsgPack â”‚ 10KB   â”‚ 1.5      â”‚ 6.7MB/s â”‚
â”‚  Protobufâ†’MsgPack â”‚ 100KB  â”‚ 12.8     â”‚ 7.8MB/s â”‚
â”‚  gRPCâ†’HTTP    â”‚ 1KB       â”‚ 1.2      â”‚ 0.8MB/s â”‚
â”‚  gRPCâ†’HTTP    â”‚ 10KB      â”‚ 3.5      â”‚ 2.9MB/s â”‚
â”‚  gRPCâ†’HTTP    â”‚ 100KB     â”‚ 28.5     â”‚ 3.5MB/s â”‚
â”‚  Jaegerâ†’OTLP  â”‚ 1KB       â”‚ 2.1      â”‚ 0.5MB/s â”‚
â”‚  Jaegerâ†’OTLP  â”‚ 10KB      â”‚ 8.5      â”‚ 1.2MB/s â”‚
â”‚  Jaegerâ†’OTLP  â”‚ 100KB     â”‚ 75.2     â”‚ 1.3MB/s â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 æ€§èƒ½ç“¶é¢ˆåˆ†æ

#### ç“¶é¢ˆè¯†åˆ«

```text
æ€§èƒ½ç“¶é¢ˆåˆ†æ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ“ä½œ          â”‚ CPUä½¿ç”¨ç‡ â”‚ å†…å­˜ä½¿ç”¨ â”‚ ç“¶é¢ˆ   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Protobufâ†’JSON â”‚ 15%      â”‚ ä½      â”‚ åºåˆ—åŒ– â”‚
â”‚  JSONâ†’Protobuf â”‚ 25%      â”‚ ä¸­      â”‚ è§£æ   â”‚
â”‚  Protobufâ†’MsgPack â”‚ 10%    â”‚ ä½      â”‚ å‹ç¼©   â”‚
â”‚  gRPCâ†’HTTP     â”‚ 30%      â”‚ é«˜      â”‚ åè®®   â”‚
â”‚  Jaegerâ†’OTLP   â”‚ 35%      â”‚ é«˜      â”‚ é€‚é…   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. è½¬æ¢ä¼˜åŒ–ç­–ç•¥

### 6.1 ç¼“å­˜è½¬æ¢ç»“æœ

#### è½¬æ¢ç»“æœç¼“å­˜

**Goå®ç°**ï¼š

```go
package main

import (
	"crypto/md5"
	"fmt"
	"sync"

	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protokit/proto"
)

// ConversionCache è½¬æ¢ç»“æœç¼“å­˜
type ConversionCache struct {
	mu    sync.RWMutex
	cache map[string][]byte
}

// NewConversionCache åˆ›å»ºè½¬æ¢ç¼“å­˜
func NewConversionCache() *ConversionCache {
	return &ConversionCache{
		cache: make(map[string][]byte),
	}
}

// Get è·å–ç¼“å­˜
func (cc *ConversionCache) Get(key string) ([]byte, bool) {
	cc.mu.RLock()
	defer cc.mu.RUnlock()
	
	value, ok := cc.cache[key]
	return value, ok
}

// Set è®¾ç½®ç¼“å­˜
func (cc *ConversionCache) Set(key string, value []byte) {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	
	cc.cache[key] = value
}

// GenerateKey ç”Ÿæˆç¼“å­˜é”®
func GenerateKey(pb proto.Message) string {
	data, _ := proto.Marshal(pb)
	hash := md5.Sum(data)
	return fmt.Sprintf("%x", hash)
}

// ProtobufToJSONCached å¸¦ç¼“å­˜çš„Protobufè½¬JSON
func ProtobufToJSONCached(pb proto.Message, cache *ConversionCache) ([]byte, error) {
	// ç”Ÿæˆç¼“å­˜é”®
	key := GenerateKey(pb)
	
	// æ£€æŸ¥ç¼“å­˜
	if cached, ok := cache.Get(key); ok {
		return cached, nil
	}
	
	// æ‰§è¡Œè½¬æ¢
	marshaler := protojson.MarshalOptions{
		Multiline:     true,
		Indent:        "  ",
		UseProtoNames: true,
	}
	
	jsonData, err := marshaler.Marshal(pb)
	if err != nil {
		return nil, err
	}
	
	// è®¾ç½®ç¼“å­˜
	cache.Set(key, jsonData)
	
	return jsonData, nil
}

func main() {
	// åˆ›å»ºç¼“å­˜
	cache := NewConversionCache()
	
	// åˆ›å»ºç¤ºä¾‹Span
	span := &v1.Span{
		TraceId:           []byte("1234567890abcdef1234567890abcdef"),
		SpanId:            []byte("abcdef1234567890"),
		Name:              "example-span",
		Kind:              v1.Span_SPAN_KIND_SERVER,
		StartTimeUnixNano: 1697123456789000000,
		EndTimeUnixNano:   1697123456790000000,
	}
	
	// ç¬¬ä¸€æ¬¡è½¬æ¢ï¼ˆæ— ç¼“å­˜ï¼‰
	jsonData1, _ := ProtobufToJSONCached(span, cache)
	fmt.Printf("First conversion: %d bytes\n", len(jsonData1))
	
	// ç¬¬äºŒæ¬¡è½¬æ¢ï¼ˆæœ‰ç¼“å­˜ï¼‰
	jsonData2, _ := ProtobufToJSONCached(span, cache)
	fmt.Printf("Second conversion: %d bytes\n", len(jsonData2))
	
	fmt.Printf("Cache hit: %v\n", len(jsonData1) == len(jsonData2))
}
```

**Pythonå®ç°**ï¼š

```python
import hashlib
from functools import lru_cache
from opentelemetry.proto.trace.v1 import trace_pb2
from google.protobuf.json_format import MessageToJson

class ConversionCache:
    """è½¬æ¢ç»“æœç¼“å­˜"""
    def __init__(self):
        self.cache = {}
    
    def get(self, key):
        """è·å–ç¼“å­˜"""
        return self.cache.get(key)
    
    def set(self, key, value):
        """è®¾ç½®ç¼“å­˜"""
        self.cache[key] = value

def generate_key(pb_message):
    """ç”Ÿæˆç¼“å­˜é”®"""
    data = pb_message.SerializeToString()
    return hashlib.md5(data).hexdigest()

def protobuf_to_json_cached(pb_message, cache):
    """å¸¦ç¼“å­˜çš„Protobufè½¬JSON"""
    # ç”Ÿæˆç¼“å­˜é”®
    key = generate_key(pb_message)
    
    # æ£€æŸ¥ç¼“å­˜
    cached = cache.get(key)
    if cached is not None:
        return cached
    
    # æ‰§è¡Œè½¬æ¢
    json_data = MessageToJson(
        pb_message,
        indent=2,
        preserving_proto_field_name=True
    )
    
    # è®¾ç½®ç¼“å­˜
    cache.set(key, json_data)
    
    return json_data

# åˆ›å»ºç¼“å­˜
cache = ConversionCache()

# åˆ›å»ºç¤ºä¾‹Span
span = trace_pb2.Span()
span.trace_id = b'1234567890abcdef1234567890abcdef'
span.span_id = b'abcdef1234567890'
span.name = 'example-span'
span.kind = trace_pb2.Span.SPAN_KIND_SERVER
span.start_time_unix_nano = 1697123456789000000
span.end_time_unix_nano = 1697123456790000000

# ç¬¬ä¸€æ¬¡è½¬æ¢ï¼ˆæ— ç¼“å­˜ï¼‰
json_data1 = protobuf_to_json_cached(span, cache)
print(f"First conversion: {len(json_data1)} bytes")

# ç¬¬äºŒæ¬¡è½¬æ¢ï¼ˆæœ‰ç¼“å­˜ï¼‰
json_data2 = protobuf_to_json_cached(span, cache)
print(f"Second conversion: {len(json_data2)} bytes")

print(f"Cache hit: {len(json_data1) == len(json_data2)}")
```

### 6.2 æ‰¹é‡è½¬æ¢

#### æ‰¹é‡è½¬æ¢ä¼˜åŒ–

**Goå®ç°**ï¼š

```go
package main

import (
	"fmt"
	"sync"

	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

// BatchConverter æ‰¹é‡è½¬æ¢å™¨
type BatchConverter struct {
	workers int
}

// NewBatchConverter åˆ›å»ºæ‰¹é‡è½¬æ¢å™¨
func NewBatchConverter(workers int) *BatchConverter {
	return &BatchConverter{
		workers: workers,
	}
}

// BatchProtobufToJSON æ‰¹é‡Protobufè½¬JSON
func (bc *BatchConverter) BatchProtobufToJSON(spans []*v1.Span) ([][]byte, error) {
	// åˆ›å»ºé€šé“
	jobs := make(chan *v1.Span, len(spans))
	results := make(chan []byte, len(spans))
	
	// å¯åŠ¨å·¥ä½œåç¨‹
	var wg sync.WaitGroup
	for i := 0; i < bc.workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for span := range jobs {
				marshaler := protojson.MarshalOptions{
					Multiline:     true,
					Indent:        "  ",
					UseProtoNames: true,
				}
				jsonData, err := marshaler.Marshal(span)
				if err != nil {
					results <- nil
				} else {
					results <- jsonData
				}
			}
		}()
	}
	
	// å‘é€ä»»åŠ¡
	go func() {
		for _, span := range spans {
			jobs <- span
		}
		close(jobs)
	}()
	
	// ç­‰å¾…å®Œæˆ
	go func() {
		wg.Wait()
		close(results)
	}()
	
	// æ”¶é›†ç»“æœ
	jsonDataList := make([][]byte, 0, len(spans))
	for jsonData := range results {
		if jsonData != nil {
			jsonDataList = append(jsonDataList, jsonData)
		}
	}
	
	return jsonDataList, nil
}

func main() {
	// åˆ›å»ºæ‰¹é‡è½¬æ¢å™¨
	converter := NewBatchConverter(4)
	
	// åˆ›å»ºç¤ºä¾‹Spans
	spans := make([]*v1.Span, 100)
	for i := 0; i < 100; i++ {
		spans[i] = &v1.Span{
			TraceId:           []byte(fmt.Sprintf("trace%d", i)),
			SpanId:            []byte(fmt.Sprintf("span%d", i)),
			Name:              fmt.Sprintf("span-%d", i),
			Kind:              v1.Span_SPAN_KIND_SERVER,
			StartTimeUnixNano: 1697123456789000000,
			EndTimeUnixNano:   1697123456790000000,
		}
	}
	
	// æ‰¹é‡è½¬æ¢
	jsonDataList, err := converter.BatchProtobufToJSON(spans)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
}
	
	fmt.Printf("Converted %d spans\n", len(jsonDataList))
}
```

**Pythonå®ç°**ï¼š

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
from opentelemetry.proto.trace.v1 import trace_pb2
from google.protobuf.json_format import MessageToJson

class BatchConverter:
    """æ‰¹é‡è½¬æ¢å™¨"""
    def __init__(self, workers=4):
        self.workers = workers
    
    def batch_protobuf_to_json(self, spans):
        """æ‰¹é‡Protobufè½¬JSON"""
        with ThreadPoolExecutor(max_workers=self.workers) as executor:
            futures = [executor.submit(self._convert_span, span) for span in spans]
            json_data_list = []
            for future in as_completed(futures):
                json_data = future.result()
                if json_data is not None:
                    json_data_list.append(json_data)
        return json_data_list
    
    def _convert_span(self, span):
        """è½¬æ¢å•ä¸ªSpan"""
        try:
            return MessageToJson(
                span,
                indent=2,
                preserving_proto_field_name=True
            )
        except Exception as e:
            print(f"Error converting span: {e}")
            return None

# åˆ›å»ºæ‰¹é‡è½¬æ¢å™¨
converter = BatchConverter(workers=4)

# åˆ›å»ºç¤ºä¾‹Spans
spans = []
for i in range(100):
    span = trace_pb2.Span()
    span.trace_id = f"trace{i}".encode()
    span.span_id = f"span{i}".encode()
    span.name = f"span-{i}"
    span.kind = trace_pb2.Span.SPAN_KIND_SERVER
    span.start_time_unix_nano = 1697123456789000000
    span.end_time_unix_nano = 1697123456790000000
    spans.append(span)

# æ‰¹é‡è½¬æ¢
json_data_list = converter.batch_protobuf_to_json(spans)
print(f"Converted {len(json_data_list)} spans")
```

### 6.3 å¹¶è¡Œè½¬æ¢

#### å¹¶è¡Œè½¬æ¢ä¼˜åŒ–

```text
å¹¶è¡Œè½¬æ¢æ€§èƒ½å¯¹æ¯”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è½¬æ¢æ–¹å¼    â”‚ æ•°æ®é‡    â”‚ è€—æ—¶(ms) â”‚ åŠ é€Ÿæ¯”   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¸²è¡Œè½¬æ¢    â”‚ 100KB     â”‚ 185      â”‚ 1.0x     â”‚
â”‚  2çº¿ç¨‹å¹¶è¡Œ   â”‚ 100KB     â”‚ 95       â”‚ 1.9x     â”‚
â”‚  4çº¿ç¨‹å¹¶è¡Œ   â”‚ 100KB     â”‚ 52       â”‚ 3.6x     â”‚
â”‚  8çº¿ç¨‹å¹¶è¡Œ   â”‚ 100KB     â”‚ 28       â”‚ 6.6x     â”‚
â”‚  16çº¿ç¨‹å¹¶è¡Œ  â”‚ 100KB     â”‚ 16       â”‚ 11.6x    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 å¤šåè®®æ”¯æŒå®æˆ˜

#### åœºæ™¯æè¿°

å¤§å‹å¾®æœåŠ¡ç³»ç»Ÿéœ€è¦åŒæ—¶æ”¯æŒgRPCå’ŒHTTPåè®®ï¼Œä»¥å®ç°çµæ´»çš„éƒ¨ç½²å’Œé›†æˆã€‚

#### è§£å†³æ–¹æ¡ˆ

```go
package main

import (
	"context"
	"fmt"
	"log"

	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protobuf/proto"
)

// MultiProtocolExporter å¤šåè®®å¯¼å‡ºå™¨
type MultiProtocolExporter struct {
	grpcEndpoint string
	httpEndpoint string
}

// NewMultiProtocolExporter åˆ›å»ºå¤šåè®®å¯¼å‡ºå™¨
func NewMultiProtocolExporter(grpcEndpoint, httpEndpoint string) *MultiProtocolExporter {
	return &MultiProtocolExporter{
		grpcEndpoint: grpcEndpoint,
		httpEndpoint: httpEndpoint,
	}
}

// ExportTraces å¯¼å‡ºTracesï¼ˆè‡ªåŠ¨é€‰æ‹©åè®®ï¼‰
func (mpe *MultiProtocolExporter) ExportTraces(ctx context.Context, traces *v1.TracesData) error {
	// åºåˆ—åŒ–Traces
	data, err := proto.Marshal(traces)
	if err != nil {
		return err
	}
	
	// å°è¯•gRPCåè®®
	if err := mpe.exportViaGRPC(ctx, data); err != nil {
		log.Printf("gRPC export failed: %v, falling back to HTTP", err)
		// é™çº§åˆ°HTTPåè®®
		return mpe.exportViaHTTP(ctx, data)
	}
	
	return nil
}

// exportViaGRPC é€šè¿‡gRPCå¯¼å‡º
func (mpe *MultiProtocolExporter) exportViaGRPC(ctx context.Context, data []byte) error {
	// gRPCå¯¼å‡ºé€»è¾‘
	fmt.Printf("Exporting via gRPC to %s\n", mpe.grpcEndpoint)
	return nil
}

// exportViaHTTP é€šè¿‡HTTPå¯¼å‡º
func (mpe *MultiProtocolExporter) exportViaHTTP(ctx context.Context, data []byte) error {
	// HTTPå¯¼å‡ºé€»è¾‘
	fmt.Printf("Exporting via HTTP to %s\n", mpe.httpEndpoint)
	return nil
}

func main() {
	// åˆ›å»ºå¤šåè®®å¯¼å‡ºå™¨
	exporter := NewMultiProtocolExporter(
		"localhost:4317",
		"http://localhost:4318/v1/traces",
	)
	
	// åˆ›å»ºç¤ºä¾‹Traces
	traces := &v1.TracesData{
		ResourceSpans: []*v1.ResourceSpans{
			{
				Resource: &v1.Resource{
					Attributes: []*v1.KeyValue{
						{
							Key: "service.name",
							Value: &v1.AnyValue{
								Value: &v1.AnyValue_StringValue{StringValue: "example-service"},
							},
						},
					},
				},
				ScopeSpans: []*v1.ScopeSpans{
					{
						Spans: []*v1.Span{
							{
								TraceId:           []byte("1234567890abcdef1234567890abcdef"),
								SpanId:            []byte("abcdef1234567890"),
								Name:              "example-span",
								Kind:              v1.Span_SPAN_KIND_SERVER,
								StartTimeUnixNano: 1697123456789000000,
								EndTimeUnixNano:   1697123456790000000,
							},
						},
					},
				},
			},
		},
	}
	
	// å¯¼å‡ºTraces
	ctx := context.Background()
	if err := exporter.ExportTraces(ctx, traces); err != nil {
		log.Fatal(err)
	}
	
	fmt.Println("Traces exported successfully")
}
```

### 7.2 æ•°æ®æ ¼å¼è½¬æ¢å®æˆ˜

#### åœºæ™¯æè¿°

ç³»ç»Ÿéœ€è¦å°†OTLPæ•°æ®è½¬æ¢ä¸ºå¤šç§æ ¼å¼ï¼Œä»¥é€‚é…ä¸åŒçš„åç«¯å­˜å‚¨ç³»ç»Ÿã€‚

#### è§£å†³æ–¹æ¡ˆ

```go
package main

import (
	"fmt"
	"log"

	"github.com/vmihailenco/msgpack/v5"
	"go.opentelemetry.io/proto/otlp/trace/v1"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

// FormatConverter æ ¼å¼è½¬æ¢å™¨
type FormatConverter struct{}

// NewFormatConverter åˆ›å»ºæ ¼å¼è½¬æ¢å™¨
func NewFormatConverter() *FormatConverter {
	return &FormatConverter{}
}

// ToJSON è½¬æ¢ä¸ºJSON
func (fc *FormatConverter) ToJSON(pb proto.Message) ([]byte, error) {
	marshaler := protojson.MarshalOptions{
		Multiline:     true,
		Indent:        "  ",
		UseProtoNames: true,
	}
	return marshaler.Marshal(pb)
}

// ToMessagePack è½¬æ¢ä¸ºMessagePack
func (fc *FormatConverter) ToMessagePack(pb proto.Message) ([]byte, error, error) {
	pbData, err := proto.Marshal(pb)
	if err != nil {
		return nil, err
	}
	
	msgpackData, err := msgpack.Marshal(pbData)
	return msgpackData, err
}

// ToProtobuf è½¬æ¢ä¸ºProtobuf
func (fc *FormatConverter) ToProtobuf(data []byte, pb proto.Message) error {
	return proto.Unmarshal(data, pb)
}

func main() {
	// åˆ›å»ºæ ¼å¼è½¬æ¢å™¨
	converter := NewFormatConverter()
	
	// åˆ›å»ºç¤ºä¾‹Span
	span := &v1.Span{
		TraceId:           []byte("1234567890abcdef1234567890abcdef"),
		SpanId:            []byte("abcdef1234567890"),
		Name:              "example-span",
		Kind:              v1.Span_SPAN_KIND_SERVER,
		StartTimeUnixNano: 1697123456789000000,
		EndTimeUnixNano:   1697123456790000000,
	}
	
	// è½¬æ¢ä¸ºJSON
	jsonData, err := converter.ToJSON(span)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("JSON size: %d bytes\n", len(jsonData))
	
	// è½¬æ¢ä¸ºMessagePack
	msgpackData, err := converter.ToMessagePack(span)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("MessagePack size: %d bytes\n", len(msgpackData))
	fmt.Printf("Compression ratio: %.2f%%\n", 
		float64(len(msgpackData))/float64(len(jsonData))*100)
}
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ ¼å¼è½¬æ¢æœ€ä½³å®è·µ

```text
æ ¼å¼è½¬æ¢æœ€ä½³å®è·µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… ä½¿ç”¨Protobufä½œä¸ºå†…éƒ¨æ ¼å¼                      â”‚
â”‚  âœ… ä»…åœ¨éœ€è¦æ—¶è½¬æ¢ä¸ºJSON                         â”‚
â”‚  âœ… ä½¿ç”¨MessagePackæ›¿ä»£JSONä»¥å‡å°ä½“ç§¯            â”‚
â”‚  âœ… ç¼“å­˜è½¬æ¢ç»“æœä»¥æå‡æ€§èƒ½                       â”‚
â”‚  âœ… æ‰¹é‡è½¬æ¢ä»¥æå‡ååé‡                         â”‚
â”‚  âœ… å¹¶è¡Œè½¬æ¢ä»¥é™ä½å»¶è¿Ÿ                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.2 åè®®è½¬æ¢æœ€ä½³å®è·µ

```text
åè®®è½¬æ¢æœ€ä½³å®è·µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… ä¼˜å…ˆä½¿ç”¨gRPCä»¥è·å¾—æœ€ä½³æ€§èƒ½                   â”‚
â”‚  âœ… ä½¿ç”¨HTTPä½œä¸ºé™çº§æ–¹æ¡ˆ                         â”‚
â”‚  âœ… æ”¯æŒHTTP/2ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½                   â”‚
â”‚  âœ… å®ç°è‡ªåŠ¨åè®®é™çº§                             â”‚
â”‚  âœ… ç›‘æ§åè®®è½¬æ¢æ€§èƒ½                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.3 æ•°æ®é€‚é…æœ€ä½³å®è·µ

```text
æ•°æ®é€‚é…æœ€ä½³å®è·µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… ä½¿ç”¨æ ‡å‡†å­—æ®µæ˜ å°„                              â”‚
â”‚  âœ… å®ç°ç±»å‹è½¬æ¢å™¨                                â”‚
â”‚  âœ… éªŒè¯æ•°æ®å®Œæ•´æ€§                                â”‚
â”‚  âœ… å¤„ç†æ•°æ®ç¼ºå¤±æƒ…å†µ                              â”‚
â”‚  âœ… è®°å½•é€‚é…æ—¥å¿—                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 9. æ€»ç»“

### 9.1 æ ¸å¿ƒè¦ç‚¹

```text
æ•°æ®è½¬æ¢ä¸é€‚é…æ ¸å¿ƒè¦ç‚¹:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. æ ¼å¼è½¬æ¢                                    â”‚
â”‚     - Protobuf â†” JSON                           â”‚
â”‚     - Protobuf â†” MessagePack                   â”‚
â”‚     - æ ¼å¼è½¬æ¢æ€§èƒ½ä¼˜åŒ–                          â”‚
â”‚                                                 â”‚
â”‚  2. åè®®è½¬æ¢                                    â”‚
â”‚     - gRPC â†” HTTP                               â”‚
â”‚     - HTTP/1.1 â†” HTTP/2                         â”‚
â”‚     - åè®®è½¬æ¢æ€§èƒ½ä¼˜åŒ–                          â”‚
â”‚                                                 â”‚
â”‚  3. æ•°æ®é€‚é…                                    â”‚
â”‚     - Jaeger â†’ OTLP                             â”‚
â”‚     - Zipkin â†’ OTLP                              â”‚
â”‚     - Prometheus â†’ OTLP                          â”‚
â”‚                                                 â”‚
â”‚  4. è½¬æ¢ä¼˜åŒ–                                    â”‚
â”‚     - ç¼“å­˜è½¬æ¢ç»“æœ                              â”‚
â”‚     - æ‰¹é‡è½¬æ¢                                  â”‚
â”‚     - å¹¶è¡Œè½¬æ¢                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.2 æ€§èƒ½æŒ‡æ ‡

```text
è½¬æ¢æ€§èƒ½æŒ‡æ ‡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è½¬æ¢ç±»å‹    â”‚ ååé‡(MB/s) â”‚ å»¶è¿Ÿ(ms) â”‚ å‹ç¼©ç‡ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Protobufâ†’JSON â”‚ 5.4          â”‚ 18.5     â”‚ 152%  â”‚
â”‚  Protobufâ†’MsgPack â”‚ 7.8        â”‚ 12.8     â”‚ 85%   â”‚
â”‚  gRPCâ†’HTTP    â”‚ 3.5          â”‚ 28.5     â”‚ -     â”‚
â”‚  Jaegerâ†’OTLP  â”‚ 1.3          â”‚ 75.2     â”‚ -     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.3 åº”ç”¨å»ºè®®

```text
åº”ç”¨å»ºè®®:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… ä¼˜å…ˆä½¿ç”¨Protobufä½œä¸ºå†…éƒ¨æ ¼å¼                  â”‚
â”‚  âœ… ä½¿ç”¨MessagePackæ›¿ä»£JSONä»¥å‡å°ä½“ç§¯            â”‚
â”‚  âœ… å®ç°å¤šåè®®æ”¯æŒä»¥å®ç°çµæ´»éƒ¨ç½²                 â”‚
â”‚  âœ… ä½¿ç”¨ç¼“å­˜å’Œæ‰¹é‡è½¬æ¢ä»¥æå‡æ€§èƒ½                 â”‚
â”‚  âœ… ç›‘æ§è½¬æ¢æ€§èƒ½ä»¥è¯†åˆ«ç“¶é¢ˆ                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥  
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ  
**ç‰ˆæœ¬**: 1.0.0

