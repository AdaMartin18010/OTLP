# OTLP语义模型扩展：自定义属性与查询能力

> **OTLP版本**: v1.0.0 (Stable)  
> **最后更新**: 2025年10月11日  
> **扩展目标**: 自定义语义约定、增强查询能力、支持业务模型  
> **文档状态**: ✅ 完成

---

## 📋 目录

- [OTLP语义模型扩展：自定义属性与查询能力](#otlp语义模型扩展自定义属性与查询能力)
  - [📋 目录](#-目录)
  - [🎯 执行摘要](#-执行摘要)
  - [📊 语义模型扩展框架](#-语义模型扩展框架)
    - [扩展层次](#扩展层次)
    - [扩展原则](#扩展原则)
  - [🔧 自定义属性定义](#-自定义属性定义)
    - [1. 属性命名约定](#1-属性命名约定)
    - [2. 电商系统自定义属性](#2-电商系统自定义属性)
    - [3. 金融系统自定义属性](#3-金融系统自定义属性)
  - [📚 语义约定扩展](#-语义约定扩展)
    - [1. 语义约定文档结构](#1-语义约定文档结构)
    - [2. 语义约定注册](#2-语义约定注册)
  - [🔍 查询能力增强](#-查询能力增强)
    - [1. SQL-like查询](#1-sql-like查询)
    - [2. 聚合查询](#2-聚合查询)
    - [3. 全文搜索](#3-全文搜索)
  - [🗺️ 业务模型映射](#️-业务模型映射)
    - [1. 电商订单模型映射](#1-电商订单模型映射)
    - [2. 金融交易模型映射](#2-金融交易模型映射)
  - [💡 最佳实践](#-最佳实践)
    - [1. 属性定义最佳实践](#1-属性定义最佳实践)
    - [2. 查询优化最佳实践](#2-查询优化最佳实践)
    - [3. 性能优化建议](#3-性能优化建议)
  - [📚 参考资源](#-参考资源)

---

## 🎯 执行摘要

**OTLP语义模型扩展**提供了灵活的自定义能力，支持业务特定的语义约定和查询需求：

```text
扩展能力:
┌─────────────────────────────────────────────────┐
│          语义模型扩展三大能力                     │
├─────────────────────────────────────────────────┤
│                                                 │
│  🔧 自定义属性: 定义业务特定的属性命名             │
│  📊 语义约定: 扩展标准语义约定                    │
│  🔍 查询增强: 支持复杂查询和聚合                   │
│                                                 │
└─────────────────────────────────────────────────┘
```

**核心扩展技术**：

1. **自定义属性**：定义业务特定的键值对属性
2. **语义约定扩展**：创建领域特定的语义约定
3. **查询能力增强**：支持SQL-like查询和聚合
4. **业务模型映射**：将业务模型映射到OTLP数据模型

---

## 📊 语义模型扩展框架

### 扩展层次

```text
OTLP语义模型扩展层次:
┌─────────────────────────────────────────────────┐
│             业务层扩展                           │
│  - 业务属性定义 (Custom Attributes)              │
│  - 业务语义约定 (Domain Conventions)             │
│  - 业务模型映射 (Business Model Mapping)         │
├─────────────────────────────────────────────────┤
│             应用层扩展                           │
│  - 自定义Instrumentation (Custom SDK)            │
│  - 属性提取器 (Attribute Extractors)             │
│  - 语义增强器 (Semantic Enrichers)               │
├─────────────────────────────────────────────────┤
│             数据层扩展                           │
│  - 属性类型扩展 (Extended Types)                 │
│  - 查询能力增强 (Query Enhancement)              │
│  - 索引策略 (Indexing Strategies)                │
├─────────────────────────────────────────────────┤
│             存储层扩展                           │
│  - 自定义Schema (Custom Schema)                  │
│  - 物化视图 (Materialized Views)                 │
│  - 聚合表 (Aggregation Tables)                   │
└─────────────────────────────────────────────────┘
```

### 扩展原则

```text
定义 (扩展原则):
SemanticExtensionPrinciples = {
  compatibility: bool,      // 向后兼容
  standardization: bool,     // 标准化命名
  documentation: bool,       // 完整文档
  versioning: bool          // 版本管理
}

扩展原则:
✅ 向后兼容: 不破坏现有语义约定
✅ 标准化命名: 遵循命名约定 (namespace.attribute)
✅ 完整文档: 提供详细的属性说明
✅ 版本管理: 支持语义约定的版本演进
```

---

## 🔧 自定义属性定义

### 1. 属性命名约定

**标准命名格式**：

```扩展属性命名约定:
┌─────────────────────────────────────────────────┐
│  标准格式: <namespace>.<category>.<attribute>  │
├─────────────────────────────────────────────────┤
│                                                 │
│  示例:                                          │
│  - business.order.total_amount                  │
│  - business.order.status                        │
│  - business.payment.method                      │
│  - business.payment.transaction_id              │
│                                                 │
│  命名规则:                                       │
│  ✅ 使用小写字母和下划线                         │
│  ✅ 使用有意义的命名空间                         │
│  ✅ 避免缩写和歧义                               │
│  ❌ 不使用驼峰命名 (camelCase)                   │
│  ❌ 不使用特殊字符 (@#$%等)                      │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 2. 电商系统自定义属性

**订单处理属性**：

```go
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// 电商系统自定义属性
const (
    // 订单属性
    OrderIDAttr           = "business.order.id"
    OrderStatusAttr       = "business.order.status"
    OrderTotalAmountAttr  = "business.order.total_amount"
    OrderCurrencyAttr     = "business.order.currency"
    OrderItemCountAttr    = "business.order.item_count"
    OrderDiscountAttr     = "business.order.discount"
    
    // 支付属性
    PaymentMethodAttr     = "business.payment.method"
    PaymentTransactionIDAttr = "business.payment.transaction_id"
    PaymentAmountAttr     = "business.payment.amount"
    PaymentStatusAttr     = "business.payment.status"
    
    // 用户属性
    UserIDAttr            = "business.user.id"
    UserLevelAttr         = "business.user.level"
    UserVipAttr           = "business.user.is_vip"
    
    // 商品属性
    ProductIDAttr         = "business.product.id"
    ProductCategoryAttr   = "business.product.category"
    ProductPriceAttr      = "business.product.price"
    ProductStockAttr      = "business.product.stock"
)

// 订单处理Span
func processOrder(ctx context.Context, order *Order) error {
    tracer := otel.Tracer("order-service")
    
    ctx, span := tracer.Start(ctx, "process_order",
        trace.WithAttributes(
            attribute.String(OrderIDAttr, order.ID),
            attribute.String(OrderStatusAttr, string(order.Status)),
            attribute.Float64(OrderTotalAmountAttr, order.TotalAmount),
            attribute.String(OrderCurrencyAttr, order.Currency),
            attribute.Int(OrderItemCountAttr, len(order.Items)),
        ),
    )
    defer span.End()
    
    // 处理订单逻辑
    if err := validateOrder(ctx, order); err != nil {
        span.RecordError(err)
        span.SetAttributes(
            attribute.String(OrderStatusAttr, "failed"),
        )
        return err
    }
    
    // 支付处理
    if err := processPayment(ctx, order); err != nil {
        span.RecordError(err)
        return err
    }
    
    // 更新订单状态
    span.SetAttributes(
        attribute.String(OrderStatusAttr, "completed"),
    )
    
    return nil
}

// 支付处理Span
func processPayment(ctx context.Context, order *Order) error {
    tracer := otel.Tracer("payment-service")
    
    ctx, span := tracer.Start(ctx, "process_payment",
        trace.WithAttributes(
            attribute.String(OrderIDAttr, order.ID),
            attribute.String(PaymentMethodAttr, order.PaymentMethod),
            attribute.Float64(PaymentAmountAttr, order.TotalAmount),
        ),
    )
    defer span.End()
    
    // 调用支付网关
    transactionID, err := callPaymentGateway(ctx, order)
    if err != nil {
        span.SetAttributes(
            attribute.String(PaymentStatusAttr, "failed"),
        )
        return err
    }
    
    // 记录交易ID
    span.SetAttributes(
        attribute.String(PaymentTransactionIDAttr, transactionID),
        attribute.String(PaymentStatusAttr, "completed"),
    )
    
    return nil
}
```

### 3. 金融系统自定义属性

**交易处理属性**：

```go
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// 金融系统自定义属性
const (
    // 交易属性
    TransactionIDAttr     = "finance.transaction.id"
    TransactionTypeAttr   = "finance.transaction.type"
    TransactionAmountAttr = "finance.transaction.amount"
    TransactionCurrencyAttr = "finance.transaction.currency"
    TransactionFeeAttr    = "finance.transaction.fee"
    
    // 账户属性
    AccountFromAttr       = "finance.account.from"
    AccountToAttr         = "finance.account.to"
    AccountBalanceAttr    = "finance.account.balance"
    
    // 风控属性
    RiskScoreAttr         = "finance.risk.score"
    RiskLevelAttr         = "finance.risk.level"
    RiskRulesAttr         = "finance.risk.rules"
    
    // 合规属性
    ComplianceCheckAttr   = "finance.compliance.check"
    ComplianceStatusAttr = "finance.compliance.status"
    ComplianceReasonAttr = "finance.compliance.reason"
)

// 转账处理Span
func transferMoney(ctx context.Context, transfer *Transfer) {
    tracer := otel.Tracer("transfer-service")
    
    ctx, span := tracer.Start(ctx, "transfer_money",
        trace.WithAttributes(
            attribute.String(TransactionIDAttr, transfer.ID),
            attribute.String(TransactionTypeAttr, "transfer"),
            attribute.Float64(TransactionAmountAttr, transfer.Amount),
            attribute.String(TransactionCurrencyAttr, transfer.Currency),
            attribute.String(AccountFromAttr, transfer.FromAccount),
            attribute.String(AccountToAttr, transfer.ToAccount),
        ),
    )
    defer span.End()
    
    // 风控检查
    riskScore := checkRisk(ctx, transfer)
    span.SetAttributes(
        attribute.Int(RiskScoreAttr, riskScore),
    )
    
    if riskScore > 80 {
        span.SetAttributes(
            attribute.String(RiskLevelAttr, "high"),
            attribute.String(TransactionTypeAttr, "blocked"),
        )
        return errors.New("high risk transaction")
    }
    
    // 合规检查
    complianceStatus := checkCompliance(ctx, transfer)
    span.SetAttributes(
        attribute.String(ComplianceCheckAttr, "passed"),
        attribute.String(ComplianceStatusAttr, complianceStatus),
    )
    
    // 执行转账
    if err := executeTransfer(ctx, transfer); err != nil {
        span.RecordError(err)
        return err
    }
    
    span.SetAttributes(
        attribute.String(TransactionTypeAttr, "completed"),
    )
}
```

---

## 📚 语义约定扩展

### 1. 语义约定文档结构

**自定义语义约定模板**：

```markdown
    # Custom Semantic Conventions

    ## Overview
    This document defines custom semantic conventions for [Domain Name].

    ## Attributes

    ### business.order.*

    Attributes for order processing.

    | Attribute Name | Type | Description | Examples | Required |
    |----------------|------|-------------|----------|----------|
    | `business.order.id` | string | Unique order identifier | `"ORD-2025-001"` | Yes |
    | `business.order.status` | string | Order status | `"pending"`, `"completed"` | Yes |
    | `business.order.total_amount` | double | Total order amount | `99.99` | Yes |
    | `business.order.currency` | string | Order currency | `"USD"`, `"CNY"` | Yes |
    | `business.order.item_count` | int | Number of items | `3` | No |

    ### business.payment.*

    Attributes for payment processing.

    | Attribute Name | Type | Description | Examples | Required |
    |----------------|------|-------------|----------|----------|
    | `business.payment.method` | string | Payment method | `"credit_card"`, `"alipay"` | Yes |
    | `business.payment.transaction_id` | string | Payment transaction ID | `"TXN-123456"` | No |
    | `business.payment.amount` | double | Payment amount | `99.99` | Yes |
    | `business.payment.status` | string | Payment status | `"success"`, `"failed"` | Yes |

    ## Examples

    ### Order Processing Span

    ```go
    span.SetAttributes(
        attribute.String("business.order.id", "ORD-2025-001"),
        attribute.String("business.order.status", "pending"),
        attribute.Float64("business.order.total_amount", 99.99),
        attribute.String("business.order.currency", "USD"),
        attribute.Int("business.order.item_count", 3),
    )
    ```

    ### Payment Processing Span

    ```go
    span.SetAttributes(
        attribute.String("business.payment.method", "credit_card"),
        attribute.String("business.payment.transaction_id", "TXN-123456"),
        attribute.Float64("business.payment.amount", 99.99),
        attribute.String("business.payment.status", "success"),
    )
    ```

    ## Versioning

    - Version 1.0.0 (2025-10-11): Initial release

```

### 2. 语义约定注册

```go
package main

import (
    "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// 语义约定注册中心
type SemanticConventionRegistry struct {
    conventions map[string]*SemanticConvention
}

type SemanticConvention struct {
    Name        string
    Version     string
    Attributes  []AttributeDefinition
    Examples    []Example
}

type AttributeDefinition struct {
    Name        string
    Type        string
    Description string
    Required    bool
    Examples    []string
}

// 注册自定义语义约定
func (r *SemanticConventionRegistry) Register(convention *SemanticConvention) {
    r.conventions[convention.Name] = convention
}

// 验证属性是否符合约定
func (r *SemanticConventionRegistry) ValidateAttribute(name string, value interface{}) error {
    // 查找对应的语义约定
    convention := r.findConvention(name)
    if convention == nil {
        return fmt.Errorf("unknown semantic convention: %s", name)
    }
    
    // 验证属性类型
    attrDef := convention.FindAttribute(name)
    if attrDef == nil {
        return fmt.Errorf("unknown attribute: %s", name)
    }
    
    // 类型验证
    if !isValidType(value, attrDef.Type) {
        return fmt.Errorf("invalid type for %s: expected %s", name, attrDef.Type)
    }
    
    return nil
}

// 使用示例
func init() {
    registry := NewSemanticConventionRegistry()
    
    // 注册电商语义约定
    registry.Register(&SemanticConvention{
        Name:    "business.order",
        Version: "1.0.0",
        Attributes: []AttributeDefinition{
            {
                Name:        "business.order.id",
                Type:        "string",
                Description: "Unique order identifier",
                Required:    true,
                Examples:    []string{"ORD-2025-001"},
            },
            {
                Name:        "business.order.status",
                Type:        "string",
                Description: "Order status",
                Required:    true,
                Examples:    []string{"pending", "completed", "cancelled"},
            },
        },
    })
}
```

---

## 🔍 查询能力增强

### 1. SQL-like查询

**OTLP数据查询接口**：

```go
package main

import (
    "context"
    "fmt"
)

// OTLP查询接口
type OTLPQuery interface {
    // 查询Traces
    QueryTraces(ctx context.Context, query *TraceQuery) ([]*Trace, error)
    
    // 查询Metrics
    QueryMetrics(ctx context.Context, query *MetricQuery) ([]*Metric, error)
    
    // 查询Logs
    QueryLogs(ctx context.Context, query *LogQuery) ([]*Log, error)
}

// Trace查询
type TraceQuery struct {
    TraceID       string
    ServiceName   string
    OperationName string
    
    // 属性过滤
    Attributes map[string]interface{}
    
    // 时间范围
    StartTime int64
    EndTime   int64
    
    // 分页
    Limit  int
    Offset int
    
    // 排序
    OrderBy string
}

// 查询实现示例
func (db *OTLPDatabase) QueryTraces(ctx context.Context, query *TraceQuery) ([]*Trace, error) {
    sql := `
        SELECT 
            trace_id,
            span_id,
            parent_span_id,
            name,
            start_time,
            end_time,
            attributes
        FROM spans
        WHERE 1=1
    `
    
    args := []interface{}{}
    
    // TraceID过滤
    if query.TraceID != "" {
        sql += " AND trace_id = $1"
        args = append(args, query.TraceID)
    }
    
    // 服务名过滤
    if query.ServiceName != "" {
        sql += " AND attributes->>'service.name' = $2"
        args = append(args, query.ServiceName)
    }
    
    // 操作名过滤
    if query.OperationName != "" {
        sql += " AND name = $3"
        args = append(args, query.OperationName)
    }
    
    // 属性过滤
    for key, value := range query.Attributes {
        sql += fmt.Sprintf(" AND attributes->>'%s' = $%d", key, len(args)+1)
        args = append(args, value)
    }
    
    // 时间范围过滤
    if query.StartTime > 0 {
        sql += fmt.Sprintf(" AND start_time >= $%d", len(args)+1)
        args = append(args, query.StartTime)
    }
    
    if query.EndTime > 0 {
        sql += fmt.Sprintf(" AND end_time <= $%d", len(args)+1)
        args = append(args, query.EndTime)
    }
    
    // 排序
    if query.OrderBy != "" {
        sql += " ORDER BY " + query.OrderBy
    }
    
    // 分页
    if query.Limit > 0 {
        sql += fmt.Sprintf(" LIMIT $%d", len(args)+1)
        args = append(args, query.Limit)
    }
    
    if query.Offset > 0 {
        sql += fmt.Sprintf(" OFFSET $%d", len(args)+1)
        args = append(args, query.Offset)
    }
    
    // 执行查询
    rows, err := db.Query(ctx, sql, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var traces []*Trace
    for rows.Next() {
        var trace Trace
        if err := rows.Scan(&trace); err != nil {
            return nil, err
        }
        traces = append(traces, &trace)
    }
    
    return traces, nil
}
```

### 2. 聚合查询

**Metrics聚合查询**：

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// Metrics聚合查询
type MetricAggregationQuery struct {
    MetricName string
    Dimensions []string
    
    // 聚合函数
    Aggregation string  // sum, avg, max, min, count
    
    // 时间范围
    StartTime int64
    EndTime   int64
    
    // 分组
    GroupBy []string
    
    // 过滤条件
    Filters map[string]interface{}
}

// 聚合查询实现
func (db *OTLPDatabase) QueryAggregatedMetrics(ctx context.Context, query *MetricAggregationQuery) ([]*AggregatedMetric, error) {
    sql := fmt.Sprintf(`
        SELECT 
            %s,
            %s(metric_value) as aggregated_value
        FROM metrics
        WHERE metric_name = $1
          AND time_unix_nano >= $2
          AND time_unix_nano <= $3
    `, 
        formatGroupBy(query.GroupBy),
        query.Aggregation,
    )
    
    args := []interface{}{
        query.MetricName,
        query.StartTime,
        query.EndTime,
    }
    
    // 维度过滤
    for _, dim := range query.Dimensions {
        sql += fmt.Sprintf(" AND attributes->>'%s' IS NOT NULL", dim)
    }
    
    // 过滤条件
    for key, value := range query.Filters {
        // 添加过滤参数
        paramIndex := len(args) + 1
        sql += fmt.Sprintf(" AND attributes->>'%s' = $%d", key, paramIndex)
        args = append(args, value)
    }
    
    // 分组
    if len(query.GroupBy) > 0 {
        sql += " GROUP BY " + formatGroupBy(query.GroupBy)
    }
    
    // 执行查询
    rows, err := db.Query(ctx, sql, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var results []*AggregatedMetric
    for rows.Next() {
        var result AggregatedMetric
        if err := rows.Scan(&result); err != nil {
            return nil, err
        }
        results = append(results, &result)
    }
    
    return results, nil
}

func formatGroupBy(groupBy []string) string {
    if len(groupBy) == 0 {
        return "time_bucket('1 hour', time_unix_nano)"
    }
    
    formatted := []string{"time_bucket('1 hour', time_unix_nano)"}
    for _, gb := range groupBy {
        formatted = append(formatted, fmt.Sprintf("attributes->>'%s'", gb))
    }
    
    return strings.Join(formatted, ", ")
}

// 使用示例
func queryOrderMetrics(ctx context.Context, db *OTLPDatabase) {
    query := &MetricAggregationQuery{
        MetricName: "business.order.total_amount",
        Aggregation: "sum",
        StartTime: time.Now().Add(-24 * time.Hour).UnixNano(),
        EndTime:   time.Now().UnixNano(),
        GroupBy: []string{"business.order.status"},
        Filters: map[string]interface{}{
            "business.order.currency": "USD",
        },
    }
    
    results, err := db.QueryAggregatedMetrics(ctx, query)
    if err != nil {
        log.Fatal(err)
    }
    
    for _, result := range results {
        fmt.Printf("Status: %s, Total: %.2f\n", 
            result.GroupBy["business.order.status"], 
            result.Value)
    }
}
```

### 3. 全文搜索

**Logs全文搜索**：

```go
package main

import (
    "context"
    "fmt"
)

// Logs全文搜索
type LogSearchQuery struct {
    Query string
    
    // 时间范围
    StartTime int64
    EndTime   int64
    
    // 严重性过滤
    Severity []string
    
    // 服务过滤
    ServiceName string
    
    // 属性过滤
    Attributes map[string]interface{}
    
    // 分页
    Limit  int
    Offset int
}

// 全文搜索实现 (PostgreSQL)
func (db *OTLPDatabase) SearchLogs(ctx context.Context, query *LogSearchQuery) ([]*Log, error) {
    sql := `
        SELECT 
            log_id,
            time_unix_nano,
            severity_number,
            severity_text,
            body,
            attributes,
            trace_id,
            span_id
        FROM logs
        WHERE to_tsvector('english', body) @@ to_tsquery('english', $1)
    `
    
    args := []interface{}{query.Query}
    
    // 时间范围过滤
    if query.StartTime > 0 {
        sql += fmt.Sprintf(" AND time_unix_nano >= $%d", len(args)+1)
        args = append(args, query.StartTime)
    }
    
    if query.EndTime > 0 {
        sql += fmt.Sprintf(" AND time_unix_nano <= $%d", len(args)+1)
        args = append(args, query.EndTime)
    }
    
    // 严重性过滤
    if len(query.Severity) > 0 {
        sql += fmt.Sprintf(" AND severity_text = ANY($%d)", len(args)+1)
        args = append(args, query.Severity)
    }
    
    // 服务过滤
    if query.ServiceName != "" {
        sql += fmt.Sprintf(" AND attributes->>'service.name' = $%d", len(args)+1)
        args = append(args, query.ServiceName)
    }
    
    // 属性过滤
    for key, value := range query.Attributes {
        sql += fmt.Sprintf(" AND attributes->>'%s' = $%d", key, len(args)+1)
        args = append(args, value)
    }
    
    // 排序
    sql += " ORDER BY time_unix_nano DESC"
    
    // 分页
    if query.Limit > 0 {
        sql += fmt.Sprintf(" LIMIT $%d", len(args)+1)
        args = append(args, query.Limit)
    }
    
    if query.Offset > 0 {
        sql += fmt.Sprintf(" OFFSET $%d", len(args)+1)
        args = append(args, query.Offset)
    }
    
    // 执行查询
    rows, err := db.Query(ctx, sql, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var logs []*Log
    for rows.Next() {
        var log Log
        if err := rows.Scan(&log); err != nil {
            return nil, err
        }
        logs = append(logs, &log)
    }
    
    return logs, nil
}

// 使用示例
func searchErrorLogs(ctx context.Context, db *OTLPDatabase) {
    query := &LogSearchQuery{
        Query:      "payment failed",
        StartTime:  time.Now().Add(-1 * time.Hour).UnixNano(),
        EndTime:    time.Now().UnixNano(),
        Severity:   []string{"ERROR", "FATAL"},
        ServiceName: "payment-service",
        Limit:      100,
    }
    
    logs, err := db.SearchLogs(ctx, query)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Found %d error logs\n", len(logs))
    for _, log := range logs {
        fmt.Printf("[%s] %s: %s\n", 
            log.SeverityText, 
            log.Time.Format(time.RFC3339),
            log.Body)
    }
}
```

---

## 🗺️ 业务模型映射

### 1. 电商订单模型映射

**业务模型到OTLP映射**：

```go
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// 电商订单业务模型
type Order struct {
    ID          string
    UserID      string
    Status      OrderStatus
    TotalAmount float64
    Currency    string
    Items       []OrderItem
    Payment     Payment
    Shipping    Shipping
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

type OrderItem struct {
    ProductID   string
    ProductName string
    Quantity    int
    Price       float64
}

type Payment struct {
    Method        string
    TransactionID string
    Amount        float64
    Status        PaymentStatus
}

// OTLP映射器
type OrderOTLPMapper struct{}

func (m *OrderOTLPMapper) MapToSpan(order *Order) trace.SpanConfig {
    return trace.SpanConfig{
        Name: "process_order",
        Attributes: []attribute.KeyValue{
            // 订单属性
            attribute.String("business.order.id", order.ID),
            attribute.String("business.order.status", string(order.Status)),
            attribute.Float64("business.order.total_amount", order.TotalAmount),
            attribute.String("business.order.currency", order.Currency),
            attribute.Int("business.order.item_count", len(order.Items)),
            
            // 用户属性
            attribute.String("business.user.id", order.UserID),
            
            // 支付属性
            attribute.String("business.payment.method", order.Payment.Method),
            attribute.String("business.payment.transaction_id", order.Payment.TransactionID),
            attribute.Float64("business.payment.amount", order.Payment.Amount),
            attribute.String("business.payment.status", string(order.Payment.Status)),
            
            // 时间属性
            attribute.Int64("business.order.created_at", order.CreatedAt.UnixNano()),
            attribute.Int64("business.order.updated_at", order.UpdatedAt.UnixNano()),
        },
    }
}

func (m *OrderOTLPMapper) MapToMetrics(order *Order) []Metric {
    metrics := []Metric{
        {
            Name:  "business.order.total_amount",
            Value: order.TotalAmount,
            Attributes: map[string]interface{}{
                "business.order.status":  string(order.Status),
                "business.order.currency": order.Currency,
            },
        },
        {
            Name:  "business.order.count",
            Value: 1,
            Attributes: map[string]interface{}{
                "business.order.status": string(order.Status),
            },
        },
        {
            Name:  "business.order.item_count",
            Value: float64(len(order.Items)),
            Attributes: map[string]interface{}{
                "business.order.status": string(order.Status),
            },
        },
    }
    
    return metrics
}

func (m *OrderOTLPMapper) MapToLogs(order *Order, event string) Log {
    return Log{
        Time:      time.Now(),
        Severity:  getSeverityFromOrderStatus(order.Status),
        Body:      fmt.Sprintf("Order %s: %s", order.ID, event),
        Attributes: map[string]interface{}{
            "business.order.id":     order.ID,
            "business.order.status": string(order.Status),
            "business.event.type":   event,
        },
    }
}

func getSeverityFromOrderStatus(status OrderStatus) string {
    switch status {
    case OrderStatusCompleted:
        return "INFO"
    case OrderStatusFailed:
        return "ERROR"
    case OrderStatusCancelled:
        return "WARN"
    default:
        return "INFO"
    }
}
```

### 2. 金融交易模型映射

**金融交易模型到OTLP映射**：

```go
package main

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// 金融交易业务模型
type Transaction struct {
    ID              string
    Type            TransactionType
    FromAccount     string
    ToAccount       string
    Amount          float64
    Currency        string
    Fee             float64
    Status          TransactionStatus
    RiskScore       int
    ComplianceCheck ComplianceCheck
    Timestamp       time.Time
}

type ComplianceCheck struct {
    Status string
    Reason string
    Rules  []string
}

// OTLP映射器
type TransactionOTLPMapper struct{}

func (m *TransactionOTLPMapper) MapToSpan(txn *Transaction) trace.SpanConfig {
    return trace.SpanConfig{
        Name: "process_transaction",
        Attributes: []attribute.KeyValue{
            // 交易属性
            attribute.String("finance.transaction.id", txn.ID),
            attribute.String("finance.transaction.type", string(txn.Type)),
            attribute.Float64("finance.transaction.amount", txn.Amount),
            attribute.String("finance.transaction.currency", txn.Currency),
            attribute.Float64("finance.transaction.fee", txn.Fee),
            attribute.String("finance.transaction.status", string(txn.Status)),
            
            // 账户属性
            attribute.String("finance.account.from", txn.FromAccount),
            attribute.String("finance.account.to", txn.ToAccount),
            
            // 风控属性
            attribute.Int("finance.risk.score", txn.RiskScore),
            
            // 合规属性
            attribute.String("finance.compliance.status", txn.ComplianceCheck.Status),
            attribute.String("finance.compliance.reason", txn.ComplianceCheck.Reason),
            
            // 时间属性
            attribute.Int64("finance.transaction.timestamp", txn.Timestamp.UnixNano()),
        },
    }
}

func (m *TransactionOTLPMapper) MapToMetrics(txn *Transaction) []Metric {
    metrics := []Metric{
        {
            Name:  "finance.transaction.amount",
            Value: txn.Amount,
            Attributes: map[string]interface{}{
                "finance.transaction.type":   string(txn.Type),
                "finance.transaction.status": string(txn.Status),
                "finance.transaction.currency": txn.Currency,
            },
        },
        {
            Name:  "finance.transaction.count",
            Value: 1,
            Attributes: map[string]interface{}{
                "finance.transaction.type":   string(txn.Type),
                "finance.transaction.status": string(txn.Status),
            },
        },
        {
            Name:  "finance.transaction.fee",
            Value: txn.Fee,
            Attributes: map[string]interface{}{
                "finance.transaction.type":   string(txn.Type),
                "finance.transaction.status": string(txn.Status),
            },
        },
    }
    
    return metrics
}
```

---

## 💡 最佳实践

### 1. 属性定义最佳实践

```text
属性定义最佳实践:
┌─────────────────────────────────────────────────┐
│  ✅ 推荐做法                                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  1. 使用有意义的命名空间                         │
│     business.order.*                            │
│     finance.transaction.*                       │
│                                                 │
│  2. 使用标准化的属性名称                         │
│     business.order.id (而非 order_id)           │
│     business.order.status (而非 orderStatus)     │
│                                                 │
│  3. 提供完整的属性文档                           │
│     - 属性名称、类型、描述                       │
│     - 示例值、必需性                            │
│     - 版本信息                                  │
│                                                 │
│  4. 使用合适的数据类型                           │
│     - string: 文本标识符                         │
│     - int: 计数、分数                           │
│     - double: 金额、百分比                       │
│     - bool: 标志位                              │
│                                                 │
│  5. 避免敏感信息                                │
│     ❌ business.user.password                    │
│     ✅ business.user.id (使用ID而非密码)         │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 2. 查询优化最佳实践

```text
查询优化最佳实践:
┌─────────────────────────────────────────────────┐
│  ✅ 推荐做法                                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  1. 使用索引优化查询                             │
│     CREATE INDEX idx_trace_id ON spans(trace_id)│
│     CREATE INDEX idx_service ON spans(attributes)│
│                                                 │
│  2. 限制查询时间范围                             │
│     WHERE start_time >= NOW() - INTERVAL '1h'  │
│                                                 │
│  3. 使用分页避免大量数据                         │
│     LIMIT 100 OFFSET 0                          │
│                                                 │
│  4. 使用物化视图加速聚合                         │
│     CREATE MATERIALIZED VIEW mv_order_stats AS  │
│     SELECT ... GROUP BY ...                     │
│                                                 │
│  5. 缓存热点查询结果                             │
│     Redis缓存常用查询结果                        │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 3. 性能优化建议

```text
性能优化建议:
┌─────────────────────────────────────────────────┐
│  优化项         │ 建议值          │ 说明           │
├─────────────────────────────────────────────────┤
│  属性数量       │ ≤ 20个/Span     │ 避免过多属性   │
│  属性值大小     │ ≤ 1KB           │ 避免大值       │
│  查询时间范围   │ ≤ 24小时        │ 避免全表扫描   │
│  分页大小       │ 100-1000条      │ 平衡性能       │
│  索引数量       │ ≤ 10个表        │ 避免过多索引   │
│  缓存TTL        │ 5-60分钟        │ 平衡实时性     │
└─────────────────────────────────────────────────┘
```

---

## 📚 参考资源

- [OpenTelemetry语义约定](https://opentelemetry.io/docs/specs/semconv/)
- [自定义语义约定指南](https://opentelemetry.io/docs/specs/semconv/general/attributes/)
- [属性命名约定](https://opentelemetry.io/docs/specs/semconv/general/attribute-naming/)
- [OTLP查询接口规范](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md)

---

**最后更新**: 2025年10月11日  
**维护者**: OTLP深度梳理团队  
**版本**: 1.0.0
