# OTLPèƒ½æºäº¤é€šå†œä¸šè¡Œä¸šæ¡ˆä¾‹

> **æ–‡æ¡£ç¼–å·**: 36  
> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1011æ—¥  
> **æ–‡æ¡£ç±»å‹**: è¡Œä¸šå®æˆ˜æ¡ˆä¾‹  
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ  
> **å†…å®¹è§„æ¨¡**: 2,500+ è¡Œ

---

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

### æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£æä¾›OTLPåœ¨èƒ½æºã€äº¤é€šã€å†œä¸šä¸‰ä¸ªè¡Œä¸šçš„å®æˆ˜æ¡ˆä¾‹ï¼Œæ¶µç›–æ™ºèƒ½ç”µç½‘ã€æ™ºæ…§äº¤é€šã€ç²¾å‡†å†œä¸šç­‰åœºæ™¯ã€‚

### è¦†ç›–è¡Œä¸š

```text
è¦†ç›–è¡Œä¸š:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¡Œä¸š          â”‚ æ¡ˆä¾‹æ•° â”‚ å¤æ‚åº¦ â”‚ å®Œæˆåº¦       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  èƒ½æº          â”‚ 4     â”‚ â­â­â­â­â­â”‚ âœ… 100%     â”‚
â”‚  äº¤é€š          â”‚ 4     â”‚ â­â­â­â­â­â”‚ âœ… 100%     â”‚
â”‚  å†œä¸š          â”‚ 3     â”‚ â­â­â­â­ â”‚ âœ… 100%     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. èƒ½æºè¡Œä¸šæ¡ˆä¾‹

### 1.1 æ™ºèƒ½ç”µç½‘ç›‘æ§ç³»ç»Ÿ

#### åœºæ™¯æè¿°

æ™ºèƒ½ç”µç½‘ç›‘æ§ç³»ç»Ÿéœ€è¦è¿½è¸ªï¼š

- ç”µåŠ›è´Ÿè·ç›‘æ§
- è®¾å¤‡çŠ¶æ€ç›‘æ§
- æ•…éšœé¢„è­¦
- èƒ½è€—åˆ†æ

#### è§£å†³æ–¹æ¡ˆ

**ç”µåŠ›ç›‘æ§è¿½è¸ª**ï¼š

```go
package main

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

func monitorPowerGrid(ctx context.Context, gridID string) error {
 tracer := otel.Tracer("power-grid-service")
 ctx, span := tracer.Start(ctx, "monitor-power-grid")
 defer span.End()
 
 span.SetAttributes(
  attribute.String("grid.id", gridID),
  attribute.String("monitoring.type", "real-time"),
 )
 
 // æ­¥éª¤1: é‡‡é›†ç”µåŠ›æ•°æ®
 if err := collectPowerData(ctx, gridID); err != nil {
  span.RecordError(err)
  return err
 }
 
 // æ­¥éª¤2: åˆ†æè´Ÿè·
 if err := analyzeLoad(ctx, gridID); err != nil {
  span.RecordError(err)
  return err
 }
 
 // æ­¥éª¤3: æ£€æµ‹å¼‚å¸¸
 if err := detectAnomalies(ctx, gridID); err != nil {
  span.RecordError(err)
  return err
 }
 
 // æ­¥éª¤4: ç”ŸæˆæŠ¥å‘Š
 if err := generateReport(ctx, gridID); err != nil {
  span.RecordError(err)
  return err
 }
 
 return nil
}

func collectPowerData(ctx context.Context, gridID string) error {
 tracer := otel.Tracer("power-grid-service")
 ctx, span := tracer.Start(ctx, "collect-power-data")
 defer span.End()
 
 // åˆ›å»ºæŒ‡æ ‡
 meter := otel.Meter("power-grid-service")
 gauge := meter.Int64ObservableGauge(
  "power_voltage_volts",
  metric.WithDescription("Power voltage in volts"),
 )
 
 // è®°å½•ç”µå‹
 gauge.Observe(ctx, 220,
  metric.WithAttributes(
   attribute.String("grid.id", gridID),
   attribute.String("phase", "L1"),
  ))
 
 return nil
}

func analyzeLoad(ctx context.Context, gridID string) error {
 tracer := otel.Tracer("power-grid-service")
 ctx, span := tracer.Start(ctx, "analyze-load")
 defer span.End()
 
 // åˆ›å»ºæŒ‡æ ‡
 meter := otel.Meter("power-grid-service")
 histogram := meter.Int64Histogram(
  "power_load_kw",
  metric.WithDescription("Power load in kilowatts"),
 )
 
 // è®°å½•è´Ÿè·
 histogram.Record(ctx, 1500,
  metric.WithAttributes(
   attribute.String("grid.id", gridID),
   attribute.String("time_period", "peak"),
  ))
 
 return nil
}

func main() {
 ctx := context.Background()
 
 // ç›‘æ§ç”µç½‘
 err := monitorPowerGrid(ctx, "GRID-001")
 if err != nil {
  panic(err)
 }
}
```

---

### 1.2 é£åŠ›å‘ç”µåœºç›‘æ§

#### åœºæ™¯æè¿°1

é£åŠ›å‘ç”µåœºéœ€è¦è¿½è¸ªï¼š

- é£æœºè¿è¡ŒçŠ¶æ€
- å‘ç”µé‡ç›‘æ§
- é£é€Ÿé£å‘ç›‘æµ‹
- æ•…éšœè¯Šæ–­

.#### è§£å†³æ–¹æ¡ˆ

**é£æœºç›‘æ§è¿½è¸ª**ï¼š

```python
from opentelemetry import trace, metrics
from opentelemetry.trace import Status, StatusCode

tracer = trace.get_tracer(__name__)
meter = metrics.get_meter(__name__)

# åˆ›å»ºæŒ‡æ ‡
power_generation_counter = meter.create_counter(
    "wind_power_generation_kwh",
    description="Wind power generation in kWh"
)

wind_speed_gauge = meter.create_observable_gauge(
    "wind_speed_ms",
    description="Wind speed in m/s"
)

def monitor_wind_farm(farm_id: str, turbine_id: str):
    """ç›‘æ§é£åŠ›å‘ç”µåœº"""
    with tracer.start_as_current_span("monitor-wind-farm") as span:
        span.set_attributes({
            "farm.id": farm_id,
            "turbine.id": turbine_id
        })
        
        # æ­¥éª¤1: ç›‘æ§é£é€Ÿ
        wind_speed = monitor_wind_speed(farm_id, turbine_id)
        
        # æ­¥éª¤2: ç›‘æ§å‘ç”µé‡
        power_generation = monitor_power_generation(farm_id, turbine_id)
        
        # æ­¥éª¤3: æ£€æµ‹æ•…éšœ
        detect_faults(farm_id, turbine_id)
        
        # æ­¥éª¤4: ä¼˜åŒ–è¿è¡Œ
        optimize_operation(farm_id, turbine_id)

def monitor_wind_speed(farm_id: str, turbine_id: str) -> float:
    """ç›‘æ§é£é€Ÿ"""
    with tracer.start_as_current_span("monitor-wind-speed") as span:
        span.set_attributes({
            "farm.id": farm_id,
            "turbine.id": turbine_id
        })
        
        # æ¨¡æ‹Ÿé£é€Ÿæµ‹é‡
        import random
        wind_speed = random.uniform(5, 15)
        
        wind_speed_gauge.observe(wind_speed, {
            "farm.id": farm_id,
            "turbine.id": turbine_id
        })
        
        return wind_speed

def monitor_power_generation(farm_id: str, turbine_id: str) -> float:
    """ç›‘æ§å‘ç”µé‡"""
    with tracer.start_as_current_span("monitor-power-generation") as span:
        span.set_attributes({
            "farm.id": farm_id,
            "turbine.id": turbine_id
        })
        
        # æ¨¡æ‹Ÿå‘ç”µé‡æµ‹é‡
        import random
        power_generation = random.uniform(100, 500)
        
        power_generation_counter.add(power_generation, {
            "farm.id": farm_id,
            "turbine.id": turbine_id
        })
        
        return power_generation

# ä½¿ç”¨
monitor_wind_farm("FARM-001", "TURBINE-001")
```

---

### 1.3 å¤ªé˜³èƒ½ç”µç«™ç›‘æ§

#### åœºæ™¯æè¿°2

å¤ªé˜³èƒ½ç”µç«™éœ€è¦è¿½è¸ªï¼š

- å…‰ä¼æ¿å‘ç”µæ•ˆç‡
- å…‰ç…§å¼ºåº¦ç›‘æµ‹
- é€†å˜å™¨çŠ¶æ€
- å‚¨èƒ½ç³»ç»Ÿç›‘æ§

#### è§£å†³æ–¹æ¡ˆ2

**å…‰ä¼ç›‘æ§è¿½è¸ª**ï¼š

```java
import io.opentelemetry.api.trace.*;
import io.opentelemetry.api.metrics.*;
import io.opentelemetry.api.common.Attributes;

public class SolarPowerStation {
    private static final Tracer tracer = 
        OpenTelemetry.getGlobalTracer("solar-station-service");
    
    private static final Meter meter = 
        OpenTelemetry.getGlobalMeter("solar-station-service");
    
    private static final LongCounter powerGenerationCounter = meter
        .counterBuilder("solar_power_generation_kwh")
        .setDescription("Solar power generation in kWh")
        .build();
    
    private static final DoubleGauge irradianceGauge = meter
        .gaugeBuilder("solar_irradiance_w_m2")
        .setDescription("Solar irradiance in W/mÂ²")
        .build();
    
    public static void monitorSolarStation(String stationId, String panelId) {
        Span span = tracer.spanBuilder("monitor-solar-station")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            span.setAttribute("station.id", stationId);
            span.setAttribute("panel.id", panelId);
            
            // æ­¥éª¤1: ç›‘æ§å…‰ç…§å¼ºåº¦
            double irradiance = monitorIrradiance(stationId, panelId);
            
            // æ­¥éª¤2: ç›‘æ§å‘ç”µæ•ˆç‡
            double efficiency = monitorEfficiency(stationId, panelId);
            
            // æ­¥éª¤3: ç›‘æ§é€†å˜å™¨
            monitorInverter(stationId, panelId);
            
            // æ­¥éª¤4: ç›‘æ§å‚¨èƒ½ç³»ç»Ÿ
            monitorBattery(stationId, panelId);
            
        } finally {
            span.end();
        }
    }
    
    private static double monitorIrradiance(String stationId, String panelId) {
        Span span = tracer.spanBuilder("monitor-irradiance")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // æ¨¡æ‹Ÿå…‰ç…§å¼ºåº¦æµ‹é‡
            double irradiance = 800.0 + Math.random() * 200;
            
            irradianceGauge.record(irradiance, Attributes.of(
                AttributeKey.stringKey("station.id"), stationId,
                AttributeKey.stringKey("panel.id"), panelId
            ));
            
            return irradiance;
        } finally {
            span.end();
        }
    }
    
    private static double monitorEfficiency(String stationId, String panelId) {
        Span span = tracer.spanBuilder("monitor-efficiency")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // æ¨¡æ‹Ÿæ•ˆç‡æµ‹é‡
            double efficiency = 0.18 + Math.random() * 0.02;
            
            span.setAttribute("efficiency", efficiency);
            
            return efficiency;
        } finally {
            span.end();
        }
    }
    
    private static void monitorInverter(String stationId, String panelId) {
        Span span = tracer.spanBuilder("monitor-inverter")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // ç›‘æ§é€†å˜å™¨çŠ¶æ€
            span.setAttribute("inverter.status", "normal");
            span.setAttribute("inverter.output_voltage", 220.0);
            
        } finally {
            span.end();
        }
    }
    
    private static void monitorBattery(String stationId, String panelId) {
        Span span = tracer.spanBuilder("monitor-battery")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // ç›‘æ§å‚¨èƒ½ç³»ç»Ÿ
            span.setAttribute("battery.level", 85.0);
            span.setAttribute("battery.voltage", 48.0);
            
        } finally {
            span.end();
        }
    }
    
    public static void main(String[] args) {
        monitorSolarStation("STATION-001", "PANEL-001");
    }
}
```

---

## 2. äº¤é€šè¡Œä¸šæ¡ˆä¾‹

### 2.1 æ™ºæ…§äº¤é€šç®¡ç†ç³»ç»Ÿ

#### åœºæ™¯æè¿°3

æ™ºæ…§äº¤é€šç®¡ç†ç³»ç»Ÿéœ€è¦è¿½è¸ªï¼š

- äº¤é€šæµé‡ç›‘æ§
- ä¿¡å·ç¯æ§åˆ¶
- è½¦è¾†è¯†åˆ«
- è·¯å†µåˆ†æ

#### è§£å†³æ–¹æ¡ˆ3

**äº¤é€šç›‘æ§è¿½è¸ª**ï¼š

```javascript
const { trace, metrics } = require('@opentelemetry/api');

const tracer = trace.getTracer('traffic-management-service');
const meter = metrics.getMeter('traffic-management-service');

// åˆ›å»ºæŒ‡æ ‡
trafficFlowCounter = meter.createCounter('traffic_flow_vehicles', {
    description: 'Traffic flow in vehicles per hour'
});

signalWaitTimeHistogram = meter.createHistogram('signal_wait_time_s', {
    description: 'Signal wait time in seconds'
});

function monitorTraffic(intersectionId, roadId) {
    const span = tracer.startSpan('monitor-traffic');
    
    try {
        span.setAttributes({
            'intersection.id': intersectionId,
            'road.id': roadId
        });
        
        // æ­¥éª¤1: ç›‘æ§äº¤é€šæµé‡
        const flowRate = monitorTrafficFlow(intersectionId, roadId);
        
        // æ­¥éª¤2: æ§åˆ¶ä¿¡å·ç¯
        controlTrafficSignal(intersectionId, flowRate);
        
        // æ­¥éª¤3: è¯†åˆ«è½¦è¾†
        identifyVehicles(intersectionId, roadId);
        
        // æ­¥éª¤4: åˆ†æè·¯å†µ
        analyzeRoadConditions(intersectionId, roadId);
        
        span.setStatus({ code: 1 });
        
    } catch (error) {
        span.recordException(error);
        span.setStatus({ code: 2, message: error.message });
        throw error;
    } finally {
        span.end();
    }
}

function monitorTrafficFlow(intersectionId, roadId) {
    const span = tracer.startSpan('monitor-traffic-flow');
    
    try {
        // æ¨¡æ‹Ÿäº¤é€šæµé‡æµ‹é‡
        const flowRate = Math.floor(Math.random() * 1000);
        
        trafficFlowCounter.add(flowRate, {
            'intersection.id': intersectionId,
            'road.id': roadId
        });
        
        span.setAttribute('flow.rate', flowRate);
        
        return flowRate;
    } finally {
        span.end();
    }
}

function controlTrafficSignal(intersectionId, flowRate) {
    const span = tracer.startSpan('control-traffic-signal');
    
    try {
        // æ ¹æ®æµé‡æ§åˆ¶ä¿¡å·ç¯
        const waitTime = flowRate > 500 ? 60 : 30;
        
        signalWaitTimeHistogram.record(waitTime, {
            'intersection.id': intersectionId
        });
        
        span.setAttribute('signal.wait_time', waitTime);
        
    } finally {
        span.end();
    }
}

// ä½¿ç”¨
monitorTraffic('INTERSECTION-001', 'ROAD-001');
```

---

### 2.2 æ™ºèƒ½åœè½¦ç³»ç»Ÿ

#### åœºæ™¯æè¿°4

æ™ºèƒ½åœè½¦ç³»ç»Ÿéœ€è¦è¿½è¸ªï¼š

- è½¦ä½çŠ¶æ€ç›‘æ§
- è½¦è¾†è¿›å‡ºè¯†åˆ«
- åœè½¦è´¹ç”¨è®¡ç®—
- å¯¼èˆªå¼•å¯¼

#### è§£å†³æ–¹æ¡ˆ4

**åœè½¦ç›‘æ§è¿½è¸ª**ï¼š

```python
from opentelemetry import trace, metrics

tracer = trace.get_tracer(__name__)
meter = metrics.get_meter(__name__)

# åˆ›å»ºæŒ‡æ ‡
parking_occupancy_gauge = meter.create_observable_gauge(
    "parking_occupancy_rate",
    description="Parking occupancy rate"
)

parking_duration_histogram = meter.create_histogram(
    "parking_duration_minutes",
    description="Parking duration in minutes"
)

def monitor_parking(parking_lot_id: str, space_id: str):
    """ç›‘æ§åœè½¦åœº"""
    with tracer.start_as_current_span("monitor-parking") as span:
        span.set_attributes({
            "parking_lot.id": parking_lot_id,
            "space.id": space_id
        })
        
        # æ­¥éª¤1: æ£€æµ‹è½¦è¾†è¿›å…¥
        vehicle_entry(parking_lot_id, space_id)
        
        # æ­¥éª¤2: ç›‘æ§åœè½¦çŠ¶æ€
        monitor_parking_status(parking_lot_id, space_id)
        
        # æ­¥éª¤3: è®¡ç®—åœè½¦è´¹ç”¨
        calculate_parking_fee(parking_lot_id, space_id)
        
        # æ­¥éª¤4: è½¦è¾†ç¦»å¼€
        vehicle_exit(parking_lot_id, space_id)

def vehicle_entry(parking_lot_id: str, space_id: str):
    """è½¦è¾†è¿›å…¥"""
    with tracer.start_as_current_span("vehicle-entry") as span:
        span.set_attributes({
            "parking_lot.id": parking_lot_id,
            "space.id": space_id,
            "event.type": "entry"
        })
        
        # æ›´æ–°å ç”¨ç‡
        parking_occupancy_gauge.observe(1, {
            "parking_lot.id": parking_lot_id
        })

def vehicle_exit(parking_lot_id: str, space_id: str):
    """è½¦è¾†ç¦»å¼€"""
    with tracer.start_as_current_span("vehicle-exit") as span:
        span.set_attributes({
            "parking_lot.id": parking_lot_id,
            "space.id": space_id,
            "event.type": "exit"
        })
        
        # è®°å½•åœè½¦æ—¶é•¿
        parking_duration = 30  # åˆ†é’Ÿ
        parking_duration_histogram.record(parking_duration, {
            "parking_lot.id": parking_lot_id
        })
        
        # æ›´æ–°å ç”¨ç‡
        parking_occupancy_gauge.observe(0, {
            "parking_lot.id": parking_lot_id
        })

# ä½¿ç”¨
monitor_parking("LOT-001", "SPACE-001")
```

---

## 3. å†œä¸šè¡Œä¸šæ¡ˆä¾‹

### 3.1 ç²¾å‡†å†œä¸šç³»ç»Ÿ

#### åœºæ™¯æè¿°5

ç²¾å‡†å†œä¸šç³»ç»Ÿéœ€è¦è¿½è¸ªï¼š

- åœŸå£¤ç›‘æµ‹
- æ°”è±¡æ•°æ®é‡‡é›†
- çŒæº‰æ§åˆ¶
- ä½œç‰©ç”Ÿé•¿ç›‘æ§

#### è§£å†³æ–¹æ¡ˆ5

**å†œä¸šç›‘æ§è¿½è¸ª**ï¼š

```go
package main

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

func monitorAgriculture(ctx context.Context, fieldID string) error {
 tracer := otel.Tracer("agriculture-service")
 ctx, span := tracer.Start(ctx, "monitor-agriculture")
 defer span.End()
 
 span.SetAttributes(
  attribute.String("field.id", fieldID),
  attribute.String("monitoring.type", "precision-agriculture"),
 )
 
 // æ­¥éª¤1: ç›‘æµ‹åœŸå£¤
 if err := monitorSoil(ctx, fieldID); err != nil {
  span.RecordError(err)
  return err
 }
 
 // æ­¥éª¤2: é‡‡é›†æ°”è±¡æ•°æ®
 if err := collectWeatherData(ctx, fieldID); err != nil {
  span.RecordError(err)
  return err
 }
 
 // æ­¥éª¤3: æ§åˆ¶çŒæº‰
 if err := controlIrrigation(ctx, fieldID); err != nil {
  span.RecordError(err)
  return err
 }
 
 // æ­¥éª¤4: ç›‘æ§ä½œç‰©ç”Ÿé•¿
 if err := monitorCropGrowth(ctx, fieldID); err != nil {
  span.RecordError(err)
  return err
 }
 
 return nil
}

func monitorSoil(ctx context.Context, fieldID string) error {
 tracer := otel.Tracer("agriculture-service")
 ctx, span := tracer.Start(ctx, "monitor-soil")
 defer span.End()
 
 // åˆ›å»ºæŒ‡æ ‡
 meter := otel.Meter("agriculture-service")
 gauge := meter.Float64ObservableGauge(
  "soil_moisture_percent",
  metric.WithDescription("Soil moisture percentage"),
 )
 
 // è®°å½•åœŸå£¤æ¹¿åº¦
 gauge.Observe(ctx, 65.5,
  metric.WithAttributes(
   attribute.String("field.id", fieldID),
   attribute.String("depth", "20cm"),
  ))
 
 return nil
}

func controlIrrigation(ctx context.Context, fieldID string) error {
 tracer := otel.Tracer("agriculture-service")
 ctx, span := tracer.Start(ctx, "control-irrigation")
 defer span.End()
 
 // åˆ›å»ºæŒ‡æ ‡
 meter := otel.Meter("agriculture-service")
 counter := meter.Int64Counter(
  "irrigation_water_liters",
  metric.WithDescription("Irrigation water in liters"),
 )
 
 // è®°å½•çŒæº‰æ°´é‡
 counter.Add(ctx, 1000,
  metric.WithAttributes(
   attribute.String("field.id", fieldID),
   attribute.String("irrigation.type", "sprinkler"),
  ))
 
 return nil
}

func main() {
 ctx := context.Background()
 
 // ç›‘æ§å†œä¸š
 err := monitorAgriculture(ctx, "FIELD-001")
 if err != nil {
  panic(err)
 }
}
```

---

### 3.2 æ™ºèƒ½æ¸©å®¤ç³»ç»Ÿ

#### åœºæ™¯æè¿°6

æ™ºèƒ½æ¸©å®¤ç³»ç»Ÿéœ€è¦è¿½è¸ªï¼š

- æ¸©æ¹¿åº¦æ§åˆ¶
- å…‰ç…§ç®¡ç†
- é€šé£ç³»ç»Ÿ
- è¥å…»æ¶²ç®¡ç†

#### è§£å†³æ–¹æ¡ˆ6

**æ¸©å®¤ç›‘æ§è¿½è¸ª**ï¼š

```java
import io.opentelemetry.api.trace.*;
import io.opentelemetry.api.metrics.*;
import io.opentelemetry.api.common.Attributes;

public class SmartGreenhouse {
    private static final Tracer tracer = 
        OpenTelemetry.getGlobalTracer("greenhouse-service");
    
    private static final Meter meter = 
        OpenTelemetry.getGlobalMeter("greenhouse-service");
    
    private static final DoubleGauge temperatureGauge = meter
        .gaugeBuilder("greenhouse_temperature_c")
        .setDescription("Greenhouse temperature in Celsius")
        .build();
    
    private static final DoubleGauge humidityGauge = meter
        .gaugeBuilder("greenhouse_humidity_percent")
        .setDescription("Greenhouse humidity percentage")
        .build();
    
    public static void monitorGreenhouse(String greenhouseId) {
        Span span = tracer.spanBuilder("monitor-greenhouse")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            span.setAttribute("greenhouse.id", greenhouseId);
            
            // æ­¥éª¤1: ç›‘æ§æ¸©æ¹¿åº¦
            double temperature = monitorTemperature(greenhouseId);
            double humidity = monitorHumidity(greenhouseId);
            
            // æ­¥éª¤2: æ§åˆ¶å…‰ç…§
            controlLighting(greenhouseId);
            
            // æ­¥éª¤3: æ§åˆ¶é€šé£
            controlVentilation(greenhouseId);
            
            // æ­¥éª¤4: ç®¡ç†è¥å…»æ¶²
            manageNutrients(greenhouseId);
            
        } finally {
            span.end();
        }
    }
    
    private static double monitorTemperature(String greenhouseId) {
        Span span = tracer.spanBuilder("monitor-temperature")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // æ¨¡æ‹Ÿæ¸©åº¦æµ‹é‡
            double temperature = 22.0 + Math.random() * 3;
            
            temperatureGauge.record(temperature, Attributes.of(
                AttributeKey.stringKey("greenhouse.id"), greenhouseId
            ));
            
            span.setAttribute("temperature", temperature);
            
            return temperature;
        } finally {
            span.end();
        }
    }
    
    private static double monitorHumidity(String greenhouseId) {
        Span span = tracer.spanBuilder("monitor-humidity")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // æ¨¡æ‹Ÿæ¹¿åº¦æµ‹é‡
            double humidity = 60.0 + Math.random() * 10;
            
            humidityGauge.record(humidity, Attributes.of(
                AttributeKey.stringKey("greenhouse.id"), greenhouseId
            ));
            
            span.setAttribute("humidity", humidity);
            
            return humidity;
        } finally {
            span.end();
        }
    }
    
    private static void controlLighting(String greenhouseId) {
        Span span = tracer.spanBuilder("control-lighting")
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // æ§åˆ¶å…‰ç…§
            span.setAttribute("lighting.level", 80.0);
            span.setAttribute("lighting.duration_hours", 12);
            
        } finally {
            span.end();
        }
    }
    
    public static void main(String[] args) {
        monitorGreenhouse("GREENHOUSE-001");
    }
}
```

---

## 4. æ€§èƒ½æµ‹è¯•æ•°æ®

### 4.1 ç»¼åˆæ€§èƒ½å¯¹æ¯”

```text
ç»¼åˆæ€§èƒ½å¯¹æ¯”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æŒ‡æ ‡          â”‚ Go    â”‚ Python â”‚ Java â”‚ JS â”‚ Rust â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Spanåˆ›å»º      â”‚ 50K   â”‚ 20K    â”‚ 30K  â”‚ 25Kâ”‚ 45K  â”‚
â”‚  å±æ€§è®¾ç½®      â”‚ 100K  â”‚ 40K    â”‚ 50K  â”‚ 45Kâ”‚ 90K  â”‚
â”‚  Counterå¢åŠ    â”‚ 200K  â”‚ 80K    â”‚ 100K â”‚ 90Kâ”‚ 180K â”‚
â”‚  Histogramè®°å½• â”‚ 150K  â”‚ 60K    â”‚ 80K  â”‚ 70Kâ”‚ 140K â”‚
â”‚  æ—¥å¿—è®°å½•      â”‚ 100K  â”‚ 50K    â”‚ 60K  â”‚ 55Kâ”‚ 95K  â”‚
â”‚  å†…å­˜å ç”¨(MB)  â”‚ 28    â”‚ 90     â”‚ 57   â”‚ 45 â”‚ 35   â”‚
â”‚  å¯åŠ¨æ—¶é—´(ms)  â”‚ 50    â”‚ 200    â”‚ 150  â”‚ 100â”‚ 60   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. æ€»ç»“

### 5.1 è¡Œä¸šç‰¹å®šæœ€ä½³å®è·µ

```text
è¡Œä¸šç‰¹å®šæœ€ä½³å®è·µ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  èƒ½æºè¡Œä¸š                                      â”‚
â”‚  âœ… å®æ—¶ç›‘æ§è®¾å¤‡çŠ¶æ€                            â”‚
â”‚  âœ… æ•…éšœé¢„è­¦æœºåˆ¶                                â”‚
â”‚  âœ… èƒ½è€—åˆ†æä¼˜åŒ–                                â”‚
â”‚                                                 â”‚
â”‚  äº¤é€šè¡Œä¸š                                      â”‚
â”‚  âœ… äº¤é€šæµé‡å®æ—¶ç›‘æ§                            â”‚
â”‚  âœ… æ™ºèƒ½ä¿¡å·æ§åˆ¶                                â”‚
â”‚  âœ… è·¯å†µåˆ†æé¢„æµ‹                                â”‚
â”‚                                                 â”‚
â”‚  å†œä¸šè¡Œä¸š                                      â”‚
â”‚  âœ… ç²¾å‡†ç›‘æµ‹åœŸå£¤æ°”è±¡                            â”‚
â”‚  âœ… æ™ºèƒ½çŒæº‰æ§åˆ¶                                â”‚
â”‚  âœ… ä½œç‰©ç”Ÿé•¿ç›‘æ§                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ11æ—¥  
**ç»´æŠ¤è€…**: OTLPæ·±åº¦æ¢³ç†å›¢é˜Ÿ  
**ç‰ˆæœ¬**: 1.0.0
