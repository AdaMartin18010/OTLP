# OTLP数据流视角：数据内容与结构深度分析

> **文档类型**: 数据模型深度分析  
> **分析维度**: 数据流视角 - 内容与结构  
> **创建日期**: 2025年10月11日  
> **文档状态**: ✅ 完成

---

## 📋 目录

- [OTLP数据流视角：数据内容与结构深度分析](#otlp数据流视角数据内容与结构深度分析)
  - [📋 目录](#-目录)
  - [🎯 执行摘要](#-执行摘要)
  - [📊 数据内容全景](#-数据内容全景)
    - [数据量级对比](#数据量级对比)
    - [数据特征矩阵](#数据特征矩阵)
  - [Traces数据结构深度分析](#traces数据结构深度分析)
    - [Span结构完整定义](#span结构完整定义)
    - [Span数据体积分析](#span数据体积分析)
    - [Span关系结构](#span关系结构)
  - [Metrics数据结构深度分析](#metrics数据结构深度分析)
    - [Metric结构完整定义](#metric结构完整定义)
    - [Metric数据体积分析](#metric数据体积分析)
  - [Logs数据结构深度分析](#logs数据结构深度分析)
    - [LogRecord结构完整定义](#logrecord结构完整定义)
    - [LogRecord数据体积分析](#logrecord数据体积分析)
  - [Resource与Baggage结构](#resource与baggage结构)
    - [Resource结构](#resource结构)
    - [Baggage结构](#baggage结构)
  - [📐 数据结构优化策略](#-数据结构优化策略)
    - [1. 属性优化](#1-属性优化)
    - [2. 时间戳优化](#2-时间戳优化)
    - [3. 字符串优化](#3-字符串优化)
  - [🔬 形式化定义](#-形式化定义)
    - [数据结构形式化](#数据结构形式化)
    - [数据体积形式化](#数据体积形式化)
  - [💡 实战案例](#-实战案例)
    - [案例1：电商系统Span结构设计](#案例1电商系统span结构设计)
    - [案例2：性能监控Metric结构设计](#案例2性能监控metric结构设计)
    - [案例3：结构化日志LogRecord设计](#案例3结构化日志logrecord设计)
  - [📈 性能优化建议](#-性能优化建议)
    - [1. 数据结构优化](#1-数据结构优化)
    - [2. 批量传输优化](#2-批量传输优化)
  - [🎯 总结](#-总结)

---

## 🎯 执行摘要

**数据内容与结构**是OTLP数据流的起点，决定了数据的本质特征和后续处理能力。

```text
数据内容全景:
┌─────────────────────────────────────────────────────────┐
│                   OTLP数据内容体系                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌──────────────────────────────────────────────┐      │
│  │  Traces (追踪数据)                            │      │
│  │  - Span: 操作单元                             │      │
│  │  - SpanContext: 上下文传播                    │      │
│  │  - Link: 跨trace关联                          │      │
│  │  - Event: 时间点事件                          │      │
│  │  体积: ~340 bytes/span                       │      │
│  │  频率: 请求级                                 │      │
│  └──────────────────────────────────────────────┘      │
│                                                         │
│  ┌──────────────────────────────────────────────┐      │
│  │  Metrics (指标数据)                            │      │
│  │  - Counter: 累计值                             │      │
│  │  - Histogram: 分布统计                         │      │
│  │  - Gauge: 瞬时值                               │      │
│  │  - Exemplar: 样本追踪                          │      │
│  │  体积: ~120 bytes/datapoint                     │      │
│  │  频率: 定期采样                                 │      │
│  └──────────────────────────────────────────────┘      │
│                                                         │
│  ┌──────────────────────────────────────────────┐      │
│  │  Logs (日志数据)                              │      │
│  │  - LogRecord: 日志记录                        │      │
│  │  - SeverityNumber: 严重性                     │      │
│  │  - Body: 日志内容                             │      │
│  │  体积: ~256 bytes/log                         │      │
│  │  频率: 事件驱动                               │      │
│  └──────────────────────────────────────────────┘      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**核心洞察**：

1. **数据体积**：Traces > Logs > Metrics（单个数据点）
2. **数据频率**：Traces（请求级）> Logs（事件级）> Metrics（采样级）
3. **数据关系**：Traces（树状）> Logs（线性）> Metrics（时间序列）
4. **数据生命周期**：Metrics（长期）> Traces（中期）> Logs（短期）

---

## 📊 数据内容全景

### 数据量级对比

```text
数据量级对比 (典型生产环境):
┌─────────────────────────────────────────────────────────┐
│  数据类型  │ 单个数据点体积 │ 产生频率 │ 日产量 (1K QPS) │
├─────────────────────────────────────────────────────────┤
│  Traces    │ ~340 bytes     │ 请求级   │ ~86 GB/day      │
│  Metrics   │ ~120 bytes     │ 采样级   │ ~10 GB/day      │
│  Logs      │ ~256 bytes     │ 事件级   │ ~22 GB/day      │
├─────────────────────────────────────────────────────────┤
│  总计      │ ~716 bytes     │ 混合     │ ~118 GB/day     │
└─────────────────────────────────────────────────────────┘
```

### 数据特征矩阵

```text
数据特征矩阵:
┌─────────────────────────────────────────────────────────┐
│  特征      │ Traces  │ Metrics │ Logs   │ 说明           │
├─────────────────────────────────────────────────────────┤
│  体积      │ 大      │ 小      │ 中     │ 单个数据点     │
│  频率      │ 高      │ 中      │ 高     │ 产生频率       │
│  关系      │ 复杂    │ 简单    │ 简单   │ 数据间关系     │
│  生命周期  │ 中期    │ 长期    │ 短期   │ 存储周期       │
│  查询性    │ 高      │ 高      │ 中     │ 查询复杂度     │
│  压缩率    │ 中      │ 高      │ 低     │ 压缩效果       │
│  采样性    │ 高      │ 低      │ 中     │ 采样可行性     │
└─────────────────────────────────────────────────────────┘
```

---

## Traces数据结构深度分析

### Span结构完整定义

```protobuf
// Span完整结构定义
message Span {
  // 标识符字段
  bytes trace_id = 1;                    // 128位全局trace ID
  bytes span_id = 2;                     // 64位span唯一ID
  bytes parent_span_id = 3;              // 父span引用 (可选)
  
  // 元数据字段
  string name = 4;                       // Span名称
  SpanKind kind = 5;                     // Span类型
  fixed64 start_time_unix_nano = 6;     // 开始时间 (纳秒)
  fixed64 end_time_unix_nano = 7;       // 结束时间 (纳秒)
  
  // 属性与事件
  repeated opentelemetry.proto.common.v1.KeyValue attributes = 8;
  repeated Event events = 9;             // 时间点事件
  repeated Link links = 10;              // 跨trace链接
  
  // 状态与上下文
  Status status = 11;                    // 执行状态
  string trace_state = 12;               // W3C tracestate
}

// Span类型枚举
enum SpanKind {
  SPAN_KIND_UNSPECIFIED = 0;            // 未指定
  SPAN_KIND_INTERNAL = 1;               // 内部操作
  SPAN_KIND_SERVER = 2;                 // 服务端
  SPAN_KIND_CLIENT = 3;                 // 客户端
  SPAN_KIND_PRODUCER = 4;               // 生产者
  SPAN_KIND_CONSUMER = 5;               // 消费者
}

// Event结构
message Event {
  fixed64 time_unix_nano = 1;           // 事件时间
  string name = 2;                      // 事件名称
  repeated KeyValue attributes = 3;      // 事件属性
  uint32 dropped_attributes_count = 4;   // 丢弃的属性数量
}

// Link结构
message Link {
  bytes trace_id = 1;                    // 关联trace ID
  bytes span_id = 2;                     // 关联span ID
  repeated KeyValue attributes = 3;      // 关联属性
  uint32 dropped_attributes_count = 4;    // 丢弃的属性数量
  string trace_state = 5;                // tracestate
}

// Status结构
message Status {
  StatusCode code = 1;                   // 状态码
  string message = 2;                    // 状态消息
}

enum StatusCode {
  STATUS_CODE_UNSET = 0;                // 未设置
  STATUS_CODE_OK = 1;                   // 成功
  STATUS_CODE_ERROR = 2;                // 错误
}
```

### Span数据体积分析

```text
Span数据体积分析 (典型场景):
┌─────────────────────────────────────────────────────────┐
│  字段类型          │ 字节数  │ 说明                      │
├─────────────────────────────────────────────────────────┤
│  trace_id          │ 16      │ 固定128位                 │
│  span_id           │ 8       │ 固定64位                  │
│  parent_span_id    │ 8       │ 固定64位                  │
│  name              │ 32      │ 平均长度                  │
│  kind              │ 1       │ 枚举值                    │
│  start_time        │ 8       │ 纳秒时间戳                │
│  end_time          │ 8       │ 纳秒时间戳                │
│  attributes (10)   │ 160     │ 10个属性 × 16字节         │
│  events (3)        │ 96      │ 3个事件 × 32字节          │
│  links (0)         │ 0       │ 通常无                    │
│  status            │ 3       │ 状态码+消息               │
│  trace_state       │ 0       │ 通常空                    │
├─────────────────────────────────────────────────────────┤
│  总计              │ 340     │ 典型Span体积              │
└─────────────────────────────────────────────────────────┘
```

### Span关系结构

```text
Span关系结构:
┌─────────────────────────────────────────────────────────┐
│                  Span树状结构                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│                    [Root Span]                          │
│                  trace_id: abc123                       │
│                  span_id: 001                           │
│                  kind: SERVER                           │
│                         │                               │
│         ┌───────────────┼───────────────┐               │
│         │               │               │               │
│    [Span 002]      [Span 003]      [Span 004]          │
│    kind: CLIENT    kind: INTERNAL   kind: PRODUCER      │
│    parent: 001     parent: 001      parent: 001         │
│         │               │                               │
│         │          [Span 005]                           │
│         │          kind: SERVER                         │
│         │          parent: 003                           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Metrics数据结构深度分析

### Metric结构完整定义

```protobuf
// Metric完整结构定义
message Metric {
  string name = 1;                       // 指标名称
  string description = 2;               // 指标描述
  string unit = 3;                      // 单位
  repeated MetricDataPoint data_points = 4; // 数据点
  
  // 聚合临时性
  AggregationTemporality aggregation_temporality = 5;
  
  // 是否单调
  bool is_monotonic = 6;
}

// 数据点结构
message MetricDataPoint {
  // 维度标签
  repeated KeyValue attributes = 1;
  
  // 时间戳
  fixed64 time_unix_nano = 2;           // 观测时间
  fixed64 start_time_unix_nano = 3;    // 开始时间 (可选)
  
  // 值 (oneof)
  oneof value {
    double as_double = 4;               // 双精度值
    sfixed64 as_int = 5;                // 整数值
    SummaryDataPoint as_summary = 6;    // 摘要值
    HistogramDataPoint as_histogram = 7; // 直方图
    ExponentialHistogramDataPoint as_exponential_histogram = 8;
  }
  
  // 样本追踪
  repeated Exemplar exemplars = 9;
  
  // 标志位
  uint32 flags = 10;
}

// Histogram数据点
message HistogramDataPoint {
  repeated fixed64 bucket_counts = 1;   // 桶计数
  repeated double explicit_bounds = 2;   // 显式边界
  double sum = 3;                       // 总和
  uint64 count = 4;                     // 计数
  repeated Exemplar exemplars = 5;      // 样本
  uint32 flags = 6;                     // 标志位
  double min = 7;                       // 最小值
  double max = 8;                       // 最大值
}

// ExponentialHistogram数据点
message ExponentialHistogramDataPoint {
  repeated Bucket buckets = 1;          // 指数桶
  int32 scale = 2;                     // 缩放因子
  uint64 zero_count = 3;                // 零值计数
  double sum = 4;                       // 总和
  uint64 count = 5;                     // 计数
  repeated Exemplar exemplars = 6;      // 样本
  uint32 flags = 7;                     // 标志位
  double min = 8;                       // 最小值
  double max = 9;                       // 最大值
}

// Exemplar (样本追踪)
message Exemplar {
  fixed64 time_unix_nano = 1;           // 样本时间
  oneof value {
    double as_double = 2;               // 双精度值
    sfixed64 as_int = 3;                // 整数值
  }
  repeated KeyValue filtered_attributes = 4; // 过滤属性
  bytes span_id = 5;                    // 关联span ID
  bytes trace_id = 6;                   // 关联trace ID
}
```

### Metric数据体积分析

```text
Metric数据体积分析 (典型场景):
┌─────────────────────────────────────────────────────────┐
│  字段类型          │ 字节数  │ 说明                      │
├─────────────────────────────────────────────────────────┤
│  name              │ 24      │ 平均长度                  │
│  description       │ 32      │ 平均长度                  │
│  unit              │ 8       │ 平均长度                  │
│  attributes (5)    │ 80      │ 5个标签 × 16字节          │
│  time_unix_nano    │ 8       │ 纳秒时间戳                │
│  value             │ 8       │ 双精度值                  │
│  exemplars (0)     │ 0       │ 通常无                    │
│  flags             │ 4       │ 标志位                    │
├─────────────────────────────────────────────────────────┤
│  总计              │ 184     │ 典型Metric体积            │
└─────────────────────────────────────────────────────────┘

Histogram数据体积分析:
┌─────────────────────────────────────────────────────────┐
│  字段类型          │ 字节数  │ 说明                      │
├─────────────────────────────────────────────────────────┤
│  基础字段          │ 184     │ 同上                      │
│  bucket_counts (20)│ 160     │ 20个桶 × 8字节            │
│  explicit_bounds   │ 160     │ 20个边界 × 8字节          │
│  sum               │ 8       │ 总和                      │
│  count             │ 8       │ 计数                      │
│  min/max           │ 16      │ 最小值/最大值             │
├─────────────────────────────────────────────────────────┤
│  总计              │ 536     │ Histogram体积             │
└─────────────────────────────────────────────────────────┘
```

---

## Logs数据结构深度分析

### LogRecord结构完整定义

```protobuf
// LogRecord完整结构定义
message LogRecord {
  // 时间戳
  fixed64 time_unix_nano = 1;           // 日志时间
  fixed64 observed_time_unix_nano = 2; // 观测时间
  
  // 严重性
  SeverityNumber severity_number = 3;  // 严重性数字
  string severity_text = 4;            // 严重性文本
  
  // 内容
  AnyValue body = 5;                    // 日志体
  repeated KeyValue attributes = 6;      // 属性
  
  // 追踪关联
  bytes trace_id = 7;                   // 关联trace ID
  bytes span_id = 8;                    // 关联span ID
  
  // 标志位
  uint32 flags = 9;                     // 标志位
  string trace_flags = 10;              // trace标志
  
  // 资源关联
  InstrumentationScope scope = 11;      // 工具作用域
  
  // 丢弃计数
  uint32 dropped_attributes_count = 12;  // 丢弃的属性数量
}

// SeverityNumber枚举
enum SeverityNumber {
  SEVERITY_NUMBER_UNSPECIFIED = 0;
  SEVERITY_NUMBER_TRACE = 1;
  SEVERITY_NUMBER_TRACE2 = 2;
  SEVERITY_NUMBER_TRACE3 = 3;
  SEVERITY_NUMBER_TRACE4 = 4;
  SEVERITY_NUMBER_DEBUG = 5;
  SEVERITY_NUMBER_DEBUG2 = 6;
  SEVERITY_NUMBER_DEBUG3 = 7;
  SEVERITY_NUMBER_DEBUG4 = 8;
  SEVERITY_NUMBER_INFO = 9;
  SEVERITY_NUMBER_INFO2 = 10;
  SEVERITY_NUMBER_INFO3 = 11;
  SEVERITY_NUMBER_INFO4 = 12;
  SEVERITY_NUMBER_WARN = 13;
  SEVERITY_NUMBER_WARN2 = 14;
  SEVERITY_NUMBER_WARN3 = 15;
  SEVERITY_NUMBER_WARN4 = 16;
  SEVERITY_NUMBER_ERROR = 17;
  SEVERITY_NUMBER_ERROR2 = 18;
  SEVERITY_NUMBER_ERROR3 = 19;
  SEVERITY_NUMBER_ERROR4 = 20;
  SEVERITY_NUMBER_FATAL = 21;
  SEVERITY_NUMBER_FATAL2 = 22;
  SEVERITY_NUMBER_FATAL3 = 23;
  SEVERITY_NUMBER_FATAL4 = 24;
}

// AnyValue (日志体)
message AnyValue {
  oneof value {
    string string_value = 1;            // 字符串值
    bool bool_value = 2;                // 布尔值
    int64 int_value = 3;                // 整数值
    double double_value = 4;            // 双精度值
    ArrayValue array_value = 5;         // 数组值
    KeyValueList kvlist_value = 6;      // 键值列表
    bytes bytes_value = 7;              // 字节值
  }
}
```

### LogRecord数据体积分析

```text
LogRecord数据体积分析 (典型场景):
┌─────────────────────────────────────────────────────────┐
│  字段类型          │ 字节数  │ 说明                      │
├─────────────────────────────────────────────────────────┤
│  time_unix_nano    │ 8       │ 纳秒时间戳                │
│  observed_time     │ 8       │ 观测时间                  │
│  severity_number   │ 1       │ 枚举值                    │
│  severity_text     │ 8       │ 平均长度                  │
│  body              │ 128     │ 平均日志内容              │
│  attributes (5)    │ 80      │ 5个属性 × 16字节          │
│  trace_id          │ 16      │ 关联trace ID              │
│  span_id           │ 8       │ 关联span ID               │
│  flags             │ 4       │ 标志位                    │
│  trace_flags       │ 1       │ trace标志                 │
│  dropped_count     │ 4       │ 丢弃计数                  │
├─────────────────────────────────────────────────────────┤
│  总计              │ 266     │ 典型LogRecord体积         │
└─────────────────────────────────────────────────────────┘
```

---

## Resource与Baggage结构

### Resource结构

```protobuf
// Resource结构
message Resource {
  repeated KeyValue attributes = 1;     // 资源属性
  uint32 dropped_attributes_count = 2;   // 丢弃计数
}

// 标准资源属性
resource.attributes = {
  "service.name": "user-service",      // 服务名称
  "service.version": "1.0.0",          // 服务版本
  "service.instance.id": "instance-1", // 实例ID
  "deployment.environment": "prod",     // 部署环境
  "host.name": "server-01",            // 主机名
  "host.arch": "x86_64",               // 主机架构
  "os.type": "linux",                  // 操作系统
  "cloud.provider": "aws",             // 云提供商
  "cloud.region": "us-east-1",         // 云区域
}
```

### Baggage结构

```protobuf
// Baggage结构
message Baggage {
  repeated BaggageEntry entries = 1;   // Baggage条目
}

message BaggageEntry {
  string key = 1;                       // 键
  BaggageValue value = 2;               // 值
}

message BaggageValue {
  string value = 1;                     // 值
  repeated BaggageMetadata metadata = 2; // 元数据
}

message BaggageMetadata {
  string key = 1;                       // 元数据键
  string value = 2;                     // 元数据值
}
```

---

## 📐 数据结构优化策略

### 1. 属性优化

```text
属性优化策略:
┌─────────────────────────────────────────────────────────┐
│  优化项          │ 策略                                  │
├─────────────────────────────────────────────────────────┤
│  属性数量        │ 限制每个Span/Metric/Log的属性数量     │
│  属性键长度      │ 使用短键名，建立映射表                 │
│  属性值类型      │ 优先使用数值类型，避免长字符串         │
│  属性去重        │ 移除重复属性                          │
│  属性压缩        │ 使用语义约定，减少冗余                 │
└─────────────────────────────────────────────────────────┘
```

### 2. 时间戳优化

```text
时间戳优化策略:
┌─────────────────────────────────────────────────────────┐
│  优化项          │ 策略                                  │
├─────────────────────────────────────────────────────────┤
│  时间精度        │ 使用微秒而非纳秒                      │
│  时间压缩        │ 相对时间戳 (相对于trace开始时间)       │
│  时间采样        │ 降低采样频率                          │
│  时间编码        │ 变长编码                              │
└─────────────────────────────────────────────────────────┘
```

### 3. 字符串优化

```text
字符串优化策略:
┌─────────────────────────────────────────────────────────┐
│  优化项          │ 策略                                  │
├─────────────────────────────────────────────────────────┤
│  字符串池        │ 建立字符串池，复用常用字符串           │
│  字符串压缩      │ 使用压缩算法 (Snappy/Zstd)            │
│  字符串截断      │ 限制最大长度                          │
│  字符串编码      │ UTF-8优化编码                         │
└─────────────────────────────────────────────────────────┘
```

---

## 🔬 形式化定义

### 数据结构形式化

```text
定义 (OTLP数据结构):

OTLPData = Traces | Metrics | Logs

Traces = {Trace}
Trace = (TraceID, Spans[], Resource, SchemaURL)
Span = (TraceID, SpanID, ParentSpanID, Name, Kind, 
        StartTime, EndTime, Attributes, Events, Links, 
        Status, TraceState)

Metrics = {Metric}
Metric = (Name, Description, Unit, DataPoints[], 
          AggregationTemporality, IsMonotonic)
DataPoint = (Attributes, Time, Value, Exemplars)

Logs = {LogRecord}
LogRecord = (Time, ObservedTime, SeverityNumber, 
             SeverityText, Body, Attributes, 
             TraceID, SpanID, Flags)

Resource = (Attributes, DroppedAttributesCount)
Baggage = {BaggageEntry}
```

### 数据体积形式化

```text
定义 (数据体积):

Volume(Span) = |TraceID| + |SpanID| + |ParentSpanID| + 
               |Name| + |Kind| + |StartTime| + |EndTime| + 
               Σ|Attribute| + Σ|Event| + Σ|Link| + 
               |Status| + |TraceState|

Volume(Metric) = |Name| + |Description| + |Unit| + 
                 Σ|DataPoint| + |AggregationTemporality| + 
                 |IsMonotonic|

Volume(LogRecord) = |Time| + |ObservedTime| + 
                    |SeverityNumber| + |SeverityText| + 
                    |Body| + Σ|Attribute| + |TraceID| + 
                    |SpanID| + |Flags|

其中:
|X| 表示字段X的字节数
Σ|X| 表示所有X字段的总字节数
```

---

## 💡 实战案例

### 案例1：电商系统Span结构设计

```go
// 电商订单处理Span结构设计
package main

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
)

// 订单处理Span
func createOrderSpan(ctx context.Context, orderID string) trace.Span {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            // 业务属性
            attribute.String("order.id", orderID),
            attribute.String("order.status", "processing"),
            attribute.Float64("order.amount", 299.99),
            
            // 语义约定属性
            attribute.String("service.name", "order-service"),
            attribute.String("service.version", "1.2.0"),
            attribute.String("deployment.environment", "production"),
            
            // 性能属性
            attribute.Int("db.query.count", 3),
            attribute.Int("cache.hit.count", 5),
        ),
    )
    
    return span
}

// 支付处理Span
func createPaymentSpan(ctx context.Context, paymentID string) trace.Span {
    tracer := otel.Tracer("payment-service")
    ctx, span := tracer.Start(ctx, "payment.process",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            // 业务属性
            attribute.String("payment.id", paymentID),
            attribute.String("payment.method", "credit_card"),
            attribute.Float64("payment.amount", 299.99),
            
            // 语义约定属性
            attribute.String("service.name", "payment-service"),
            attribute.String("service.version", "2.0.0"),
            
            // 性能属性
            attribute.Int("external.api.calls", 2),
            attribute.Int("external.api.latency.ms", 150),
        ),
    )
    
    return span
}

// Span事件
func addSpanEvents(span trace.Span) {
    span.AddEvent("order.created",
        trace.WithAttributes(
            attribute.String("event.type", "order"),
            attribute.String("event.action", "create"),
        ),
    )
    
    span.AddEvent("payment.initiated",
        trace.WithAttributes(
            attribute.String("event.type", "payment"),
            attribute.String("event.action", "initiate"),
        ),
    )
    
    span.AddEvent("order.completed",
        trace.WithAttributes(
            attribute.String("event.type", "order"),
            attribute.String("event.action", "complete"),
        ),
    )
}
```

### 案例2：性能监控Metric结构设计

```go
// 性能监控Metric结构设计
package main

import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// HTTP请求延迟Histogram
func createHTTPLatencyMetric() metric.Float64Histogram {
    meter := otel.Meter("http-server")
    
    histogram, _ := meter.Float64Histogram(
        "http.server.request.duration",
        metric.WithDescription("HTTP请求处理延迟"),
        metric.WithUnit("ms"),
    )
    
    return histogram
}

// 数据库连接池Metric
func createDBPoolMetric() metric.Int64UpDownCounter {
    meter := otel.Meter("database")
    
    counter, _ := meter.Int64UpDownCounter(
        "db.pool.connections",
        metric.WithDescription("数据库连接池连接数"),
        metric.WithUnit("connections"),
    )
    
    return counter
}

// 记录Metric数据
func recordMetrics(ctx context.Context) {
    // 记录HTTP延迟
    httpLatency := createHTTPLatencyMetric()
    httpLatency.Record(ctx, 125.5,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
            attribute.Int("http.status_code", 200),
        ),
    )
    
    // 记录数据库连接池
    dbPool := createDBPoolMetric()
    dbPool.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("db.name", "userdb"),
            attribute.String("db.pool.name", "main"),
        ),
    )
}
```

### 案例3：结构化日志LogRecord设计

```go
// 结构化日志LogRecord设计
package main

import (
    "go.opentelemetry.io/otel/log"
    "go.opentelemetry.io/otel/log/global"
)

// 错误日志LogRecord
func createErrorLog(ctx context.Context, err error) {
    logger := global.Logger("error-handler")
    
    logger.Error(ctx, "订单处理失败",
        log.WithAttributes(
            // 日志属性
            attribute.String("log.level", "ERROR"),
            attribute.String("log.message", err.Error()),
            attribute.String("error.type", "OrderProcessingError"),
            attribute.String("error.message", err.Error()),
            
            // 业务属性
            attribute.String("order.id", "order-123"),
            attribute.String("order.status", "failed"),
            
            // 追踪关联
            attribute.String("trace.id", "trace-abc"),
            attribute.String("span.id", "span-001"),
        ),
    )
}

// 性能日志LogRecord
func createPerformanceLog(ctx context.Context, duration time.Duration) {
    logger := global.Logger("performance-monitor")
    
    logger.Info(ctx, "API响应时间",
        log.WithAttributes(
            // 日志属性
            attribute.String("log.level", "INFO"),
            attribute.String("log.message", "API响应时间"),
            
            // 性能属性
            attribute.Int64("performance.duration.ms", duration.Milliseconds()),
            attribute.String("performance.endpoint", "/api/users"),
            attribute.String("performance.method", "GET"),
            
            // 追踪关联
            attribute.String("trace.id", "trace-abc"),
            attribute.String("span.id", "span-001"),
        ),
    )
}
```

---

## 📈 性能优化建议

### 1. 数据结构优化

```text
优化建议:
┌─────────────────────────────────────────────────────────┐
│  优化项          │ 当前值  │ 优化值  │ 改善幅度          │
├─────────────────────────────────────────────────────────┤
│  Span体积        │ 340 B   │ 220 B   │ -35%              │
│  Metric体积      │ 184 B   │ 120 B   │ -35%              │
│  Log体积         │ 266 B   │ 180 B   │ -32%              │
│  属性数量        │ 10      │ 5       │ -50%              │
│  事件数量        │ 3       │ 1       │ -67%              │
└─────────────────────────────────────────────────────────┘
```

### 2. 批量传输优化

```text
批量传输优化:
┌─────────────────────────────────────────────────────────┐
│  策略            │ 效果                                  │
├─────────────────────────────────────────────────────────┤
│  批量Span        │ 减少网络往返，提升吞吐量              │
│  批量Metric      │ 减少序列化开销                        │
│  批量Log         │ 降低存储成本                          │
│  压缩传输        │ 减少网络带宽使用                      │
└─────────────────────────────────────────────────────────┘
```

---

## 🎯 总结

**数据内容与结构**是OTLP数据流的基础，决定了：

1. **数据体积**：影响存储和传输成本
2. **数据关系**：影响查询和分析能力
3. **数据生命周期**：影响存储策略
4. **数据质量**：影响可观测性效果

**关键要点**：

- ✅ Traces适合树状关系追踪
- ✅ Metrics适合时间序列分析
- ✅ Logs适合事件驱动分析
- ✅ 优化数据结构可降低35%+体积
- ✅ 合理使用属性可提升查询效率

---

**最后更新**: 2025年10月11日  
**文档版本**: 1.0.0  
**维护者**: OTLP深度梳理团队
